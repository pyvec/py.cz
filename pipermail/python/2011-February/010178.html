<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 
<!-- Mirrored from www.py.cz/pipermail/python/2011-February/010178.html by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 20 Mar 2016 21:18:09 GMT -->
<HEAD>
   <TITLE> [python] (ne)logiènost .join() ?
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:python%40py.cz?Subject=Re%3A%20%5Bpython%5D%20%3D%3Futf-8%3Fb%3FKG5lKWxvZ2nEjW5vc3QgLmpvaW4oKSA/%3F%3D&In-Reply-To=%3C20110228143841.23E2A60006DB%40mail1012.cent%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=iso-8859-2">
   <LINK REL="Previous"  HREF="http://www.py.cz/pipermail/python/2011-February/010172.html">
   <LINK REL="Next"  HREF="http://www.py.cz/pipermail/python/2011-February/010141.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[python] (ne)logiènost .join() ?</H1>
    <B>Petr Pøikryl</B> 
    <A HREF="mailto:python%40py.cz?Subject=Re%3A%20%5Bpython%5D%20%3D%3Futf-8%3Fb%3FKG5lKWxvZ2nEjW5vc3QgLmpvaW4oKSA/%3F%3D&In-Reply-To=%3C20110228143841.23E2A60006DB%40mail1012.cent%3E"
       TITLE="[python] (ne)logiènost .join() ?">prikryl na atlas.cz
       </A><BR>
    <I>Pondìlí Únor 28 15:38:41 CET 2011</I>
    <P><UL>
        <LI>Pøedchozí pøíspìvek: <A HREF="http://www.py.cz/pipermail/python/2011-February/010172.html">[python] (ne)logiènost .join() ?
</A></li>
        <LI>Následující pøíspìvek: <A HREF="http://www.py.cz/pipermail/python/2011-February/010141.html">[python] Q&amp;A server zamìøený na Python
</A></li>
         <LI> <B>Zprávy tøídìné podle:</B> 
              <a href="http://www.py.cz/pipermail/python/2011-February/date.html#10178">[ data ]</a>
              <a href="http://www.py.cz/pipermail/python/2011-February/thread.html#10178">[ vlákna ]</a>
              <a href="http://www.py.cz/pipermail/python/2011-February/subject.html#10178">[ subjektu ]</a>
              <a href="http://www.py.cz/pipermail/python/2011-February/author.html#10178">[ autora ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>
Trochu popøehazuji poøadí...

&quot;Radek&quot; &lt;<A HREF="http://www.py.cz/mailman/listinfo/python">rad... na gmail.com</A>&gt; napsal...
&gt;<i> On 23 ún, 08:08, &quot;Petr Pøikryl&quot; &lt;<A HREF="http://www.py.cz/mailman/listinfo/python">prik... na atlas.cz</A>&gt; wrote:
</I>&gt;&gt;<i> A co se týká &quot;volnì rozhozených built-in funkcí&quot;,
</I>&gt;&gt;<i> ono jich zase tak stra¹nì moc není. Nezvyklé je
</I>&gt;&gt;<i> to hlavnì pro lidi, kteøí pracovali v èistì OO
</I>&gt;&gt;<i> jazyce, který funkce nepodporuje
</I>&gt;<i> 
</I>&gt;<i> jo, asi tak nìjak. Teï by bodl dokument: &quot;Jak
</I>&gt;<i> zobjektit Python v místech kde se tomu brání,
</I>&gt;<i> resp. kde to je¹tì nikdo neudìlal.&quot;
</I>&gt;<i> 
</I>&gt;<i> To je asi to nejtrefnìj¹í: Pøesnì v místech kdy
</I>&gt;<i> Python nesleduje objektové principy to bolí, a
</I>&gt;<i> stra¹nì.
</I>
Ono je tro¹ku problematické øíci, ¾e Python nesleduje
objektové principy. V Pythonu je toti¾ objektem v¹echno.
Podle mého názoru dogma èistì objektového pøístupu, kdy je
ve¹kerá funkènost realizována metodami objektù, neodpovídá
realitì, která nás obklopuje. Neodpovídá ani matematickým
abstrakcím, které nás obklopují od základní ¹koly.

Pokud vás tedy nìco &quot;stra¹nì bolí&quot;, pak je to poru¹ení onìch
dogmat, které byste si pøál bezhlavì následovat.

Metody tøíd jsou formálním zpùsobem popisu chování objektù
dané tøídy. Vychází se z poznatku, ¾e pøi formálním zápisu
transformace vnitøního stavu objektu udìláme ménì chyb, kdy¾
popis spojíme s abstrakcí objektu dané tøídy. Vychází to ze
zku¹enosti, ¾e napøíklad v urèitém kontextu se celé èíslo 
musí chápat jako letopoèet a ne jako poèet kusù nìèeho nebo
jako zcela abstraktní èíslo. A¾ potud nelze nic namítat.

Existují ale situace, kdy chceme s urèitou hodnotou pracovat
jako s velmi abstraktní hodnotou -- jaksi &quot;bez kontextu&quot; --,
kdy jí chceme interpretaci pøidìlit a¾ v okam¾iku
zpracování. Dám pøíklad. Mnohé reálné objekty lze v urèitých
situacích popsat vektorem v trojrozmìrném prostoru. 
Pøirozeným zpùsobem mù¾eme dojít k
nìjakému dejme tomu geometrickému &quot;úhlu&quot;, který je prostì
úhlem bez bli¾¹í vazby na konkrétní objekt. Dejme tomu, ¾e
na daný úhel potøebujeme aplikovat to, èemu od základní
¹koly øíkáme funkce sinus. V takové situaci je velmi obtí¾né
pova¾ovat zápis

  objekt.vektor.úhel.sin()
  
za pøirozené vyjádøení toho, co nás u onoho úhlu daného
objektu zajímá. Mnohem pøirozenìj¹í pro nás je zápis, kdy se
úhel stane argumentem obecné funkce sin().

&gt;&gt;<i> Ka¾dý má jiný pohled na vìc a jiná oèekávání.
</I>&gt;&gt;<i> Podle mého názoru je pøístup typu
</I>&gt;&gt;<i> ','.join(kontejner) mo¾ná na první pohled
</I>&gt;&gt;<i> nezvyklý, ale na druhý pohled je velmi logický.
</I>&gt;&gt;<i> Jde o to, ¾e doká¾e spojit zadaným øetìzcem prvky
</I>&gt;&gt;<i> dodané jakýmkoliv kontejnerem, který podporuje
</I>&gt;&gt;<i> iteraci a který vrací øetìzcové prvky.
</I>&gt;<i> 
</I>&gt;<i> Zajisté, pro implemetátora má smysl to definovat
</I>&gt;<i> na jednom místì. Tak¾e by byl dobrý mixin nebo
</I>&gt;<i> tøída která implementuje metody nad iterabilními
</I>&gt;<i> kontejnery, a ty iterabilní kontejnery podìdí nebo
</I>&gt;<i> si ty metody mixnou.
</I>
Tohle je jen technický detail, který umo¾ní svázat nìjakou 
operaci s nìjakou tøídou objektu. Poøád bychom si mìli
uvìdomovat, ¾e teèková notace pou¾ívaná u OO jazykù je pouze
notací, která má usnadnit vnímání nále¾itosti metod k
objektùm. Taková notace je pøínosná v situacích, kdy máme
pocit, ¾e je její pøínos pøirozený. Tím mám na mysli to, ¾e
zápis pokud mo¾no snadno pochopí i ten (se struèným návodem),
kdo takový zápis vidí poprvé.

&gt;<i> Ale kdy¾ pracujete tak chcete psat nìco jako
</I>&gt;<i> 
</I>&gt;<i> neco.jeho_kolekce.transform.sort.jeste_transform.join
</I>
Tohle pova¾uji za pomìrnì ne¹»astné v jakémkoliv OO jazyce.
Pøesnìji, netýká se to jazyka, ale jeho pou¾ívání. Nezávisle
na tom, zda se jedná o reference nebo ukazatele... Pokud má
transformace join probíhat na konci uvedeného øetìzu, pak
musí být zaji¹tìno, ¾e pøedchozí transformace nìjak
nesel¾ou. To z hlediska robustnosti kódu nemusí být tak
samozøejmé.

&gt;<i> a nemáte chu» psát
</I>&gt;<i> 
</I>&gt;<i> join(neco.jeho_kolekce.transform.sort.jeste_transform)
</I>
Tady je potøeba si uvìdomit, ¾e metoda str.join(), o které
se tady bavíme, je velmi specifická v tom smyslu, ¾e jde o
metodu, která má spojovat nìkolik podøetìzcù do jednoho
øetìzce. Je tedy specifická v tom, ¾e pracuje nad &quot;øetìzci&quot;
ve velmi abstraktní podobì a ¾e výsledkem je zase èistý
&quot;øetìzec&quot;. V souvislosti s vý¹e uvedeným pøíkladem úhlu a
funkce sinus je to nìco podobného.

&gt;<i> obzvlá¹tì kdy¾ ten øetìzec chcete na teèce dále
</I>&gt;<i> zpracovávat.
</I>&gt;<i> 
</I>&gt;<i> neco.jeho_kolekce.transform.sort.jeste_transform
</I>&gt;<i> .join.strip.jiny_transform.split
</I>
Pøehlédl jste ale jeden detail. Na zaèátku celé transformace
vystupuje objekt nìjakého typu, který se postupnì
transformuje do kolekce øetìzcù. Potom následuje zmìna velmi
specifické kolekce øetìzcù na velmi abstraktní typ
&quot;øetìzec&quot;. Dal¹í operace probíhají nad abstraktním øetìzcem.

&gt;<i> kdy¾ to pak pøepí¹ete do závorkové notace, tak je
</I>&gt;<i> to neèitelné, proto¾e v závorkové notaci se pí¹e
</I>&gt;<i> doleva a v teèkové doprava. Pár takových závorek v
</I>&gt;<i> teèkovaném výrazu a nevyzná se v tom ani zvíøe
</I>&gt;<i> které to má v popisu práce.
</I>
Tohle není vìc teèkové/závorkové notace. To je vìc
pøehledného zápisu programu.

&gt;<i> A nebo jinak. Kolikrát v ¾ivotì jste potøebovali
</I>&gt;<i> aplikovat join na øetìzec v teèce? Já si
</I>&gt;<i> nepamatuju jediný pøípad.
</I>
Osobnì mi kroutí mozkem vyjádøení &quot;aplikovat join na øetìzec
v teèce&quot;. Ale pøitom právì zápis

    'separátor'.join(kolekce)
    
je velmi objektový. Velmi typicky se pou¾ívá napøíklad pro
vytvoøení víceøádkového øetìzce ze seznamu øádkù, které
neobsahují n:

    'n'.join(lst)
    
nebo pro vytvoøení &quot;èitelného&quot; øádku textových reprezentací 
hodnot, které se mají oddìlit èárkou a mezerou:

    ', '.join(lst)
    
A dal¹ích pøíkladù je celá øada.    

Problém je taky v tom, co by mìl obecný .join() pro kolekce
vyjadøovat. Jakého typu má být výsledek?

P.
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Pøedchozí pøíspìvek: <A HREF="http://www.py.cz/pipermail/python/2011-February/010172.html">[python] (ne)logiènost .join() ?
</A></li>
	<LI>Následující pøíspìvek: <A HREF="http://www.py.cz/pipermail/python/2011-February/010141.html">[python] Q&amp;A server zamìøený na Python
</A></li>
         <LI> <B>Zprávy tøídìné podle:</B> 
              <a href="http://www.py.cz/pipermail/python/2011-February/date.html#10178">[ data ]</a>
              <a href="http://www.py.cz/pipermail/python/2011-February/thread.html#10178">[ vlákna ]</a>
              <a href="http://www.py.cz/pipermail/python/2011-February/subject.html#10178">[ subjektu ]</a>
              <a href="http://www.py.cz/pipermail/python/2011-February/author.html#10178">[ autora ]</a>
         </LI>
       </UL>
<hr>
<a href="http://www.py.cz/mailman/listinfo/python">Dal¹í informace o konferenci Python</a><br>
</body>
<!-- Mirrored from www.py.cz/pipermail/python/2011-February/010178.html by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 20 Mar 2016 21:18:09 GMT -->
</html>
