<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 
<!-- Mirrored from www.py.cz/pipermail/python/2006-November/004974.html by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 20 Mar 2016 21:24:18 GMT -->
<HEAD>
   <TITLE> [python] Statické metody v Pythonu
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:python%40py.cz?Subject=%5Bpython%5D%20%3D%3Fiso-8859-2%3Fq%3FStatick%3DE9_metody_v_Pythonu%3F%3D&In-Reply-To=E8AE1CAFC84D634A9CCC887B8AAB15EC0EA20C%40skil01.skil.mistni">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=iso-8859-2">
   <LINK REL="Previous"  HREF="http://www.py.cz/pipermail/python/2006-November/004995.html">
   <LINK REL="Next"  HREF="http://www.py.cz/pipermail/python/2006-November/004979.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[python] Statické metody v Pythonu</H1>
    <B>superman</B> 
    <A HREF="mailto:python%40py.cz?Subject=%5Bpython%5D%20%3D%3Fiso-8859-2%3Fq%3FStatick%3DE9_metody_v_Pythonu%3F%3D&In-Reply-To=E8AE1CAFC84D634A9CCC887B8AAB15EC0EA20C%40skil01.skil.mistni"
       TITLE="[python] Statické metody v Pythonu">feed na centrum.cz
       </A><BR>
    <I>Støeda Listopad  8 15:56:28 CET 2006</I>
    <P><UL>
        <LI>Pøedchozí pøíspìvek: <A HREF="http://www.py.cz/pipermail/python/2006-November/004995.html">[python] Classmethod
</A></li>
        <LI>Následující pøíspìvek: <A HREF="http://www.py.cz/pipermail/python/2006-November/004979.html">[python] Statické metody v Pythonu
</A></li>
         <LI> <B>Zprávy tøídìné podle:</B> 
              <a href="http://www.py.cz/pipermail/python/2006-November/date.html#4974">[ data ]</a>
              <a href="http://www.py.cz/pipermail/python/2006-November/thread.html#4974">[ vlákna ]</a>
              <a href="http://www.py.cz/pipermail/python/2006-November/subject.html#4974">[ subjektu ]</a>
              <a href="http://www.py.cz/pipermail/python/2006-November/author.html#4974">[ autora ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>&gt;&gt;<i>jazycích bylo v poøádku. Never is perfect :-)))
</I>&gt;&gt;<i>[my¹leno asi Nobody is perfect -- Nìkdo to rád horké]
</I>
Pøesnì tak :-) Díky za opravu, pøí¹tì si dám pozor na cizí termity :-)

&gt;<i> je dekorátor zapoznámkovaný, tak¾e je to stejné, jako kdybych
</I>&gt;<i> napsal 
</I>&gt;<i> 
</I>&gt;<i>  class zemepisny_uhel(uhel):
</I>&gt;<i>       def static(a):
</I>&gt;<i>           print &quot;trida2.static(): &quot;, a
</I>&gt;<i> 
</I>&gt;<i> Co¾ je stejné jako
</I>&gt;<i> 
</I>&gt;<i>  class zemepisny_uhel(uhel):
</I>&gt;<i>       def static(self):
</I>&gt;<i>           print &quot;trida2.static(): &quot;, self
</I>&gt;<i> 
</I>&gt;<i> Jenom jsi poru¹il konvenci, ¾e první argument metody se má
</I>&gt;<i> pojmenovat self. No a druhý argument tam není. Myslím,
</I>&gt;<i> ¾e interpret Pythonu v tom docela jasno MÁ ;o)
</I>
Má, tohle je opravdu moje chyba. U¾ mì na to upozornil èlovìk z 
pøedchozího mailu.

Jen prostì mì nenadchlo, ¾e v pøedchozí tøídì to byla statická metoda, 
poèítalo se s ní jako se statickou metodou a pokud to v potomkovi zmìním 
na dynamickou, ¾e to má zpìtné dùsledky i do pøedka nejen ohlednì 
chování, ale vlastnì i z hlediska interface. Ale to je otázkou toho, ¾e 
jsme v dynamickém jazyce. Tak¾e je to asi v poøádku.

&gt;<i> A je¹tì k tomu pou¾ití statické metody. Mo¾ná má¹ znalosti
</I>&gt;<i> C++, kde se zápis typu 
</I>&gt;<i> 
</I>&gt;<i> zem_uhel + &quot;30N54&quot; 
</I>&gt;<i> 
</I>&gt;<i> typicky dosahuje pøetí¾ením operátoru +  a typicky se
</I>&gt;<i> implementuje tak, ¾e se na místì druhého argumentu oèekává
</I>&gt;<i> konstantní reference a tøídu zemepisny_uhel. Jen¾e 
</I>&gt;<i> u tøídy zemepisny_uhel by se v takovém pøípadì typicky 
</I>&gt;<i> definoval konstruktor, který bere odkaz na konstantní string
</I>&gt;<i> a mù¾e se tam tedy dosadit i literál. Pøekladaè pak automaticky
</I>&gt;<i> udìlá tohle:
</I>&gt;<i> 
</I>&gt;<i> zem_uhel + zemepisny_uhel(&quot;30N54&quot;)
</I>&gt;<i> 
</I>&gt;<i> tj. nejdøíve zkonstruuje pomocný objekt pro druhý argument.
</I>&gt;<i> Dále se to dá rozepsat jako
</I>&gt;<i> 
</I>&gt;<i> zem_uhel.operator+(zemepisny_uhel((&quot;30N54&quot;)))
</I>
No, C++ je velmi flexibilní jazyk, tak¾e buï C++ zavolá konstruktor, a 
nebo operátor +, kde druhý parametr je string, pokud takový existuje. Ta 
první varianta s voláním konstruktoru je &quot;drahá&quot;, tedy z nouze ctnost, 
proto¾e se zbyteènì vytváøí doèasná instance, a pak zase ru¹í. Operátor 
+ to vìt¹inou doká¾e efektivnìji s mnohem men¹í re¾ií.

&gt;<i> Python ale implicitnì podobný konstruktor nezavolá. Podle 
</I>&gt;<i> mého by tedy mìla být tøída uhel vytvoøena tak, aby její
</I>&gt;<i> slo¾ka __radians jednodu¹e obsahovala platnou hodnotu, nebo
</I>&gt;<i> by se mìla definovat metoda, která hodnotu v radiánech
</I>&gt;<i> vrací. Metoda __add__ by jako argument mìla brát instanci
</I>&gt;<i> tøídy uhel a udìlat jednodu¹e
</I>&gt;<i> 
</I>&gt;<i> class uhel:
</I>&gt;<i>     def __init__(self, radian):
</I>&gt;<i>         self.__rad = radian
</I>&gt;<i> 
</I>&gt;<i>     def __add__(self, u):
</I>&gt;<i>         return self.__rad + u.__rad
</I>&gt;<i> 
</I>&gt;<i>     def __str__(self):
</I>&gt;<i>         return str(self.__rad)
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> u1 = uhel(1.0)
</I>&gt;<i> u2 = uhel(2.0)
</I>&gt;<i> 
</I>&gt;<i> print u1
</I>&gt;<i> print u2
</I>&gt;<i> 
</I>&gt;<i> u3 = u1 + u2
</I>&gt;<i> u4 = u1 + uhel(3.0)
</I>&gt;<i> 
</I>&gt;<i> print u3
</I>&gt;<i> print u4
</I>
To je pøesnì stejný pøípad jako s tím C++. Tohle øe¹ení, které uvádíte 
je naprosto nejelegantnìj¹í a nejèistìj¹í. Myslím, ¾e nic lep¹ího asi 
nelze vymyslet, ale vzniká tu instance tøídy uhel, která vlastnì 
vzniknout nemusí. Øeknìme, ¾e je to takový relikt v mém my¹lení, který 
mì nutí se obèas zabývat efektivitou programu a který mi øíká, ¾e 
vytvoøení instance tøídy uhel není potøeba. Proto jsem zavedl tu 
statickou metodu a upravil jsem __add__ tak, aby pøijímal i èísla a stringy.

Tohle spoète souèet bez toho, ani¾ by se vytvøila doèasná instance tøídy 
uhel:

u4 = u1 + 3.0

A tohle udìlá to samé, ale vytvoøí se (a pak posléze zru¹í) navíc 
instance tøidy uhel:

u4 = u1 + uhel(3.0)

Prostì nevím a netu¹ím, jestli tuhle re¾ii vytvoøení instance navíc mám 
vzít v úvahu. Pokud jí pøipustím, mám asi èistìj¹í kód, pokud zase 
pomù¾u metodì __add__, aby umìla seèíst èíslo pøímo, mám efektivnìj¹í 
kód. Naproti tomu zase hrozí, ¾e seètu nìco, co se jako èíslo bude 
tváøit a významovì to nemá s úhlem nic spoleèného a mù¾u hledat chyby. 
Nevím, který postup je správný, asi ka¾dý má nìco.

&gt;<i> Tøída zemepisny_uhel by byla odvozená v tom smyslu, 
</I>&gt;<i> ¾e by mìla jinou implementaci __init__(), ve které
</I>&gt;<i> by se mohly rozpoznávat rùzné formy pøedaného argumentu.
</I>&gt;<i> Pak by to mohlo vypadat takhle:
</I>&gt;<i> 
</I>&gt;<i> class uhel:
</I>&gt;<i>     def __init__(self, radian):
</I>&gt;<i>         self.__rad = radian
</I>&gt;<i> 
</I>&gt;<i>     def __add__(self, u):
</I>&gt;<i>         return self.__rad + u.__rad
</I>&gt;<i> 
</I>&gt;<i>     def __str__(self):
</I>&gt;<i>         return str(self.__rad)
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> class zemepisny_uhel(uhel):
</I>&gt;<i>     def __init__(self, s):
</I>&gt;<i>         uhel.__init__(self, float(s))
</I>&gt;<i> 
</I>&gt;<i> u1 = uhel(1.0)
</I>&gt;<i> u2 = uhel(2.0)
</I>&gt;<i> 
</I>&gt;<i> print u1
</I>&gt;<i> print u2
</I>&gt;<i> 
</I>&gt;<i> u3 = u1 + u2
</I>&gt;<i> u4 = u1 + uhel(3.0)
</I>&gt;<i> 
</I>&gt;<i> print u3
</I>&gt;<i> print u4
</I>&gt;<i> 
</I>&gt;<i> z = zemepisny_uhel('4.0')
</I>&gt;<i> 
</I>&gt;<i> print z
</I>&gt;<i> print u1 + z
</I>&gt;<i> print z + u2
</I>&gt;<i> 
</I>&gt;<i> Uplatnìní pro statické metody jsem v tom pøíkladu
</I>&gt;<i> zatím nena¹el.
</I>
Já také ne. Jen¾e u mì ta statická metoda pro vytvoøení úhlu vypadá 
takto a taky se¾ere a¾ neuvìøitelnì divoké definice úhlù od zadání úhlu 
v radiánech a¾ po rùzné se stupni, minutami, atd.. Skoro jsem na svojí 
metodu hrdý :-))):

_MathAngleRegExpStr = \
     u'(^\\s*' + \
     u'([0-9]*[.]?[0-9]*)\\s*' + \
     u'((?:[Rr](?:[Aa][Dd](?:[Ss]|[Ii][Aa][Nn][Ss])?))\\s*)*' + \
     u'\\s*$)' + \
     u'|' + \
     u'(^\\s*' + \
     u'([0-9]*[.]?[0-9]*)\\s*' + \
 
u'(?:(?:[°]|[Dd](?:[Ee][Gg](?:[Rr]|(?:[Ee][Ee]))?[Ss]?)?)\\s*)*\\s*' + \
     u'([0-9]*[.]?[0-9]*)\\s*' + \
     u'(?:(?:[\']|(?:[Mm](?:[Ii][Nn](?:[Uu][Tt][Ee])?[Ss]?)))\\s*)*\\s*' + \
     u'([0-9]*[.]?[0-9]*)\\s*' + \
 
u'(?:(?:[\&quot;]|(?:[Ss](?:[Ee][Cc](?:[Oo][Nn][Dd])?[Ss]?)?))\\s*)*\\s*' + \
     u'[.]?([0-9]*)' + \
     u'\\s*$)'


_MathAngleRegExp = re.compile(_MathAngleRegExpStr, re.UNICODE)


class Angle(object):

   @staticmethod
   def _s_ConvertStringToRadians(angle_string):
     angle_string = unicode(angle_string)
     reg_exp_result = _MathAngleRegExp.findall(angle_string)
     if (not isinstance(reg_exp_result, list)) \
       or (len(reg_exp_result) &lt;= 0):
       raise ValueError
     reg_exp_result = reg_exp_result[0]
     if not isinstance(reg_exp_result, tuple):
       raise ValueError
      # atd.

A pak máte potomky, které jsou schopny se¾rat je¹tì dal¹í konkrétní 
formáty stringy odle urèení.

&gt;<i> Poznámka: kromì staticmethod() a pøíslu¹ného
</I>&gt;<i> dekorátoru existuje i classmethod(), ke které 
</I>&gt;<i> jsme se zatím nedostali.
</I>
Uf, dekorátory mì zajímají. V manuálu jsem na¹el tak akorát velké nic, 
tak¾e informace na toto téma vítám. Co dìlá classmethod?

Miloslav Ponkrác



</PRE>











<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Pøedchozí pøíspìvek: <A HREF="http://www.py.cz/pipermail/python/2006-November/004995.html">[python] Classmethod
</A></li>
	<LI>Následující pøíspìvek: <A HREF="http://www.py.cz/pipermail/python/2006-November/004979.html">[python] Statické metody v Pythonu
</A></li>
         <LI> <B>Zprávy tøídìné podle:</B> 
              <a href="http://www.py.cz/pipermail/python/2006-November/date.html#4974">[ data ]</a>
              <a href="http://www.py.cz/pipermail/python/2006-November/thread.html#4974">[ vlákna ]</a>
              <a href="http://www.py.cz/pipermail/python/2006-November/subject.html#4974">[ subjektu ]</a>
              <a href="http://www.py.cz/pipermail/python/2006-November/author.html#4974">[ autora ]</a>
         </LI>
       </UL>
<hr>
<a href="http://www.py.cz/mailman/listinfo/python">Dal¹í informace o konferenci Python</a><br>
</body>
<!-- Mirrored from www.py.cz/pipermail/python/2006-November/004974.html by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 20 Mar 2016 21:24:18 GMT -->
</html>
