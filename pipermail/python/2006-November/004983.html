<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 
<!-- Mirrored from www.py.cz/pipermail/python/2006-November/004983.html by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 20 Mar 2016 21:24:18 GMT -->
<HEAD>
   <TITLE> [python] Statické metody v Pythonu
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:python%40py.cz?Subject=%5Bpython%5D%20%3D%3Futf-8%3Fq%3FStatick%3DC3%3DA9_metody_v_Pythonu%3F%3D&In-Reply-To=45520324.2070703%40gentoo.org">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=iso-8859-2">
   <LINK REL="Previous"  HREF="http://www.py.cz/pipermail/python/2006-November/004982.html">
   <LINK REL="Next"  HREF="http://www.py.cz/pipermail/python/2006-November/004997.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[python] Statické metody v Pythonu</H1>
    <B>superman</B> 
    <A HREF="mailto:python%40py.cz?Subject=%5Bpython%5D%20%3D%3Futf-8%3Fq%3FStatick%3DC3%3DA9_metody_v_Pythonu%3F%3D&In-Reply-To=45520324.2070703%40gentoo.org"
       TITLE="[python] Statické metody v Pythonu">feed na centrum.cz
       </A><BR>
    <I>Støeda Listopad  8 17:45:55 CET 2006</I>
    <P><UL>
        <LI>Pøedchozí pøíspìvek: <A HREF="http://www.py.cz/pipermail/python/2006-November/004982.html">[python] Statické metody v Pythonu
</A></li>
        <LI>Následující pøíspìvek: <A HREF="http://www.py.cz/pipermail/python/2006-November/004997.html">[python] Dekorátory
</A></li>
         <LI> <B>Zprávy tøídìné podle:</B> 
              <a href="http://www.py.cz/pipermail/python/2006-November/date.html#4983">[ data ]</a>
              <a href="http://www.py.cz/pipermail/python/2006-November/thread.html#4983">[ vlákna ]</a>
              <a href="http://www.py.cz/pipermail/python/2006-November/subject.html#4983">[ subjektu ]</a>
              <a href="http://www.py.cz/pipermail/python/2006-November/author.html#4983">[ autora ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE> &gt;&gt;jazycích bylo v poøádku. Never is perfect :-)))
 &gt;&gt;[my¹leno asi Nobody is perfect -- Nìkdo to rád horké]

Pøesnì tak :-) Díky za opravu, pøí¹tì si dám pozor na cizí termity :-)

 &gt; je dekorátor zapoznámkovaný, tak¾e je to stejné, jako kdybych
 &gt; napsal
 &gt;
 &gt;  class zemepisny_uhel(uhel):
 &gt;       def static(a):
 &gt;           print &quot;trida2.static(): &quot;, a
 &gt;
 &gt; Co¾ je stejné jako
 &gt;
 &gt;  class zemepisny_uhel(uhel):
 &gt;       def static(self):
 &gt;           print &quot;trida2.static(): &quot;, self
 &gt;
 &gt; Jenom jsi poru¹il konvenci, ¾e první argument metody se má
 &gt; pojmenovat self. No a druhý argument tam není. Myslím,
 &gt; ¾e interpret Pythonu v tom docela jasno MÁ ;o)

Má, tohle je opravdu moje chyba. U¾ mì na to upozornil èlovìk z
pøedchozího mailu.

Jen prostì mì nenadchlo, ¾e v pøedchozí tøídì to byla statická metoda,
poèítalo se s ní jako se statickou metodou a pokud to v potomkovi zmìním
na dynamickou, ¾e to má zpìtné dùsledky i do pøedka nejen ohlednì
chování, ale vlastnì i z hlediska interface. Ale to je otázkou toho, ¾e
jsme v dynamickém jazyce. Tak¾e je to asi v poøádku.

 &gt; A je¹tì k tomu pou¾ití statické metody. Mo¾ná má¹ znalosti
 &gt; C++, kde se zápis typu
 &gt;
 &gt; zem_uhel + &quot;30N54&quot;
 &gt;
 &gt; typicky dosahuje pøetí¾ením operátoru +  a typicky se
 &gt; implementuje tak, ¾e se na místì druhého argumentu oèekává
 &gt; konstantní reference a tøídu zemepisny_uhel. Jen¾e
 &gt; u tøídy zemepisny_uhel by se v takovém pøípadì typicky
 &gt; definoval konstruktor, který bere odkaz na konstantní string
 &gt; a mù¾e se tam tedy dosadit i literál. Pøekladaè pak automaticky
 &gt; udìlá tohle:
 &gt;
 &gt; zem_uhel + zemepisny_uhel(&quot;30N54&quot;)
 &gt;
 &gt; tj. nejdøíve zkonstruuje pomocný objekt pro druhý argument.
 &gt; Dále se to dá rozepsat jako
 &gt;
 &gt; zem_uhel.operator+(zemepisny_uhel((&quot;30N54&quot;)))

No, C++ je velmi flexibilní jazyk, tak¾e buï C++ zavolá konstruktor, a
nebo operátor +, kde druhý parametr je string, pokud takový existuje. Ta
první varianta s voláním konstruktoru je &quot;drahá&quot;, tedy z nouze ctnost,
proto¾e se zbyteènì vytváøí doèasná instance, a pak zase ru¹í. Operátor
+ to vìt¹inou doká¾e efektivnìji s mnohem men¹í re¾ií.

 &gt; Python ale implicitnì podobný konstruktor nezavolá. Podle
 &gt; mého by tedy mìla být tøída uhel vytvoøena tak, aby její
 &gt; slo¾ka __radians jednodu¹e obsahovala platnou hodnotu, nebo
 &gt; by se mìla definovat metoda, která hodnotu v radiánech
 &gt; vrací. Metoda __add__ by jako argument mìla brát instanci
 &gt; tøídy uhel a udìlat jednodu¹e
 &gt;
 &gt; class uhel:
 &gt;     def __init__(self, radian):
 &gt;         self.__rad = radian
 &gt;
 &gt;     def __add__(self, u):
 &gt;         return self.__rad + u.__rad
 &gt;
 &gt;     def __str__(self):
 &gt;         return str(self.__rad)
 &gt;
 &gt;
 &gt; u1 = uhel(1.0)
 &gt; u2 = uhel(2.0)
 &gt;
 &gt; print u1
 &gt; print u2
 &gt;
 &gt; u3 = u1 + u2
 &gt; u4 = u1 + uhel(3.0)
 &gt;
 &gt; print u3
 &gt; print u4

To je pøesnì stejný pøípad jako s tím C++. Tohle øe¹ení, které uvádíte
je naprosto nejelegantnìj¹í a nejèistìj¹í. Myslím, ¾e nic lep¹ího asi
nelze vymyslet, ale vzniká tu instance tøídy uhel, která vlastnì
vzniknout nemusí. Øeknìme, ¾e je to takový relikt v mém my¹lení, který
mì nutí se obèas zabývat efektivitou programu a který mi øíká, ¾e
vytvoøení instance tøídy uhel není potøeba. Proto jsem zavedl tu
statickou metodu a upravil jsem __add__ tak, aby pøijímal i èísla a stringy.

Tohle spoète souèet bez toho, ani¾ by se vytvøila doèasná instance tøídy
uhel:

u4 = u1 + 3.0

A tohle udìlá to samé, ale vytvoøí se (a pak posléze zru¹í) navíc
instance tøidy uhel:

u4 = u1 + uhel(3.0)

Prostì nevím a netu¹ím, jestli tuhle re¾ii vytvoøení instance navíc mám
vzít v úvahu. Pokud jí pøipustím, mám asi èistìj¹í kód, pokud zase
pomù¾u metodì __add__, aby umìla seèíst èíslo pøímo, mám efektivnìj¹í
kód. Naproti tomu zase hrozí, ¾e seètu nìco, co se jako èíslo bude
tváøit a významovì to nemá s úhlem nic spoleèného a mù¾u hledat chyby.
Nevím, který postup je správný, asi ka¾dý má nìco.

 &gt; Tøída zemepisny_uhel by byla odvozená v tom smyslu,
 &gt; ¾e by mìla jinou implementaci __init__(), ve které
 &gt; by se mohly rozpoznávat rùzné formy pøedaného argumentu.
 &gt; Pak by to mohlo vypadat takhle:
 &gt;
 &gt; class uhel:
 &gt;     def __init__(self, radian):
 &gt;         self.__rad = radian
 &gt;
 &gt;     def __add__(self, u):
 &gt;         return self.__rad + u.__rad
 &gt;
 &gt;     def __str__(self):
 &gt;         return str(self.__rad)
 &gt;
 &gt;
 &gt; class zemepisny_uhel(uhel):
 &gt;     def __init__(self, s):
 &gt;         uhel.__init__(self, float(s))
 &gt;
 &gt; u1 = uhel(1.0)
 &gt; u2 = uhel(2.0)
 &gt;
 &gt; print u1
 &gt; print u2
 &gt;
 &gt; u3 = u1 + u2
 &gt; u4 = u1 + uhel(3.0)
 &gt;
 &gt; print u3
 &gt; print u4
 &gt;
 &gt; z = zemepisny_uhel('4.0')
 &gt;
 &gt; print z
 &gt; print u1 + z
 &gt; print z + u2
 &gt;
 &gt; Uplatnìní pro statické metody jsem v tom pøíkladu
 &gt; zatím nena¹el.

Já také ne. Jen¾e u mì ta statická metoda pro vytvoøení úhlu vypadá
takto a taky se¾ere a¾ neuvìøitelnì divoké definice úhlù od zadání úhlu
v radiánech a¾ po rùzné se stupni, minutami, atd.. Skoro jsem na svojí
metodu hrdý :-))):

_MathAngleRegExpStr = \
      u'(^\\s*' + \
      u'([0-9]*[.]?[0-9]*)\\s*' + \
      u'((?:[Rr](?:[Aa][Dd](?:[Ss]|[Ii][Aa][Nn][Ss])?))\\s*)*' + \
      u'\\s*$)' + \
      u'|' + \
      u'(^\\s*' + \
      u'([0-9]*[.]?[0-9]*)\\s*' + \

u'(?:(?:[°]|[Dd](?:[Ee][Gg](?:[Rr]|(?:[Ee][Ee]))?[Ss]?)?)\\s*)*\\s*' + \
      u'([0-9]*[.]?[0-9]*)\\s*' + \
 
u'(?:(?:[\']|(?:[Mm](?:[Ii][Nn](?:[Uu][Tt][Ee])?[Ss]?)))\\s*)*\\s*' + \
      u'([0-9]*[.]?[0-9]*)\\s*' + \

u'(?:(?:[\&quot;]|(?:[Ss](?:[Ee][Cc](?:[Oo][Nn][Dd])?[Ss]?)?))\\s*)*\\s*' + \
      u'[.]?([0-9]*)' + \
      u'\\s*$)'


_MathAngleRegExp = re.compile(_MathAngleRegExpStr, re.UNICODE)


class Angle(object):

    @staticmethod
    def _s_ConvertStringToRadians(angle_string):
      angle_string = unicode(angle_string)
      reg_exp_result = _MathAngleRegExp.findall(angle_string)
      if (not isinstance(reg_exp_result, list)) \
        or (len(reg_exp_result) &lt;= 0):
        raise ValueError
      reg_exp_result = reg_exp_result[0]
      if not isinstance(reg_exp_result, tuple):
        raise ValueError
       # atd.

A pak máte potomky, které jsou schopny se¾rat je¹tì dal¹í konkrétní
formáty stringy odle urèení.

 &gt; Poznámka: kromì staticmethod() a pøíslu¹ného
 &gt; dekorátoru existuje i classmethod(), ke které
 &gt; jsme se zatím nedostali.

Uf, dekorátory mì zajímají. V manuálu jsem na¹el tak akorát velké nic,
tak¾e informace na toto téma vítám. Co dìlá classmethod?

Miloslav Ponkrác


</PRE>





<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Pøedchozí pøíspìvek: <A HREF="http://www.py.cz/pipermail/python/2006-November/004982.html">[python] Statické metody v Pythonu
</A></li>
	<LI>Následující pøíspìvek: <A HREF="http://www.py.cz/pipermail/python/2006-November/004997.html">[python] Dekorátory
</A></li>
         <LI> <B>Zprávy tøídìné podle:</B> 
              <a href="http://www.py.cz/pipermail/python/2006-November/date.html#4983">[ data ]</a>
              <a href="http://www.py.cz/pipermail/python/2006-November/thread.html#4983">[ vlákna ]</a>
              <a href="http://www.py.cz/pipermail/python/2006-November/subject.html#4983">[ subjektu ]</a>
              <a href="http://www.py.cz/pipermail/python/2006-November/author.html#4983">[ autora ]</a>
         </LI>
       </UL>
<hr>
<a href="http://www.py.cz/mailman/listinfo/python">Dal¹í informace o konferenci Python</a><br>
</body>
<!-- Mirrored from www.py.cz/pipermail/python/2006-November/004983.html by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 20 Mar 2016 21:24:18 GMT -->
</html>
