<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 
<!-- Mirrored from www.py.cz/pipermail/python/2006-November/004990.html by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 20 Mar 2016 21:24:19 GMT -->
<HEAD>
   <TITLE> [python] Statické metody v Pythonu
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:python%40py.cz?Subject=%5Bpython%5D%20%3D%3Fiso-8859-2%3Fq%3FStatick%3DE9_metody_v_Pythonu%3F%3D&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=iso-8859-2">
   <LINK REL="Previous"  HREF="http://www.py.cz/pipermail/python/2006-November/004989.html">
   <LINK REL="Next"  HREF="http://www.py.cz/pipermail/python/2006-November/004991.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[python] Statické metody v Pythonu</H1>
    <B>Petr Prikryl</B> 
    <A HREF="mailto:python%40py.cz?Subject=%5Bpython%5D%20%3D%3Fiso-8859-2%3Fq%3FStatick%3DE9_metody_v_Pythonu%3F%3D&In-Reply-To="
       TITLE="[python] Statické metody v Pythonu">PrikrylP na skil.cz
       </A><BR>
    <I>Ètvrtek Listopad  9 09:11:23 CET 2006</I>
    <P><UL>
        <LI>Pøedchozí pøíspìvek: <A HREF="http://www.py.cz/pipermail/python/2006-November/004989.html">[python] dekorator property
</A></li>
        <LI>Následující pøíspìvek: <A HREF="http://www.py.cz/pipermail/python/2006-November/004991.html">[python] Statické metody v Pythonu
</A></li>
         <LI> <B>Zprávy tøídìné podle:</B> 
              <a href="http://www.py.cz/pipermail/python/2006-November/date.html#4990">[ data ]</a>
              <a href="http://www.py.cz/pipermail/python/2006-November/thread.html#4990">[ vlákna ]</a>
              <a href="http://www.py.cz/pipermail/python/2006-November/subject.html#4990">[ subjektu ]</a>
              <a href="http://www.py.cz/pipermail/python/2006-November/author.html#4990">[ autora ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>&gt;<i> &gt; zem_uhel + &quot;30N54&quot;
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; typicky dosahuje pøetí¾ením operátoru + a typicky se
</I>&gt;<i> &gt; implementuje tak, ¾e se na místì druhého argumentu oèekává
</I>&gt;<i> &gt; konstantní reference a tøídu zemepisny_uhel. Jen¾e u tøídy
</I>&gt;<i> &gt; zemepisny_uhel by se v takovém pøípadì typicky definoval
</I>&gt;<i> &gt; konstruktor, který bere odkaz na konstantní string a mù¾e
</I>&gt;<i> &gt; se tam tedy dosadit i literál. Pøekladaè pak automaticky
</I>&gt;<i> &gt; udìlá tohle:
</I>&gt;<i> &gt;
</I>&gt;<i> &gt; zem_uhel + zemepisny_uhel(&quot;30N54&quot;)
</I>&gt;<i>  
</I>&gt;<i> No, C++ je velmi flexibilní jazyk, tak¾e buï C++ zavolá
</I>&gt;<i> konstruktor, a nebo operátor +, kde druhý parametr je
</I>&gt;<i> string, pokud takový existuje. Ta první varianta s voláním
</I>&gt;<i> konstruktoru je &quot;drahá&quot;, tedy z nouze ctnost, proto¾e se
</I>&gt;<i> zbyteènì vytváøí doèasná instance, a pak zase ru¹í. Operátor
</I>&gt;<i> + to vìt¹inou doká¾e efektivnìji s mnohem men¹í re¾ií.
</I>
Ano. Ale toto je otázka návrhu. Typicky se definuje operátor
pro sèítání (operator+() nebo __add__()), který pracuje s
argumentem stejné tøídy, jako je sám objekt. V budoucnu si mù¾u
vymyslet dal¹í konverze, ze kterých vypadne úhel. Z hlediska
údr¾by je lep¹í, kdy¾ se speciality dìlají zvenku. Je tedy
lep¹í venku pøevést string zemìpisné ¹íøky na úhel a
dosadit.

&gt;<i> [...] ale vzniká tu
</I>&gt;<i> instance tøídy uhel, která vlastnì vzniknout nemusí.
</I>&gt;<i> Øeknìme, ¾e je to takový relikt v mém my¹lení, který mì nutí
</I>&gt;<i> se obèas zabývat efektivitou programu a který mi øíká, ¾e
</I>&gt;<i> vytvoøení instance tøídy uhel není potøeba. Proto jsem
</I>&gt;<i> zavedl tu statickou metodu a upravil jsem __add__ tak, aby
</I>&gt;<i> pøijímal i èísla a stringy.
</I>
Jedna vìc je strojová efektivita a druhá vìc je jak je to
mentálnì uchopitelné, tj. kolik to dá práce mozku
programátora (pokud tedy neprogramuje srdcem ;)

The Zen of Python k tomu v¹emu mù¾e øíci (výbìr):

Explicit is better than implicit.
Simple is better than complex.
Readability counts.
Special cases aren't special enough to break the rules.
In the face of ambiguity, refuse the temptation to guess.
If the implementation is hard to explain, it's a bad idea.
If the implementation is easy to explain, it may be a good idea.

&gt;<i> [...]
</I>&gt;<i> A tohle udìlá to samé, ale vytvoøí se (a pak posléze 
</I>&gt;<i> zru¹í) navíc instance tøidy uhel:
</I>&gt;<i> 
</I>&gt;<i> u4 = u1 + uhel(3.0)
</I>&gt;<i> 
</I>&gt;<i> Prostì nevím a netu¹ím, jestli tuhle re¾ii vytvoøení
</I>&gt;<i> instance navíc mám vzít v úvahu. Pokud jí pøipustím, mám
</I>&gt;<i> asi èistìj¹í kód, pokud zase pomù¾u metodì __add__, aby
</I>&gt;<i> umìla seèíst èíslo pøímo, mám efektivnìj¹í kód. Naproti
</I>&gt;<i> tomu zase hrozí, ¾e seètu nìco, co se jako èíslo bude
</I>&gt;<i> tváøit a významovì to nemá s úhlem nic spoleèného a mù¾u
</I>&gt;<i> hledat chyby. Nevím, který postup je správný, asi ka¾dý má
</I>&gt;<i> nìco.
</I>
Viz vý¹e. Navíc &quot;In the face of ambiguity, refuse the
temptation to guess.&quot; mívá pokraèování &quot;zmìø to&quot;.

Obvykle se taky projevuje dualita mezi daty a kódem:
Slo¾itìj¹í kód, jednodu¹¹í datové struktury a naopak.
Slo¾itìj¹í kód mù¾e vést k úspoøe pamìti, ale obvykle také
ke zvý¹ení èasové nároènosti. Slo¾itìj¹í datové struktury...

&gt;<i> [...] Jen¾e u mì ta statická metoda pro vytvoøení
</I>&gt;<i> úhlu vypadá takto a taky se¾ere a¾ neuvìøitelnì divoké
</I>&gt;<i> definice úhlù od zadání úhlu v radiánech a¾ po rùzné se
</I>&gt;<i> stupni, minutami, atd. [...]
</I> 
Asi bych radìji místo statické metody pou¾il obyèejnou
funkci ve stejném modulu. Pokud by potomek potøeboval nìco
jiného, pøedefinoval by si pøíslu¹nou metodu tak, aby volala
jinou funkci. Zadarmo bych tím také získal pøístup k oné
funkci bez závislosti na pou¾ívání tøíd, které ji pou¾ívají
(tj. napø pøevod z øetìzce na radiány).
 
&gt;<i> Uf, dekorátory mì zajímají. V manuálu jsem na¹el tak akorát
</I>&gt;<i> velké nic, tak¾e informace na toto téma vítám.
</I>
Ony dekorátory taky nic moc nedìlají. Je to jen takový
&quot;syntactic sugar&quot; -- to tvrdí &quot;opravdoví programátoøi&quot;
opovr¾livì. Na druhou stranu, právì takové vìci dìlají
pou¾ití jazyka elegantním. Pøetì¾ování operátorù je taky
syntaktický cukøík, ale jak pìknì se s tím pak pracuje!
(Tedy pokud se to nachystá správnì.)

pepr
</PRE>






<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Pøedchozí pøíspìvek: <A HREF="http://www.py.cz/pipermail/python/2006-November/004989.html">[python] dekorator property
</A></li>
	<LI>Následující pøíspìvek: <A HREF="http://www.py.cz/pipermail/python/2006-November/004991.html">[python] Statické metody v Pythonu
</A></li>
         <LI> <B>Zprávy tøídìné podle:</B> 
              <a href="http://www.py.cz/pipermail/python/2006-November/date.html#4990">[ data ]</a>
              <a href="http://www.py.cz/pipermail/python/2006-November/thread.html#4990">[ vlákna ]</a>
              <a href="http://www.py.cz/pipermail/python/2006-November/subject.html#4990">[ subjektu ]</a>
              <a href="http://www.py.cz/pipermail/python/2006-November/author.html#4990">[ autora ]</a>
         </LI>
       </UL>
<hr>
<a href="http://www.py.cz/mailman/listinfo/python">Dal¹í informace o konferenci Python</a><br>
</body>
<!-- Mirrored from www.py.cz/pipermail/python/2006-November/004990.html by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 20 Mar 2016 21:24:19 GMT -->
</html>
