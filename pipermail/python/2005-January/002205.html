<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 
<!-- Mirrored from www.py.cz/pipermail/python/2005-January/002205.html by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 20 Mar 2016 21:27:56 GMT -->
<HEAD>
   <TITLE> RE: [python] globální promìnné
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:python%40py.cz?Subject=%3D%3Fiso-8859-2%3FQ%3FRE%3D3A_%3D5Bpython%3D5D_glob%3DE1ln%3DED_prom%3DECnn%3DE9%3F%3D&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=iso-8859-2">
   <LINK REL="Previous"  HREF="http://www.py.cz/pipermail/python/2005-January/002204.html">
   <LINK REL="Next"  HREF="http://www.py.cz/pipermail/python/2005-January/002206.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>RE: [python] globální promìnné</H1>
    <B>Petr Prikryl</B> 
    <A HREF="mailto:python%40py.cz?Subject=%3D%3Fiso-8859-2%3FQ%3FRE%3D3A_%3D5Bpython%3D5D_glob%3DE1ln%3DED_prom%3DECnn%3DE9%3F%3D&In-Reply-To="
       TITLE="RE: [python] globální promìnné">Prikryl na skil.cz
       </A><BR>
    <I>Úterý Leden  4 09:25:47 CET 2005</I>
    <P><UL>
        <LI>Pøedchozí pøíspìvek: <A HREF="http://www.py.cz/pipermail/python/2005-January/002204.html">[python] globální promìnné
</A></li>
        <LI>Následující pøíspìvek: <A HREF="http://www.py.cz/pipermail/python/2005-January/002206.html">[python] navrhove vzory v Pythonu
</A></li>
         <LI> <B>Zprávy tøídìné podle:</B> 
              <a href="http://www.py.cz/pipermail/python/2005-January/date.html#2205">[ data ]</a>
              <a href="http://www.py.cz/pipermail/python/2005-January/thread.html#2205">[ vlákna ]</a>
              <a href="http://www.py.cz/pipermail/python/2005-January/subject.html#2205">[ subjektu ]</a>
              <a href="http://www.py.cz/pipermail/python/2005-January/author.html#2205">[ autora ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Ahoj Pavle, (doufám, ¾e tykání nevadí ;)

&gt;<i> Dìkuji za vyèerpávající vysvìtlení. Nechci vypadat jako
</I>&gt;<i> Tluèhuba :-), pøesto zkusím je¹tì jednou mùj postoj.
</I>
Já zase nechci vypadat jako pøechytralý, ale mùj obor
vzdìlání a praxe mi alespoò statisticky zaruèuje, ¾e bych se
v tomto pøípadì nemusel mýlit.

Pokud jde o postoj, jeho zmìna by ti mo¾ná pomohla posunout
se o kousek dál. Tøeba ti v tom pomù¾u.

&gt;<i> class G:
</I>&gt;<i>    pass
</I>&gt;<i> 
</I>&gt;<i> g=G()
</I>&gt;<i> g.x=30
</I>&gt;<i> 
</I>&gt;<i> Mo¾ná nepou¾ívám nejsprávnìj¹í terminologii, kdy¾ nazývám x
</I>&gt;<i> globální promìnnou (ano, je to lokální uvnitø G), nicménì
</I>&gt;<i> objekt 'g.x' je &quot;veøejnì pøístupný&quot;, *ze v¹ech funkcí
</I>&gt;<i> mìnitelný bez jakýchkoliv dal¹ích fíglu v rámci celého
</I>&gt;<i> programu*, jedná se tedy, podle mne, o mnou obhajovanou
</I>&gt;<i> superglobalni (superglobalni z hlediska celého programu a ne
</I>&gt;<i> jednotlivé tøídy èi instance - z jejich hlediska to je
</I>&gt;<i> samozøejmì lokální) promìnnou. Ale i výraz veøejnì pøístupný
</I>&gt;<i> je OK, nic to na vìci nemìní. Mo¾ná se pletu, mo¾ná existují
</I>&gt;<i> skulinky, kdy to neplatí, nicménì v programu s pár funkcemi
</I>&gt;<i> a jednou main to funguje.
</I>
Pøi debatách o programování je opravdu dobré pou¾ívat
jednotnou terminologii, proto¾e jinak si v¹ichni mù¾eme
vìcnì myslet to samé a pøitom se budeme hádat. &quot;Globálnì
pøístupná&quot; znamená pøístupná ze v¹ech míst programu bez
výjimky. Slo¾ka x není pøístupná odkudkoliv -- pouze pøes g.
Nemù¾e tedy být globální. Ale proto¾e g je pøístupné, pak je
i jeho veøejná slo¾ka pøístupná. To nemá s globálností
pøístupu nic spoleèného. Pí¹e¹ &quot;(ano, je to lokální uvnitø
G)&quot;. To není pravda. Slo¾ka x je pøístupná pøes g, nikoliv
pøes G. Není souèástí tøídy, je souèástí instance tøídy
(objektu). Tøída pouze pøedepisuje chování, objekt je
realizuje.

Zavedením objektu g nic superglobálního nevyøe¹ím. Je to jen
fale¹ný dojem. Pouze se ti slo¾itìj¹ím zpùsobem podaøilo
vyjádøit nìco podobného, jako kdybys vytvoøil skuteènì
globální promìnnou x. Funguje to úplnì stejnì, jen¾e kvùli
zvý¹ení slo¾itosti vyjádøení jsi pøehlédl, ¾e je to úplnì
stejné. Zkus tohle (pro zjednodu¹ení vynechávám èe¹tinu,
okopíruj do souboru a spus»):

========================================================

class G:
   pass

   
def fa():
    g = 'funkce fa() lokalne predefinovala jmeno g'
    print 'Uvnitr fa():', g
    
    try:
        print 'Pokus o pristup k g.x uvnitr fa():', g.x
    except:
        print 'Chyba!'
        

def fb():
    g = G()       # nova, lokalni instance tridy G
    g.x = 'hodnota lokalni instance objektu -- fb()'
    print 'Uvnitr fb():', g.x
    
    
g = G()
g.x = 'superglobalni hodnota'

print '\n\n\n' + '-' * 20           # jen oddelovac
print 'Na globalni urovni:', g.x

fa()

print 'Na globalni urovni:', g.x

fb()

print 'Na globalni urovni:', g.x

g2 = g        # navazu objekt na jine jmeno
g = 'nove g'

print 'Objekt s jinym jmenem:', g2.x    # OK
print 'Nova hodnota pojmenovana g:', g
print 'Na globalni urovni:', g.x        # chyba

========================================================

V¹imni si, ¾e funkce fa() i fb() definují svou lokální
promìnnou g a tím (doèasnì, v jejich tìle) znepøístupní 
g definovanou na globální úrovni. Funkce fa() mìní typ
promìnné zpøístupòované pøes jméno g, funkce fb() zachovává
dokonce stejný typ (stejnou tøídu) objektu. Ale pro celý
kód uvnitø fb() a pro v¹echny pøípadné funkce volané z fb()
znemo¾òuje pøístup k objektu g na globální úrovni. Místo
nìj podstrèí lokálnìj¹í g, definovaný na úrovni tìla fb().

Teï pøepí¹u toté¾ bez tøídy G a jejích instancí. Místo g.x
budu psát x a místo g2.x budu psát x2. Uvnitø fa() nebude
nutné o¹etøovat pøístup ke slo¾ce x a zviditelní se tím
lokálnost nového x. Funkce fb() nyní demonstruje pou¾ití
klíèového slova global, které potlaèí vytvoøení lokálního x
(narozdíl od fa()).

========================================================

def fa():
    x = 'funkce fa() lokalne predefinovala jmeno x'
    print 'Uvnitr fa():', x
    
def fb():
    global x
    x = 'nova globalni hodnota x'
    print 'Uvnitr fb():', x
    
x = 'globalni hodnota'

print '\n\n\n' + '-' * 20           # jen oddelovac
print 'Na globalni urovni:', x

fa()

print 'Na globalni urovni:', x

fb()

print 'Na globalni urovni:', x

x2 = x        # navazu objekt na jine jmeno
x = 'nove x'

print 'Objekt s jinym jmenem:', x2    # OK
print 'Nova hodnota x:', x

========================================================


&gt;<i> Uznávám, není to èisté øe¹ení, pøesto mi to pøipadá
</I>&gt;<i> &quot;èistìj¹í&quot; ne¾ pou¾ití global. 
</I>
Klíèové slovo 'global' není neèisté. Pouze umo¾òuje &quot;neèisté
praktiky&quot; pou¾ívání globálních promìnných. Tím, ¾e sis
&quot;nìjak&quot; vynutil zabalení x do nadøízené struktury, ses
jakoby vyhnul pou¾ití globální promìnné z hlediska jména x,
ale nevyhnul ses pou¾ívání globální promìnné z hlediska
jména g, jeho¾ je x slo¾kou. Pokud tvoje funkce nebudou
definovat novou hodnotu g jako celku (neprovedou novou vazbu
mezi jménem g a jiným objektem) a budou pouze pracovat s
jeho slo¾kami, pak jsi vyøe¹il svùj problém.

Napadá mì, ¾e mo¾ná intuitivnì smìøuje¹ k øe¹ení, kterému se
v objektovì orientovaném návrhu øíká singleton (jeden z
návrhových vzorù). Singleton je objekt, u kterého je
zaji¹tìno, ¾e existuje v jediné instanci. To znamená, ¾e i
kdy¾ nemusí mít pøidìlené jméno, v¾dy se nìjak dostanu k
jedinému objektu. Pokud si nìjak zajistím pøístup k objektu
této tøídy, pak je zaji¹tìno, ¾e budu pracovat s jediným
mo¾ným a tím samým objektem. Typicky se k nìmu
nedostávám pøes jméno, ale pokusím se o vytvoøení instance
vyhrazené tøídy. Tøída ale zajistí, ¾e se objekt vytvoøí jen
poprvé a pøi ostatních pokusech se místo nových instancí
vracejí reference na ji¾ existující, jediný objekt. Jde 
návrhový vzor, který se pou¾ívá napøíè rùznými OO jazyky,
ale v rùzných jazycích se implementuje rùzným zpùsobem.

&gt;<i> Kdy¾ ukazujete &quot;zjednodu¹ování&quot; kódu vypou¹tìním funkcí f()
</I>&gt;<i> i r(), tak to nevyjadøuje praxi. V praxi samozøejmì funkce
</I>&gt;<i> takto jednoduché nejsou a nedají se vypustit, proto¾e &quot;nìco
</I>&gt;<i> dìlají&quot; a veøejnì pøístupné promìnné jsou tam jenom pro
</I>&gt;<i> usnadnìní práce (funkce tam není samoúèelnì, kvùli nim), pro
</I>&gt;<i> zpøehlednìní kódu, pro pøiblí¾ení se práce v OOP. Snad
</I>&gt;<i> klasickým pøípadem je vznik nových promìnných ve funkci,
</I>&gt;<i> které v¹ak je tøeba si uchovat do dal¹ího prùchodu
</I>&gt;<i> funkcí,kde se s nimi bude opìt pracovat.
</I>
V pøíkladech z minulé diskuse jsem zavádìl a ru¹il funkce
jen proto, abych ukázal, ¾e se zavedením nebo rozepsáním
funkce principiálnì nic nemìní. Chtìl jsem tím ukázat, ¾e
definice funkce do vyjasòování nic nového nevná¹í. Chtìl
jsem také ukázat, ¾e definice tøídy G do problému
globální/lokální promìnná nic nového nevná¹í. 

Funkce se teoreticky dají vypustit v¾dy -- jejich volání lze
rozepsat jejich tìly --, co¾ ale neznamená, ¾e je jejich
pou¾ívání zbyteèné. Zde spolu nejsme &quot;ve_pøi&quot; ;)

Pou¾ívání funkcí v Pythonu se od pou¾ívání funkcí v
typických kompilovaných jazycích li¹í v tom, ¾e aèkoliv
parametry pøedáváme v¾dy odkazy (nikdy hodnotami), nìkteré z
pøedaných objektù nemù¾eme mìnit (jsou &quot;immutable&quot;, nemìnné
-- typicky èísla a øetìzce). Proto, pokud má pythonovská
funkce modifikovat napøíklad nìjakou èíselnou promìnnou a
nechceme pou¾ívat globální promìnnou, musíme pou¾ívat obrat
podobný následujícímu:

def f(x):
    return x + 1

v = 10
for i in xrange(10):
    v = f(v)
    print v
    
Pro stejný úèel nelze pou¾ít funkci, která by nevyu¾ívala
mo¾nost vracet výslednou hodnotu, ani¾ bychom vyu¾ili nìjaké
globálnì pøístupné struktury:


def f(x):
    x = x + 1

v = 10
for i in xrange(10):
    f(v)
    print v
    

Naposledy uvedený pøíklad by fungoval napøíklad v Pascalu pøi
pøedávání parametru x odkazem. V Pythonu nebude fungovat
nikdy, proto¾e pøíkaz x = x + 1 vede k vytvoøení nového
objektu a k vazbì lokálního jména x na tento novì vytvoøený
objekt. Pùvodní vazba jména v na objekt s hodnotou 10
zùstává nezmìnìna. Novì vytvoøená vazba x se s ukonèením
tìla funkce ztrácí.
    
&gt;<i> Já si tedy OOP dost zjednodu¹uji, tøebas kdy¾ se vytváøí
</I>&gt;<i> nìjaký textový editor v OOP, tak vlastnì celý program je
</I>&gt;<i> jedna velká tøída a uvnitø ní jsou její promìnné 'self.x'
</I>&gt;<i> viditelné ze v¹ech jejích metod. Tomu jsem se právì chtìl
</I>&gt;<i> svým pøístupem pøiblí¾it.
</I>
Pou¾ívání objektovì orientovaného pøístupu by nemìlo být
cílem, ale prostøedkem. Nemá smysl znásilòovat tøídy. Pro
zaèátek je mo¾ná lep¹í osvojit si práci s moduly a uvnitø
definovanými funkcemi. Pokud ti práce s tøídami a s objekty
pøipadá trochu nepøirozená, je dobré zajímat se o to proè.

Postoj se dá zmìnit, vìci se dají douèit a pochopit.
Budováním programu jako jedné velké tøídy mù¾e¹ oddálit svùj
zá¾itek, pocit, pochopení významu OOP. Spoèívá mimo jiné ve
zmìnì pøístupu k programování. Ta zmìna nespoèívá v tom, ¾e
pøestanu pou¾ívat &quot;obyèejné&quot; promìnné, &quot;obyèejné&quot; funkce a
&quot;obyèejné&quot; moduly. Ta zmìna pøístupu spoèívá v tom, ¾e zaènu
slo¾itìj¹í aplikace øe¹it lep¹ím zpùsobem.

Petr

-- 
Petr Prikryl (<A HREF="http://www.py.cz/mailman/listinfo/python">prikrylp na skil.cz</A>)  

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Pøedchozí pøíspìvek: <A HREF="http://www.py.cz/pipermail/python/2005-January/002204.html">[python] globální promìnné
</A></li>
	<LI>Následující pøíspìvek: <A HREF="http://www.py.cz/pipermail/python/2005-January/002206.html">[python] navrhove vzory v Pythonu
</A></li>
         <LI> <B>Zprávy tøídìné podle:</B> 
              <a href="http://www.py.cz/pipermail/python/2005-January/date.html#2205">[ data ]</a>
              <a href="http://www.py.cz/pipermail/python/2005-January/thread.html#2205">[ vlákna ]</a>
              <a href="http://www.py.cz/pipermail/python/2005-January/subject.html#2205">[ subjektu ]</a>
              <a href="http://www.py.cz/pipermail/python/2005-January/author.html#2205">[ autora ]</a>
         </LI>
       </UL>
<hr>
<a href="http://www.py.cz/mailman/listinfo/python">Dal¹í informace o konferenci Python</a><br>
</body>
<!-- Mirrored from www.py.cz/pipermail/python/2005-January/002205.html by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 20 Mar 2016 21:27:56 GMT -->
</html>
