<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 
<!-- Mirrored from www.py.cz/pipermail/python/2005-January/002210.html by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 20 Mar 2016 21:27:56 GMT -->
<HEAD>
   <TITLE> RE: [python] globální promìnné
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:python%40py.cz?Subject=%3D%3Fiso-8859-2%3FQ%3FRE%3D3A_%3D5Bpython%3D5D_glob%3DE1ln%3DED_prom%3DECnn%3DE9%3F%3D&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=iso-8859-2">
   <LINK REL="Previous"  HREF="http://www.py.cz/pipermail/python/2005-January/002209.html">
   <LINK REL="Next"  HREF="http://www.py.cz/pipermail/python/2005-January/002212.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>RE: [python] globální promìnné</H1>
    <B>Petr Prikryl</B> 
    <A HREF="mailto:python%40py.cz?Subject=%3D%3Fiso-8859-2%3FQ%3FRE%3D3A_%3D5Bpython%3D5D_glob%3DE1ln%3DED_prom%3DECnn%3DE9%3F%3D&In-Reply-To="
       TITLE="RE: [python] globální promìnné">Prikryl na skil.cz
       </A><BR>
    <I>Støeda Leden  5 11:16:36 CET 2005</I>
    <P><UL>
        <LI>Pøedchozí pøíspìvek: <A HREF="http://www.py.cz/pipermail/python/2005-January/002209.html">[python] globální promìnné
</A></li>
        <LI>Následující pøíspìvek: <A HREF="http://www.py.cz/pipermail/python/2005-January/002212.html">[python] globální promìnné
</A></li>
         <LI> <B>Zprávy tøídìné podle:</B> 
              <a href="http://www.py.cz/pipermail/python/2005-January/date.html#2210">[ data ]</a>
              <a href="http://www.py.cz/pipermail/python/2005-January/thread.html#2210">[ vlákna ]</a>
              <a href="http://www.py.cz/pipermail/python/2005-January/subject.html#2210">[ subjektu ]</a>
              <a href="http://www.py.cz/pipermail/python/2005-January/author.html#2210">[ autora ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Myslím, ¾e u¾ jsem pochopil o co ti jde. Má to i svùj
termín. Cituji z oficiálního tutorialu Pythonu (2.4):

   9.7 Odds and Ends 
 
   Sometimes it is useful to have a data type similar to the
   Pascal ``record'' or C ``struct'', bundling together a
   couple of named data items. An empty class definition
   will do nicely:

    class Employee:
        pass
    
    john = Employee() # Create an empty employee record
    
    # Fill the fields of the record
    john.name = 'John Doe'
    john.dept = 'computer lab'
    john.salary = 1000

Èesky se tomu øíká záznam (v pascalovské terminologii)
nebo struktura (v jazyce C a C++). 

Python se od zmínìného Pascalu, C a jiných kompilovaných
jazykù li¹í tím, ¾e do takového záznamu mù¾eme za bìhu
pøidávat polo¾ky nebo je naopak ru¹it. V kompilovaných
jazycích mají záznamy pevnou velikost (v pamìti).

&gt;<i> 4/ Tenhle dùvod jsem vykoukal v LiveWires: tato
</I>&gt;<i> superglobalita (proménnì instance tøídy) slou¾í jako jakýsi
</I>&gt;<i> Kontejner vlastností, které mají spoleèný základ. Tøebas:
</I>&gt;<i> 
</I>&gt;<i> hrac=G()
</I>&gt;<i> hrax.souradniceX=0
</I>&gt;<i> hrac.souradniceY=0
</I>&gt;<i> hrac.tvar=...
</I>&gt;<i> 
</I>&gt;<i> ... V¹echno pìknì seskupené pod pøiléhavým názvem a k tomi
</I>&gt;<i> bonus zdarma, ¾e uvnitø v¹ech funkcí, které nìjak ovlivòují
</I>&gt;<i> hraèe nemusím psát &quot;global&quot;
</I>
Tak¾e jinak, nepou¾ívá¹ nic &quot;superglobálního&quot;, ale jednodu¹e
globální promìnnou typu záznam. Tady bych doporuèil, abys ji
nepou¾íval jako globální, ale abys ji pøedával (jako celek)
funkcím, které ji potøebují. Pøíklad:

    class Zaznam():
        pass

    def NovyHrac():
        return Zaznam()
       
    def Inicializace(hrac):
        hrac.x = 0
        hrac.y = 0
        hrac.tvar = '...'
       
   def PresunAbsolutne(hrac, x, y):
        hrac.souradniceX = x
        hrac.souradniceY = y
   
   ...
   
   # Pou¾ití... 
   
   if __name__ == '__main__':
       
       hracA = NovyHrac()
       Inicializace(hracA)
       PresunAbsolutne(hracA, 10, 20)
       
Výhodou je to, ¾e ty stejné funkce mù¾u znovu pou¾ít pro
dal¹ího hráèe (to platí samozøejmì obecnì, i kdy¾ pou¾ívám 
záznamy urèené pro jiný úèel):       

       hracB = NovyHrac()
       Inicializace(hracB)
       PresunAbsolutne(hracB, 30, 50)

Úplná ukázka (doporuèuji nahlédnout) 
<A HREF="http://www.skil.cz/python/ukazka/hra1.py">http://www.skil.cz/python/ukazka/hra1.py</A>       

Z ukázky je vidìt, ¾e pøi takovém pøístupu se poøád na místì
prvního parametru vyskytuje odkaz na záznam hráèe. Pokud
takto pou¾ívám funkce, které jsou velmi tìsnì významovì
vázány k datové èásti záznamu hráèe, pak z nich mohu udìlat
&quot;algoritmické slo¾ky záznamu&quot; hráèe -- funkce pøidru¾ené k
záznamu. Narozdíl od datových slo¾ek není nutné jejich kód
udr¾ovat opakovanì v ka¾dém záznamu, proto¾e je pro v¹echny
záznamy se stejným významem (pro v¹echny hráèe) stejný.

Odtud je ji¾ jen krùèek k OOP. V¹ichni hráèi se chovají
stejnì. Li¹í se pouze vnitøním stavem (hodnotami v datové
èásti). Popis hráèe se obecnì zachytí do konstrukce, které
se øíká tøída. Instanci tøídy se pak neøíká záznam, ale
objekt. Tak jak se u záznamu pøistupovalo k datovým slo¾kám,
tak se pøistupuje i ke slo¾kám záznamu typu funkce -- øíká
se jim metody. Tyto funkce automaticky dostávají první
skrytý parametr, který je odkazem na datovou èást objektu.
Technicky je to toté¾, jako jsme realizovali v pøedchozí
ukázce -- jen se to pøehlednìji zapisuje. A hlavnì, o
objektech uva¾ujeme trochu personifikovanì -- ka¾dý se stará
o svùj vnitøek (data), ve svých metodách se na svou datovou
èást dívá jako na &quot;sebe samotného&quot; (anglicky self) a
komunikuje s ostatními pøi øe¹ení nìjakého problému tím, ¾e
volá zase jejich metody.

Vý¹e uvedený pøíklad s hráèi pak bude vypadat takto.
Inicializace je natolik typickou vlastností, ¾e pro ni je
vyhra¾ena speciální metoda, která se volá automaticky po
vzniku objektu:

    class Hrac:
        def __init__(self):
            self.x = 0
            self.y = 0
            self.tvar = '...'
           
        def PresunAbsolutne(self, x, y):
            self.x = x
            self.y = y
           
        ...
        
    # Pou¾ití...
    
    if __name__ == '__main__':
    
        hracA = Hrac()
        hracA.PresunAbsolutne(10, 20)
        
        hracB = Hrac()
        hracB.PresunAbsolutne(30, 50)

Vý¹e odkazované øe¹ení 
<A HREF="http://www.skil.cz/python/ukazka/hra1.py">http://www.skil.cz/python/ukazka/hra1.py</A>       
je vlastnì objektové, ale k zápisu vyu¾ívá
pouze prostøedky procedurálního programování.
Python jednodu¹e nepodporuje definice datových
blokù typu záznam, proto se zde zneu¾ívá 
konstrukce class.

Druhé øe¹ení -- viz
<A HREF="http://www.skil.cz/python/ukazka/hra2.py">http://www.skil.cz/python/ukazka/hra2.py</A> --
vyu¾ívá pro stejné øe¹ení tého¾ problému
jazykové prostøedky pro práci s tøídami a objekty.
        

My¹lenka tøíd a jejich instancí (objektù) tedy jen
formálnìji zachycuje pøístup, kdy chceme vyjádøit
sounále¾itost datových slo¾ek formou vy¹¹ího celku --
záznamu. Navíc chceme vyjádøit, ¾e k tomuto typu záznamu
jsou vázány i vybrané funkce (metody tøídy).

Objektovì orientovaný pøístup k programování problému spoèívá v
dùsledném balení souvisejících dat do záznamù a ve vytváøení
souvisejících funkcí, kterým systematicky pøedáváme
související záznam jako první parametr. Dal¹í údaje, které
nesouvisejí s vnitøním stavem záznamu, se dodávají jako
dal¹í parametry.

Objektovì orientované jazyky tento pøístup usnadòují tím, ¾e
pro popis souvisejících datových a funèních èástí poskytují
konstrukci pro popis tøídy a pøíslu¹ná syntaktická
pravidla (formy zápisu v programovacím jazyce). První
parametr funkce/metody (odkaz na záznam) se nezapisuje jako
první parametr funkce, ale pøed jméno funkce (oddìleno
teèkou). Usnadní se tím &quot;personifikované&quot; vnímání objektù.
Kromì toho OO jazyky podporují dal¹í vylep¹ení, které
zlep¹ují udr¾ovatelnost programu.

V Pythonu se pøi zápisu metod tøídy se první parametr uvádí
a má význam reference na sebe sama. Doporuèuje se, aby
jsme jej pojmenovali self, ale v souvislostí s prvním
pøíkladem by se klidnì mohl jmenovat hrac:

        def PresunAbsolutne(self, x, y):
   
Pøi volání metody objektu se ji¾ se self nikde nepotkáme.
Zastupuje jej odkaz na objekt zapisovaný pøed jméno metody:

        hrac.PresunAbsolutne(xx, yy)

Mù¾u se na to dívat tak, ¾e okolí zná objekt pod jménem
hrac, ale objekt (zevnitø) své unikátní jméno znát 
nepotøebuje. Ví, ¾e je to &quot;on sám&quot; (self). Objekt má
jakoby jiné jméno zvenku a jiné zevnitø, ale je to poøád
ten stejný objekt. Mù¾eme zkusit vypsat:

        print id(hrac)  # v místì pou¾ívání objektu
  nebo 
        print id(self)  # pøidat do tìla PresunAbsolutne()

Mìlo by se objevit stejné èíslo.

Napøíklad v jazyce C++ se tento odkaz pøi definici 
metod jako první parametr neuvádí, ale má vyhrazené 
jméno this (ukazatel na sebe sama, èesky &quot;tento&quot;).

Procedurální (strukturované) programování lze
charakterizovat tak, ¾e mám na jedné stranì data a na druhé
stranì algoritmy, které s daty manipulují. Neexistuje
formální vazba mezi algoritmy a daty. Kdy¾ si nedáme pozor,
mù¾eme funkci pøi volání pøedat parametr správného typu
(napøíklad èíslo), ale s jiným významem (napøíklad
èíslo domu místo roku narození).

Objektovì orientované programování se na øe¹ení problémù
dívá jako na spolupráci podsystémù, které øe¹í podproblémy.
Ka¾dý podproblém je reprezentován tøídou, právì zpracovávaný
podproblém je reprezentován objektem této tøídy. Ka¾dý
objekt se strará o svùj stav. Kdy¾ potøebuje vìdìt nìco o
svém okolí, zeptá se okolních objektù (musí si ve své datové
èásti udr¾ovat odkaz na tyto objekty nebo musí vyu¾ít nìjaké
dohodnuté formy, kterou k nim získá pøístup). Pokud se
objektu nìkdo z okolí zeptá (voláním jeho metody), odpoví mu
(návratová hodnota metody).

Pou¾ívání globálních promìnných do schématu spolupracujících
èástí nezapadá, proto¾e na globální promìnnou se mù¾u dívat
jako kdyby patøila k datové èásti v¹ech objektù. Zmìnou
globální promìnné tedy jakoby najednou mìním stav v¹ech
objektù a to i tìch, o kterých nevím. To znamená, ¾e u
nìkterých objektù mohu neèekanì ovlivnit jejich dal¹í
chování. V tom spoèívá ten problém. Proto bychom se
globálním promìnným mìli vyhýbat.

Obèas zmiòovaná men¹í efektivnost programù zapsaných 
objektovì orientovaným pøístupem je diskutabilní. 
Neefektivnosti vyplývají spí¹e z nepochopení toho, jak
by se to mìlo dìlat -- ze ¹patného návrhu aplikace.


To pro dne¹ek staèí ;)

Petr

-- 
Petr Prikryl (prikrylp at skil dot cz) 

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Pøedchozí pøíspìvek: <A HREF="http://www.py.cz/pipermail/python/2005-January/002209.html">[python] globální promìnné
</A></li>
	<LI>Následující pøíspìvek: <A HREF="http://www.py.cz/pipermail/python/2005-January/002212.html">[python] globální promìnné
</A></li>
         <LI> <B>Zprávy tøídìné podle:</B> 
              <a href="http://www.py.cz/pipermail/python/2005-January/date.html#2210">[ data ]</a>
              <a href="http://www.py.cz/pipermail/python/2005-January/thread.html#2210">[ vlákna ]</a>
              <a href="http://www.py.cz/pipermail/python/2005-January/subject.html#2210">[ subjektu ]</a>
              <a href="http://www.py.cz/pipermail/python/2005-January/author.html#2210">[ autora ]</a>
         </LI>
       </UL>
<hr>
<a href="http://www.py.cz/mailman/listinfo/python">Dal¹í informace o konferenci Python</a><br>
</body>
<!-- Mirrored from www.py.cz/pipermail/python/2005-January/002210.html by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 20 Mar 2016 21:27:56 GMT -->
</html>
