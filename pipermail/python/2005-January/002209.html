<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 
<!-- Mirrored from www.py.cz/pipermail/python/2005-January/002209.html by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 20 Mar 2016 21:27:56 GMT -->
<HEAD>
   <TITLE> [python] globální promìnné
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:python%40py.cz?Subject=%5Bpython%5D%20%3D%3FISO-8859-2%3FQ%3Fglob%3DE1ln%3DED_prom%3DECnn%3DE9%3F%3D&In-Reply-To=mailman.1.1104827099.1562.python%40py.cz">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=iso-8859-2">
   <LINK REL="Previous"  HREF="http://www.py.cz/pipermail/python/2005-January/002208.html">
   <LINK REL="Next"  HREF="http://www.py.cz/pipermail/python/2005-January/002210.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[python] globální promìnné</H1>
    <B>p.kosina</B> 
    <A HREF="mailto:python%40py.cz?Subject=%5Bpython%5D%20%3D%3FISO-8859-2%3FQ%3Fglob%3DE1ln%3DED_prom%3DECnn%3DE9%3F%3D&In-Reply-To=mailman.1.1104827099.1562.python%40py.cz"
       TITLE="[python] globální promìnné">gen2n na seznam.cz
       </A><BR>
    <I>Úterý Leden  4 15:57:52 CET 2005</I>
    <P><UL>
        <LI>Pøedchozí pøíspìvek: <A HREF="http://www.py.cz/pipermail/python/2005-January/002208.html">[python] navrhove vzory v Pythonu
</A></li>
        <LI>Následující pøíspìvek: <A HREF="http://www.py.cz/pipermail/python/2005-January/002210.html">RE: [python] globální promìnné
</A></li>
         <LI> <B>Zprávy tøídìné podle:</B> 
              <a href="http://www.py.cz/pipermail/python/2005-January/date.html#2209">[ data ]</a>
              <a href="http://www.py.cz/pipermail/python/2005-January/thread.html#2209">[ vlákna ]</a>
              <a href="http://www.py.cz/pipermail/python/2005-January/subject.html#2209">[ subjektu ]</a>
              <a href="http://www.py.cz/pipermail/python/2005-January/author.html#2209">[ autora ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Ahoj,

Zvykl jsem si na Outlookový styl, snad mi to projde, ¾e odpovídám nahoøe
a ne v textu.

Jsem skuteènì spí¹ praktik, teorii zaèínám vyhledávat, a¾ kdy¾ mi nìco
nefunguje, tak¾e èasto asi nepou¾ívám správné termíny, ale postupnì to
vylep¹uji :-).

Jaké výhody získám zavedením mé superglobální promìnné oproti obyèejným
globálním promìnným? (ov¹em za pøedpokladu, ¾e je ve svých funkcích
nepøepí¹i, jak jsi ukazoval (promin ze jsem svou odpoved shrnul do tak
krátké vìty) - to samozøejme nesmím, ale na to musím dávat pozor i u
ohromných tøíd, abych dvakrát nepou¾il self.pocet=...)

1/ nemusím ve v¹ech svých funkcích typovat global x
Ov¹em ono to v praxi není takto pøehledné global x, ale vìt¹inou
global pocetStrel, souradniceX, souradniceY, PocetZivotù,...... a ve 3-5 
funkcích. Prostì program získává na pøehlednosti.

2/ bod èíslo 2 není....

3/ kdy¾ potøebuji uvnitø mé funkce promìnnou, ve které
potøebuji, aby zùstala její hodnota i do dal¹ího volání funkce.
A zase, teoreticky není problém udìlat return x, ale v praxi, je tam
tìch dlouhojmenných promìnných habakuk.

4/ Tenhle dùvod jsem vykoukal v LiveWires: tato superglobalita (proménnì
instance tøídy) slou¾í jako jakýsi Kontejner vlastností, které mají
spoleèný základ. Tøebas :
hrac=G()
hrax.souradniceX=0
hrac.souradniceY=0
hrac.tvar=...
... V¹echno pìknì seskupené pod pøiléhavým názvem a k tomi bonus zdarma,
¾e uvnitø v¹ech funkcí, které nìjak ovlivòují hraèe nemusím psát &quot;global&quot;

Singleton - je to hezká idea, ale myslím ¾e to není to o co se sna¾ím.

Jinak díky za ty pøíklady, upopzornili mì na mo¾ná úskalí.

Abych i prakticky podpoøil mé sna¾ení, mám dva pøíklady. Jeden se
pou¾ívá v tìch LiveWires a ten druhý tu chci ukázat. Mìl jsem vèera
potøebu z registru win98 odstranit v¹echny klíèe, kde je 'avg6' (nìjak
mi ne¹la instalace avg7. Nakonec z toho vzniklo rekurzivní volání s
významným zasoupením superglobalnosti, kdy zbyteènì funkci stále
nepøedávám v agrumentech, co je nemìnné (hledaný text, ..) a jako bonus 
jsem získal nìco jako g.pocet, kde nasèítám zcela transparentnì poèet 
výskytù hledaného textu a taky tøeba g.cesta, kde appenduji jednotlive 
klice, jak jimi prochazim. Mo¾ná ten pøíklad z LiveWires je hezèí, ale 
tenhle je u¾iteènìj¹í...
SKRIPT NIC NEMA®E ANI NEMÌNÍ, JEN TISKNE, PØESTO JE POU®ITÍ JEN NA
VLASTNÍ NEBEZPEÈÍ.
<A HREF="http://www.alpha-site.wz.cz/zaci/amos/registrWindows.py">http://www.alpha-site.wz.cz/zaci/amos/registrWindows.py</A>


Ufff, 0,5 hodiny psaní + 5 hodin ladìní skriptu.
Is it worth it? I hope so.

Pavel




Petr Prikryl napsal(a):
&gt;<i> Ahoj Pavle, (doufám, ¾e tykání nevadí ;)
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i>Dìkuji za vyèerpávající vysvìtlení. Nechci vypadat jako
</I>&gt;&gt;<i>Tluèhuba :-), pøesto zkusím je¹tì jednou mùj postoj.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> Já zase nechci vypadat jako pøechytralý, ale mùj obor
</I>&gt;<i> vzdìlání a praxe mi alespoò statisticky zaruèuje, ¾e bych se
</I>&gt;<i> v tomto pøípadì nemusel mýlit.
</I>&gt;<i> 
</I>&gt;<i> Pokud jde o postoj, jeho zmìna by ti mo¾ná pomohla posunout
</I>&gt;<i> se o kousek dál. Tøeba ti v tom pomù¾u.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i>class G:
</I>&gt;&gt;<i>   pass
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>g=G()
</I>&gt;&gt;<i>g.x=30
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>Mo¾ná nepou¾ívám nejsprávnìj¹í terminologii, kdy¾ nazývám x
</I>&gt;&gt;<i>globální promìnnou (ano, je to lokální uvnitø G), nicménì
</I>&gt;&gt;<i>objekt 'g.x' je &quot;veøejnì pøístupný&quot;, *ze v¹ech funkcí
</I>&gt;&gt;<i>mìnitelný bez jakýchkoliv dal¹ích fíglu v rámci celého
</I>&gt;&gt;<i>programu*, jedná se tedy, podle mne, o mnou obhajovanou
</I>&gt;&gt;<i>superglobalni (superglobalni z hlediska celého programu a ne
</I>&gt;&gt;<i>jednotlivé tøídy èi instance - z jejich hlediska to je
</I>&gt;&gt;<i>samozøejmì lokální) promìnnou. Ale i výraz veøejnì pøístupný
</I>&gt;&gt;<i>je OK, nic to na vìci nemìní. Mo¾ná se pletu, mo¾ná existují
</I>&gt;&gt;<i>skulinky, kdy to neplatí, nicménì v programu s pár funkcemi
</I>&gt;&gt;<i>a jednou main to funguje.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> Pøi debatách o programování je opravdu dobré pou¾ívat
</I>&gt;<i> jednotnou terminologii, proto¾e jinak si v¹ichni mù¾eme
</I>&gt;<i> vìcnì myslet to samé a pøitom se budeme hádat. &quot;Globálnì
</I>&gt;<i> pøístupná&quot; znamená pøístupná ze v¹ech míst programu bez
</I>&gt;<i> výjimky. Slo¾ka x není pøístupná odkudkoliv -- pouze pøes g.
</I>&gt;<i> Nemù¾e tedy být globální. Ale proto¾e g je pøístupné, pak je
</I>&gt;<i> i jeho veøejná slo¾ka pøístupná. To nemá s globálností
</I>&gt;<i> pøístupu nic spoleèného. Pí¹e¹ &quot;(ano, je to lokální uvnitø
</I>&gt;<i> G)&quot;. To není pravda. Slo¾ka x je pøístupná pøes g, nikoliv
</I>&gt;<i> pøes G. Není souèástí tøídy, je souèástí instance tøídy
</I>&gt;<i> (objektu). Tøída pouze pøedepisuje chování, objekt je
</I>&gt;<i> realizuje.
</I>&gt;<i> 
</I>&gt;<i> Zavedením objektu g nic superglobálního nevyøe¹ím. Je to jen
</I>&gt;<i> fale¹ný dojem. Pouze se ti slo¾itìj¹ím zpùsobem podaøilo
</I>&gt;<i> vyjádøit nìco podobného, jako kdybys vytvoøil skuteènì
</I>&gt;<i> globální promìnnou x. Funguje to úplnì stejnì, jen¾e kvùli
</I>&gt;<i> zvý¹ení slo¾itosti vyjádøení jsi pøehlédl, ¾e je to úplnì
</I>&gt;<i> stejné. Zkus tohle (pro zjednodu¹ení vynechávám èe¹tinu,
</I>&gt;<i> okopíruj do souboru a spus»):
</I>&gt;<i> 
</I>&gt;<i> ========================================================
</I>&gt;<i> 
</I>&gt;<i> class G:
</I>&gt;<i>    pass
</I>&gt;<i> 
</I>&gt;<i>    
</I>&gt;<i> def fa():
</I>&gt;<i>     g = 'funkce fa() lokalne predefinovala jmeno g'
</I>&gt;<i>     print 'Uvnitr fa():', g
</I>&gt;<i>     
</I>&gt;<i>     try:
</I>&gt;<i>         print 'Pokus o pristup k g.x uvnitr fa():', g.x
</I>&gt;<i>     except:
</I>&gt;<i>         print 'Chyba!'
</I>&gt;<i>         
</I>&gt;<i> 
</I>&gt;<i> def fb():
</I>&gt;<i>     g = G()       # nova, lokalni instance tridy G
</I>&gt;<i>     g.x = 'hodnota lokalni instance objektu -- fb()'
</I>&gt;<i>     print 'Uvnitr fb():', g.x
</I>&gt;<i>     
</I>&gt;<i>     
</I>&gt;<i> g = G()
</I>&gt;<i> g.x = 'superglobalni hodnota'
</I>&gt;<i> 
</I>&gt;<i> print '\n\n\n' + '-' * 20           # jen oddelovac
</I>&gt;<i> print 'Na globalni urovni:', g.x
</I>&gt;<i> 
</I>&gt;<i> fa()
</I>&gt;<i> 
</I>&gt;<i> print 'Na globalni urovni:', g.x
</I>&gt;<i> 
</I>&gt;<i> fb()
</I>&gt;<i> 
</I>&gt;<i> print 'Na globalni urovni:', g.x
</I>&gt;<i> 
</I>&gt;<i> g2 = g        # navazu objekt na jine jmeno
</I>&gt;<i> g = 'nove g'
</I>&gt;<i> 
</I>&gt;<i> print 'Objekt s jinym jmenem:', g2.x    # OK
</I>&gt;<i> print 'Nova hodnota pojmenovana g:', g
</I>&gt;<i> print 'Na globalni urovni:', g.x        # chyba
</I>&gt;<i> 
</I>&gt;<i> ========================================================
</I>&gt;<i> 
</I>&gt;<i> V¹imni si, ¾e funkce fa() i fb() definují svou lokální
</I>&gt;<i> promìnnou g a tím (doèasnì, v jejich tìle) znepøístupní 
</I>&gt;<i> g definovanou na globální úrovni. Funkce fa() mìní typ
</I>&gt;<i> promìnné zpøístupòované pøes jméno g, funkce fb() zachovává
</I>&gt;<i> dokonce stejný typ (stejnou tøídu) objektu. Ale pro celý
</I>&gt;<i> kód uvnitø fb() a pro v¹echny pøípadné funkce volané z fb()
</I>&gt;<i> znemo¾òuje pøístup k objektu g na globální úrovni. Místo
</I>&gt;<i> nìj podstrèí lokálnìj¹í g, definovaný na úrovni tìla fb().
</I>&gt;<i> 
</I>&gt;<i> Teï pøepí¹u toté¾ bez tøídy G a jejích instancí. Místo g.x
</I>&gt;<i> budu psát x a místo g2.x budu psát x2. Uvnitø fa() nebude
</I>&gt;<i> nutné o¹etøovat pøístup ke slo¾ce x a zviditelní se tím
</I>&gt;<i> lokálnost nového x. Funkce fb() nyní demonstruje pou¾ití
</I>&gt;<i> klíèového slova global, které potlaèí vytvoøení lokálního x
</I>&gt;<i> (narozdíl od fa()).
</I>&gt;<i> 
</I>&gt;<i> ========================================================
</I>&gt;<i> 
</I>&gt;<i> def fa():
</I>&gt;<i>     x = 'funkce fa() lokalne predefinovala jmeno x'
</I>&gt;<i>     print 'Uvnitr fa():', x
</I>&gt;<i>     
</I>&gt;<i> def fb():
</I>&gt;<i>     global x
</I>&gt;<i>     x = 'nova globalni hodnota x'
</I>&gt;<i>     print 'Uvnitr fb():', x
</I>&gt;<i>     
</I>&gt;<i> x = 'globalni hodnota'
</I>&gt;<i> 
</I>&gt;<i> print '\n\n\n' + '-' * 20           # jen oddelovac
</I>&gt;<i> print 'Na globalni urovni:', x
</I>&gt;<i> 
</I>&gt;<i> fa()
</I>&gt;<i> 
</I>&gt;<i> print 'Na globalni urovni:', x
</I>&gt;<i> 
</I>&gt;<i> fb()
</I>&gt;<i> 
</I>&gt;<i> print 'Na globalni urovni:', x
</I>&gt;<i> 
</I>&gt;<i> x2 = x        # navazu objekt na jine jmeno
</I>&gt;<i> x = 'nove x'
</I>&gt;<i> 
</I>&gt;<i> print 'Objekt s jinym jmenem:', x2    # OK
</I>&gt;<i> print 'Nova hodnota x:', x
</I>&gt;<i> 
</I>&gt;<i> ========================================================
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i>Uznávám, není to èisté øe¹ení, pøesto mi to pøipadá
</I>&gt;&gt;<i>&quot;èistìj¹í&quot; ne¾ pou¾ití global. 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> Klíèové slovo 'global' není neèisté. Pouze umo¾òuje &quot;neèisté
</I>&gt;<i> praktiky&quot; pou¾ívání globálních promìnných. Tím, ¾e sis
</I>&gt;<i> &quot;nìjak&quot; vynutil zabalení x do nadøízené struktury, ses
</I>&gt;<i> jakoby vyhnul pou¾ití globální promìnné z hlediska jména x,
</I>&gt;<i> ale nevyhnul ses pou¾ívání globální promìnné z hlediska
</I>&gt;<i> jména g, jeho¾ je x slo¾kou. Pokud tvoje funkce nebudou
</I>&gt;<i> definovat novou hodnotu g jako celku (neprovedou novou vazbu
</I>&gt;<i> mezi jménem g a jiným objektem) a budou pouze pracovat s
</I>&gt;<i> jeho slo¾kami, pak jsi vyøe¹il svùj problém.
</I>&gt;<i> 
</I>&gt;<i> Napadá mì, ¾e mo¾ná intuitivnì smìøuje¹ k øe¹ení, kterému se
</I>&gt;<i> v objektovì orientovaném návrhu øíká singleton (jeden z
</I>&gt;<i> návrhových vzorù). Singleton je objekt, u kterého je
</I>&gt;<i> zaji¹tìno, ¾e existuje v jediné instanci. To znamená, ¾e i
</I>&gt;<i> kdy¾ nemusí mít pøidìlené jméno, v¾dy se nìjak dostanu k
</I>&gt;<i> jedinému objektu. Pokud si nìjak zajistím pøístup k objektu
</I>&gt;<i> této tøídy, pak je zaji¹tìno, ¾e budu pracovat s jediným
</I>&gt;<i> mo¾ným a tím samým objektem. Typicky se k nìmu
</I>&gt;<i> nedostávám pøes jméno, ale pokusím se o vytvoøení instance
</I>&gt;<i> vyhrazené tøídy. Tøída ale zajistí, ¾e se objekt vytvoøí jen
</I>&gt;<i> poprvé a pøi ostatních pokusech se místo nových instancí
</I>&gt;<i> vracejí reference na ji¾ existující, jediný objekt. Jde 
</I>&gt;<i> návrhový vzor, který se pou¾ívá napøíè rùznými OO jazyky,
</I>&gt;<i> ale v rùzných jazycích se implementuje rùzným zpùsobem.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;&gt;<i>Kdy¾ ukazujete &quot;zjednodu¹ování&quot; kódu vypou¹tìním funkcí f()
</I>&gt;&gt;<i>i r(), tak to nevyjadøuje praxi. V praxi samozøejmì funkce
</I>&gt;&gt;<i>takto jednoduché nejsou a nedají se vypustit, proto¾e &quot;nìco
</I>&gt;&gt;<i>dìlají&quot; a veøejnì pøístupné promìnné jsou tam jenom pro
</I>&gt;&gt;<i>usnadnìní práce (funkce tam není samoúèelnì, kvùli nim), pro
</I>&gt;&gt;<i>zpøehlednìní kódu, pro pøiblí¾ení se práce v OOP. Snad
</I>&gt;&gt;<i>klasickým pøípadem je vznik nových promìnných ve funkci,
</I>&gt;&gt;<i>které v¹ak je tøeba si uchovat do dal¹ího prùchodu
</I>&gt;&gt;<i>funkcí,kde se s nimi bude opìt pracovat.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> V pøíkladech z minulé diskuse jsem zavádìl a ru¹il funkce
</I>&gt;<i> jen proto, abych ukázal, ¾e se zavedením nebo rozepsáním
</I>&gt;<i> funkce principiálnì nic nemìní. Chtìl jsem tím ukázat, ¾e
</I>&gt;<i> definice funkce do vyjasòování nic nového nevná¹í. Chtìl
</I>&gt;<i> jsem také ukázat, ¾e definice tøídy G do problému
</I>&gt;<i> globální/lokální promìnná nic nového nevná¹í. 
</I>&gt;<i> 
</I>&gt;<i> Funkce se teoreticky dají vypustit v¾dy -- jejich volání lze
</I>&gt;<i> rozepsat jejich tìly --, co¾ ale neznamená, ¾e je jejich
</I>&gt;<i> pou¾ívání zbyteèné. Zde spolu nejsme &quot;ve_pøi&quot; ;)
</I>&gt;<i> 
</I>&gt;<i> Pou¾ívání funkcí v Pythonu se od pou¾ívání funkcí v
</I>&gt;<i> typických kompilovaných jazycích li¹í v tom, ¾e aèkoliv
</I>&gt;<i> parametry pøedáváme v¾dy odkazy (nikdy hodnotami), nìkteré z
</I>&gt;<i> pøedaných objektù nemù¾eme mìnit (jsou &quot;immutable&quot;, nemìnné
</I>&gt;<i> -- typicky èísla a øetìzce). Proto, pokud má pythonovská
</I>&gt;<i> funkce modifikovat napøíklad nìjakou èíselnou promìnnou a
</I>&gt;<i> nechceme pou¾ívat globální promìnnou, musíme pou¾ívat obrat
</I>&gt;<i> podobný následujícímu:
</I>&gt;<i> 
</I>&gt;<i> def f(x):
</I>&gt;<i>     return x + 1
</I>&gt;<i> 
</I>&gt;<i> v = 10
</I>&gt;<i> for i in xrange(10):
</I>&gt;<i>     v = f(v)
</I>&gt;<i>     print v
</I>&gt;<i>     
</I>&gt;<i> Pro stejný úèel nelze pou¾ít funkci, která by nevyu¾ívala
</I>&gt;<i> mo¾nost vracet výslednou hodnotu, ani¾ bychom vyu¾ili nìjaké
</I>&gt;<i> globálnì pøístupné struktury:
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> def f(x):
</I>&gt;<i>     x = x + 1
</I>&gt;<i> 
</I>&gt;<i> v = 10
</I>&gt;<i> for i in xrange(10):
</I>&gt;<i>     f(v)
</I>&gt;<i>     print v
</I>&gt;<i>     
</I>&gt;<i> 
</I>&gt;<i> Naposledy uvedený pøíklad by fungoval napøíklad v Pascalu pøi
</I>&gt;<i> pøedávání parametru x odkazem. V Pythonu nebude fungovat
</I>&gt;<i> nikdy, proto¾e pøíkaz x = x + 1 vede k vytvoøení nového
</I>&gt;<i> objektu a k vazbì lokálního jména x na tento novì vytvoøený
</I>&gt;<i> objekt. Pùvodní vazba jména v na objekt s hodnotou 10
</I>&gt;<i> zùstává nezmìnìna. Novì vytvoøená vazba x se s ukonèením
</I>&gt;<i> tìla funkce ztrácí.
</I>&gt;<i>     
</I>&gt;<i> 
</I>&gt;&gt;<i>Já si tedy OOP dost zjednodu¹uji, tøebas kdy¾ se vytváøí
</I>&gt;&gt;<i>nìjaký textový editor v OOP, tak vlastnì celý program je
</I>&gt;&gt;<i>jedna velká tøída a uvnitø ní jsou její promìnné 'self.x'
</I>&gt;&gt;<i>viditelné ze v¹ech jejích metod. Tomu jsem se právì chtìl
</I>&gt;&gt;<i>svým pøístupem pøiblí¾it.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> Pou¾ívání objektovì orientovaného pøístupu by nemìlo být
</I>&gt;<i> cílem, ale prostøedkem. Nemá smysl znásilòovat tøídy. Pro
</I>&gt;<i> zaèátek je mo¾ná lep¹í osvojit si práci s moduly a uvnitø
</I>&gt;<i> definovanými funkcemi. Pokud ti práce s tøídami a s objekty
</I>&gt;<i> pøipadá trochu nepøirozená, je dobré zajímat se o to proè.
</I>&gt;<i> 
</I>&gt;<i> Postoj se dá zmìnit, vìci se dají douèit a pochopit.
</I>&gt;<i> Budováním programu jako jedné velké tøídy mù¾e¹ oddálit svùj
</I>&gt;<i> zá¾itek, pocit, pochopení významu OOP. Spoèívá mimo jiné ve
</I>&gt;<i> zmìnì pøístupu k programování. Ta zmìna nespoèívá v tom, ¾e
</I>&gt;<i> pøestanu pou¾ívat &quot;obyèejné&quot; promìnné, &quot;obyèejné&quot; funkce a
</I>&gt;<i> &quot;obyèejné&quot; moduly. Ta zmìna pøístupu spoèívá v tom, ¾e zaènu
</I>&gt;<i> slo¾itìj¹í aplikace øe¹it lep¹ím zpùsobem.
</I>&gt;<i> 
</I>&gt;<i> Petr
</I>&gt;<i> 
</I>
</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Pøedchozí pøíspìvek: <A HREF="http://www.py.cz/pipermail/python/2005-January/002208.html">[python] navrhove vzory v Pythonu
</A></li>
	<LI>Následující pøíspìvek: <A HREF="http://www.py.cz/pipermail/python/2005-January/002210.html">RE: [python] globální promìnné
</A></li>
         <LI> <B>Zprávy tøídìné podle:</B> 
              <a href="http://www.py.cz/pipermail/python/2005-January/date.html#2209">[ data ]</a>
              <a href="http://www.py.cz/pipermail/python/2005-January/thread.html#2209">[ vlákna ]</a>
              <a href="http://www.py.cz/pipermail/python/2005-January/subject.html#2209">[ subjektu ]</a>
              <a href="http://www.py.cz/pipermail/python/2005-January/author.html#2209">[ autora ]</a>
         </LI>
       </UL>
<hr>
<a href="http://www.py.cz/mailman/listinfo/python">Dal¹í informace o konferenci Python</a><br>
</body>
<!-- Mirrored from www.py.cz/pipermail/python/2005-January/002209.html by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 20 Mar 2016 21:27:56 GMT -->
</html>
