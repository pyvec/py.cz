<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 
<!-- Mirrored from www.py.cz/pipermail/python/2007-January/005333.html by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 20 Mar 2016 21:23:49 GMT -->
<HEAD>
   <TITLE> [python] Modifikace seznamu bez kopirovnani (bylo SQLite - forma selectovaných dat)
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:python%40py.cz?Subject=%5Bpython%5D%20%3D%3Fiso-8859-2%3Fq%3FModifikace_seznamu_bez_kopirovnani_%3D28byl%3F%3D%0A%09%3D%3Fiso-8859-2%3Fq%3Fo_SQLite_-_forma_selectovan%3DFDch_dat%3D29%3F%3D&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=iso-8859-2">
   <LINK REL="Previous"  HREF="http://www.py.cz/pipermail/python/2007-January/005332.html">
   <LINK REL="Next"  HREF="http://www.py.cz/pipermail/python/2007-January/005336.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[python] Modifikace seznamu bez kopirovnani (bylo SQLite - forma selectovaných dat)</H1>
    <B>Petr Prikryl</B> 
    <A HREF="mailto:python%40py.cz?Subject=%5Bpython%5D%20%3D%3Fiso-8859-2%3Fq%3FModifikace_seznamu_bez_kopirovnani_%3D28byl%3F%3D%0A%09%3D%3Fiso-8859-2%3Fq%3Fo_SQLite_-_forma_selectovan%3DFDch_dat%3D29%3F%3D&In-Reply-To="
       TITLE="[python] Modifikace seznamu bez kopirovnani (bylo SQLite - forma selectovaných dat)">PrikrylP na skil.cz
       </A><BR>
    <I>Pondìlí Leden  8 08:32:50 CET 2007</I>
    <P><UL>
        <LI>Pøedchozí pøíspìvek: <A HREF="http://www.py.cz/pipermail/python/2007-January/005332.html">[python] *^*^*^*^8=====&gt; Sexy Bikini Video Downloads	&lt;=====8*^*^*^*^*^*
</A></li>
        <LI>Následující pøíspìvek: <A HREF="http://www.py.cz/pipermail/python/2007-January/005336.html">[python] Modifikace seznamu bez kopirovnani (bylo SQLite - forma selectovaných dat)
</A></li>
         <LI> <B>Zprávy tøídìné podle:</B> 
              <a href="http://www.py.cz/pipermail/python/2007-January/date.html#5333">[ data ]</a>
              <a href="http://www.py.cz/pipermail/python/2007-January/thread.html#5333">[ vlákna ]</a>
              <a href="http://www.py.cz/pipermail/python/2007-January/subject.html#5333">[ subjektu ]</a>
              <a href="http://www.py.cz/pipermail/python/2007-January/author.html#5333">[ autora ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>superman
&gt;<i> &gt; JInak, proc pouzivate for i in range(len(a)): ? Uz jsem si toho
</I>&gt;<i> &gt; vsimnul driv, u jinych prispevku. Preci, kdyz chci iterovat pres
</I>&gt;<i> &gt; prvky, tak musi staci for item in a:
</I>&gt;<i> [...]
</I>&gt;<i> 2) Proto¾e taková iterace je read only. Já mù¾u dát for item 
</I>&gt;<i>    in a, ale u¾ nezmìním ten konkrétní prvek pøímo v poli.
</I>&gt;<i>    [...] Existuje mo¾nost jak to udìlat bez indexování a bez 
</I>&gt;<i>    toho, aby v pamìti byly doèasnì dvì pole?
</I>
Iterace není &quot;read only&quot;. Read only jsou zpøístupòované objekty.

Od Python 2.3 existuje standardní funkce enumerate(), která
vrací iterátor. Jeho metoda next() vrací dvojici (index, element).
Tak¾e pùvodní kód

  a = [(1,2),(3,4)]
  for i in range(len(a)):
      a[i] = list(a[i])

Mù¾u pøepsat na 

  a = [ (1, 2), (3, 4) ]
  for i, elem in enumerate(a):
      a[i] = list(elem)

V pùvodním kódu je navíc pou¾ito range(), které by mìlo
být alespoò nahrazeno xrange(). Dal¹í problém je v tom,
¾e do pùvodního øe¹ení nemohu zasadit &quot;nekoneènou&quot; 
iterovatelnou strukturu.

Podobný nedostatek má i øe¹ení Luká¹e Linharta

  data2 = [list(t) for t in data]

které navíc provádí kopii celého seznamu. Na druhou stranu
je velmi jednoduché a pøehledné a zále¾í na tom, jaký
problém chci ve skuteènosti øe¹it (jak velké jsou konvertované
struktury a jak èasto chci konverzi provádìt).

Pokud bych chtìl být extrémista, pak lze pøi zpracování
seznamu na místì samém (pou¾ívá se pojem &quot;in situ&quot;)
kombinovat enumerate() s testováním typu elementu 
a konverzi provádìt jen pro elementy typu tuple:

from types import *
a = [ (1, 2), (3, 4) ]
for i, elem in enumerate(a):
    if type(elem) is TupleType:
        a[i] = list(elem)

&gt;<i> V PHP existuje stejná iterace, dokonce si tam mù¾ete udìlat 
</I>&gt;<i> i vlastní iterátor, èeho¾ jsem hojnì vyu¾íval ve svých 
</I>&gt;<i> tøídách a objektech. Ale v PHP je iterátor dvojí, jeden 
</I>&gt;<i> read only jako v Pythonu a druhý s mo¾ností zmìnit prvek 
</I>&gt;<i> pole, a ten mi v Pythonu chybí (a nebo o nìm nevím).
</I>
V Pythonu mù¾u rovnì¾ definovat vlastní iterátor, 
který nejspí¹e nabude podobu generátoru. Pokud bych
mìl definován vlastní kontejner, pak od Python 2.2
mohu definovat i jeho vlastní iterátor dodefinováním
metod __iter__() a next().

Tohle je problém v rozdílném pojetí homogenního pole
(v¹echny prvky mají stejný typ) a pythonovského
seznamu, který je svým zpùsobem sice taky homogenní,
ale obsahuje jen reference, které se automaticky 
dereferencují (kdy¾ u¾ musím pou¾ít tak pìknì èeské slovo).

Iterátor pøes pythonovský seznam mì odkazuje na stejný
objekt, na jaký odkazuje a[i], ale nemohu se pøes nìj
dostat na samotný seznam a. Nemohu tedy zmìnit obsah 
seznamu. Nemohu tedy nahradit odkaz na n-tici odkazem
na jiný objekt -- seznam.

&gt;<i> Následující kód v PHP docela elegantnì iterací pøiète ke 
</I>&gt;<i> ka¾dému prvku pole trojku, ani¾ by se musela vytváøet
</I>&gt;<i> kopie pole:
</I>&gt;<i> 
</I>&gt;<i> $a = array(1,2,3,4,5);
</I>&gt;<i> foreach ($a as &amp;$value)
</I>&gt;<i>    $value += 3;
</I>
V Pythonu nemohu mìnit hodnotu prvku typu int, proto¾e
jde o objekt s konstantní hodnotou (immutable). Mohu jej
pouze nahradit jiným objektem typu int, který je vypoètený
z hodnoty pùvodního a z dal¹í konstanty. V seznamu tedy
musím opìt pou¾ít obrat, kdy modifikuji samotný prvek 
seznamu. V tomto pøípadì ale dojde k modifikaci ka¾dého
prvku seznamu, tak¾e nejefektivnìj¹í a nejstruènìj¹í 
zpùsob spoèívá v konstrukci nového, upraveného seznamu:

  a = [ 1, 2, 3, 4, 5 ]
  a = [ e+3 for e in a ]
  print a

Pokud bych definoval svou vlastní tøídu objektù 
s celoèíselnou hodnotou, které by mohly být modifikovány
(mutable), bylo by mo¾né modifikovat seznam bez
vytváøení nového.

&gt;<i> V C++ také existuje iterace, dokonce s mo¾ností projet 
</I>&gt;<i> jen èást prvkù daných iterátorem:
</I>
Pro seznam lze v Pythonu pro tento úèel vyu¾ít slice,
který vystupuje v roli èásti pùvodního seznamu.

pepr
</PRE>




<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Pøedchozí pøíspìvek: <A HREF="http://www.py.cz/pipermail/python/2007-January/005332.html">[python] *^*^*^*^8=====&gt; Sexy Bikini Video Downloads	&lt;=====8*^*^*^*^*^*
</A></li>
	<LI>Následující pøíspìvek: <A HREF="http://www.py.cz/pipermail/python/2007-January/005336.html">[python] Modifikace seznamu bez kopirovnani (bylo SQLite - forma selectovaných dat)
</A></li>
         <LI> <B>Zprávy tøídìné podle:</B> 
              <a href="http://www.py.cz/pipermail/python/2007-January/date.html#5333">[ data ]</a>
              <a href="http://www.py.cz/pipermail/python/2007-January/thread.html#5333">[ vlákna ]</a>
              <a href="http://www.py.cz/pipermail/python/2007-January/subject.html#5333">[ subjektu ]</a>
              <a href="http://www.py.cz/pipermail/python/2007-January/author.html#5333">[ autora ]</a>
         </LI>
       </UL>
<hr>
<a href="http://www.py.cz/mailman/listinfo/python">Dal¹í informace o konferenci Python</a><br>
</body>
<!-- Mirrored from www.py.cz/pipermail/python/2007-January/005333.html by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 20 Mar 2016 21:23:49 GMT -->
</html>
