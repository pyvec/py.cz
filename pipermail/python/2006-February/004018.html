<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 
<!-- Mirrored from www.py.cz/pipermail/python/2006-February/004018.html by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 20 Mar 2016 21:25:49 GMT -->
<HEAD>
   <TITLE> [python] Referencia
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:python%40py.cz?Subject=%5Bpython%5D%20Referencia&In-Reply-To=E8AE1CAFC84D634A9CCC887B8AAB15EC069F74%40skil01.skil.mistni">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=iso-8859-2">
   <LINK REL="Previous"  HREF="http://www.py.cz/pipermail/python/2006-February/004017.html">
   <LINK REL="Next"  HREF="http://www.py.cz/pipermail/python/2006-February/004019.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[python] Referencia</H1>
    <B>balky</B> 
    <A HREF="mailto:python%40py.cz?Subject=%5Bpython%5D%20Referencia&In-Reply-To=E8AE1CAFC84D634A9CCC887B8AAB15EC069F74%40skil01.skil.mistni"
       TITLE="[python] Referencia">vbalko na gmail.com
       </A><BR>
    <I>Pátek Únor  3 12:42:55 CET 2006</I>
    <P><UL>
        <LI>Pøedchozí pøíspìvek: <A HREF="http://www.py.cz/pipermail/python/2006-February/004017.html">[python] Referencia
</A></li>
        <LI>Následující pøíspìvek: <A HREF="http://www.py.cz/pipermail/python/2006-February/004019.html">[python] Referencia
</A></li>
         <LI> <B>Zprávy tøídìné podle:</B> 
              <a href="http://www.py.cz/pipermail/python/2006-February/date.html#4018">[ data ]</a>
              <a href="http://www.py.cz/pipermail/python/2006-February/thread.html#4018">[ vlákna ]</a>
              <a href="http://www.py.cz/pipermail/python/2006-February/subject.html#4018">[ subjektu ]</a>
              <a href="http://www.py.cz/pipermail/python/2006-February/author.html#4018">[ autora ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Vdaka za naozaj rozsiahle a zhrnujuce vysvetlenie - mozno by sa mohlo 
hodit na wiki.

Ale problem ostal nevyrieseny. Ako viem zabezpecit aby sa B stale 
odkazovalo na objekt s menom A. Konkretne ide o to, ze v pythone je 
cyklus for neunosne pomaly. Pracujem s NumPy a potrebujem vynulovat 
vsetky prvky pola. Je OVELA rychlejsie urobit

A = numpy.zeros(rozmer)

ako

for i in xrange(rozmer):
  A[i] = 0

Popritom vsak mam &quot;odkazy&quot; na pole A.

Cize este raz chcem aby sa B odkazovalo aj na nove pole s menom A. Da sa 
to v pythone vyriesit?

balky

Petr Prikryl wrote:

&gt;<i>Zkusím to celé shrnout a vysvìtlit po svém...
</I>&gt;<i>
</I>&gt;<i>balky napsal:
</I>&gt;<i>  
</I>&gt;<i>
</I>&gt;&gt;<i>[...] pokial viem, tak ak do premennej priradim nieco,
</I>&gt;&gt;<i>nepriradil som vlastne obsah tej premennej, ale iba
</I>&gt;&gt;<i>odkaz (pointer) na ten objekt.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>    
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i>a = [1,2,3]
</I>&gt;&gt;&gt;&gt;&gt;<i>b = a
</I>&gt;&gt;&gt;&gt;&gt;<i>print b
</I>&gt;&gt;&gt;&gt;&gt;<i>          
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>[1,2,3]
</I>&gt;&gt;<i>    
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i>a = [3,3,3]
</I>&gt;&gt;&gt;&gt;&gt;<i>print a
</I>&gt;&gt;&gt;&gt;&gt;<i>          
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>[3,3,3]
</I>&gt;&gt;<i>    
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i>print b
</I>&gt;&gt;&gt;&gt;&gt;<i>          
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>[1,2,3]
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>Ako zabezpecim, aby sa pri zmene hodnoty a zmenila aj
</I>&gt;&gt;<i>hodnota v b? Nie je b iba odkaz na a? Alebo je to
</I>&gt;&gt;<i>odkaz na ine a?
</I>&gt;&gt;<i>    
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i>JP reagoval:
</I>&gt;<i>  
</I>&gt;<i>
</I>&gt;&gt;<i>zapomen na to, co znas z Pascalu, C apod. Neexistuji
</I>&gt;&gt;<i>zadne promenne 'a' a 'b'. Jsou to jenom dve jmena,
</I>&gt;&gt;<i>kterym je prirazeny objekt. Kdyz napises b = a, tak
</I>&gt;&gt;<i>obe dve jmena ukazuji na stejny objekt a jakmile
</I>&gt;&gt;<i>napises a = [3,3,3], tak uz a neodkazuje na puvodni
</I>&gt;&gt;<i>objekt, zatimco b ano.
</I>&gt;&gt;<i>    
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i>Je to tak trochu napùl. V Pascalu i v C++ (a myslím, ¾e
</I>&gt;<i>i v novìj¹í normì C) existuje nìco, èemu se øíká
</I>&gt;<i>reference. V Pascalu ji najdeme jen v podobì parametru
</I>&gt;<i>procedury/funkce pøedávaného odkazem (var). V C++ jde o
</I>&gt;<i>jeden ze základních typù a pøi pou¾ití se chová podobnì
</I>&gt;<i>jako v Pythonu. Reference se od ukazatele (pointeru)
</I>&gt;<i>li¹í tím, ¾e se pøi pou¾ití jména provádí automatická
</I>&gt;<i>dereference. Referenci se kromì toho nedá pøiøadit nìco
</I>&gt;<i>jako prázdný odkaz (nelze simulovat NULL pointer).
</I>&gt;<i>Pou¾ití jména promìnné typu reference se tedy jeví jako
</I>&gt;<i>kdybychom pøejmenovali pùvodní objekt.
</I>&gt;<i>
</I>&gt;<i>V Pascalu, C/C++ a v jiných kompilovaných jazycích ale
</I>&gt;<i>jméno pùvodního objektu mù¾e vystupovat i jinak, ne¾ v
</I>&gt;<i>Pythonu a podobných jazycích. Mù¾e být pøi pøekladu
</I>&gt;<i>nahrazeno pøímou adresou umístìní objektu. Narozdíl od
</I>&gt;<i>reference (a od ukazatele) takové jméno není spojeno s
</I>&gt;<i>pøidìlením dal¹ího pamì»ového prostoru za bìhu
</I>&gt;<i>aplikace.
</I>&gt;<i>
</I>&gt;<i>V Pythonu se v podstatì pracuje jen s referencemi.
</I>&gt;<i>Pamì»ový prostor, který za bìhu programu zabírají, se
</I>&gt;<i>nachází v systémovém slovníku v podobì zachycení vztahu
</I>&gt;<i>'jméno': 'odkaz na objekt').
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>Yeti poznamenal:
</I>&gt;<i>  
</I>&gt;<i>
</I>&gt;&gt;<i>[...] Kdyby se pøiøazení v Pythonu øíkalo pojmenování,
</I>&gt;&gt;<i>asi by se mnohé vyjasnilo.
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>    
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i>a = [1,2,3]
</I>&gt;&gt;&gt;&gt;&gt;<i>b = a
</I>&gt;&gt;&gt;&gt;&gt;<i>print b
</I>&gt;&gt;&gt;&gt;&gt;<i>          
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>[1,2,3]
</I>&gt;&gt;<i>    
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i>a = [3,3,3]
</I>&gt;&gt;&gt;&gt;&gt;<i>          
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>Tento øádek vytvoøí nový objekt [3,3,3] a pojmenuje ho
</I>&gt;&gt;<i>a. Na objekt [1,2,3] u¾ pak existuje jen odkaz jménem
</I>&gt;&gt;<i>b. [...] b není odkaz na ¾ádné a; jména a a b jsou dvì
</I>&gt;&gt;<i>jména tého¾ objektu (resp. byla, ne¾ jsi jménem a
</I>&gt;&gt;<i>pojmenoval jiný objekt).
</I>&gt;&gt;<i>
</I>&gt;&gt;<i>Nevím, èeho se pøesnì sna¾í¹ dosáhnout, ale zkus se
</I>&gt;&gt;<i>prostì podívat na pøiøazení jako na pojmenování.
</I>&gt;&gt;<i>    
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i>Python vazbì mezi jménem a objektem skuteènì øíká
</I>&gt;<i>&quot;vazba&quot; (binding). O pøiøazení objektu jménu øíká, ¾e
</I>&gt;<i>jde o vytvoøení vazby mezi jménem a objektem. V
</I>&gt;<i>kompilovaných jazycích se tomu øíká reference, ale
</I>&gt;<i>Python je speciální v tom, ¾e v¹echny reference
</I>&gt;<i>uchovává v systémových slovnících (globálním a
</I>&gt;<i>lokálních), kde jméno vystupuje jako klíè k hodnotì
</I>&gt;<i>reference.
</I>&gt;<i>
</I>&gt;<i>Pro pøíchozí ze svìta staticky kompilovaných jazykù by
</I>&gt;<i>se mnohé vyjasnilo spí¹ tím, kdyby ony jazyky bì¾nì
</I>&gt;<i>pracovaly s pojmem reference (jako C++). Yetiho dal¹í
</I>&gt;<i>poznámku bych pak mohl pro ekvivalent v kompilovaných
</I>&gt;<i>jazycích pøeformulovat takto:
</I>&gt;<i>
</I>&gt;<i>   Tento øádek vytvoøí nový objekt [3,3,3] a referenci
</I>&gt;<i>   pøiøadí do promìnné a. Tím se pùvodní reference na
</I>&gt;<i>   objekt [1,2,3] pøepí¹e novou hodnotou. Na pùvodní
</I>&gt;<i>   objekt [1,2,3] se pak dostaneme jen pøes referenci
</I>&gt;<i>   b. [...] b není reference na (refernci) a; a i b
</I>&gt;<i>   jsou zpoèátku dvì reference na tentý¾ objekt
</I>&gt;<i>   seznamu.
</I>&gt;<i>
</I>&gt;<i>
</I>&gt;<i>Jirka Vít ¹ikovnì navedl na pou¾ití zabudované funkce
</I>&gt;<i>id(), která v souèasných implementacích Pythonu vrací
</I>&gt;<i>adresu skuteèného umístìní objektu:
</I>&gt;<i>
</I>&gt;<i>  
</I>&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i>a=[1,2,3]
</I>&gt;&gt;&gt;&gt;&gt;<i>b = a
</I>&gt;&gt;&gt;&gt;&gt;<i>id(a)
</I>&gt;&gt;&gt;&gt;&gt;<i>          
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>9596640
</I>&gt;&gt;<i>    
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i>id(b)
</I>&gt;&gt;&gt;&gt;&gt;<i>          
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>9596640
</I>&gt;&gt;<i>    
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i>Snad by pro pochopení pomohlo, kdyby se pøiøazení
</I>&gt;<i>objektu [3, 3, 3] provedlo na dva kroky. Nejdøíve jej
</I>&gt;<i>pojmenujeme c (pythonovský ekvivalent pøiøazení
</I>&gt;<i>reference) a pak hodnotì b pøiøadíme hodnotu c. Mù¾eme
</I>&gt;<i>uva¾ovat, ¾e jména jsou &quot;promìnné v Pascalovském
</I>&gt;<i>smyslu&quot;, kterým pøiøazujeme hodnoty identifikací 
</I>&gt;<i>skuteèných objektù a pøi pou¾ití jmen se provádí
</I>&gt;<i>automatické zpøístupnìní tìchto objektù:
</I>&gt;<i>
</I>&gt;<i>  
</I>&gt;<i>
</I>&gt;&gt;&gt;&gt;<i>a = [1, 2, 3]
</I>&gt;&gt;&gt;&gt;<i>id(a)
</I>&gt;&gt;&gt;&gt;<i>        
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;<i>9592464
</I>&gt;<i>  
</I>&gt;<i>
</I>&gt;&gt;&gt;&gt;<i>b = a
</I>&gt;&gt;&gt;&gt;<i>id(b)
</I>&gt;&gt;&gt;&gt;<i>        
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;<i>9592464
</I>&gt;<i>  
</I>&gt;<i>
</I>&gt;&gt;&gt;&gt;<i>c = [3, 3, 3]
</I>&gt;&gt;&gt;&gt;<i>id(c)
</I>&gt;&gt;&gt;&gt;<i>        
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;<i>9591744
</I>&gt;<i>  
</I>&gt;<i>
</I>&gt;&gt;&gt;&gt;<i>b = c
</I>&gt;&gt;&gt;&gt;<i>id(b)
</I>&gt;&gt;&gt;&gt;<i>        
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;<i>9591744
</I>&gt;<i>
</I>&gt;<i>Tomá¹ Fujtalar správnì poznamenal, ¾e
</I>&gt;<i>
</I>&gt;<i>  
</I>&gt;<i>
</I>&gt;&gt;<i>Ve Vasem pripade jste ale do a priradil novy objekt,
</I>&gt;&gt;<i>o cemz zakonite objekt b &quot;nema paru&quot;.
</I>&gt;&gt;<i>    
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i>a pøidal...
</I>&gt;<i>  
</I>&gt;<i>
</I>&gt;&gt;<i>nebo muzete obsah celeho seznamu a prepsat novym:
</I>&gt;&gt;<i>    
</I>&gt;&gt;<i>
</I>&gt;&gt;&gt;&gt;&gt;<i>a[:] = [4,5,6,7]
</I>&gt;&gt;&gt;&gt;&gt;<i>print b
</I>&gt;&gt;&gt;&gt;&gt;<i>          
</I>&gt;&gt;&gt;&gt;&gt;<i>
</I>&gt;&gt;<i>[4,5,6,7]
</I>&gt;&gt;<i>    
</I>&gt;&gt;<i>
</I>&gt;<i>
</I>&gt;<i>Stejný obrat pou¾il i Jan Martínek a pí¹e:
</I>&gt;<i>  
</I>&gt;<i>
</I>&gt;&gt;<i>a nadále platí, ¾e id(a) == id(b)
</I>&gt;&gt;<i>    
</I>&gt;&gt;<i>
</I>&gt;<i> 
</I>&gt;<i>Tenhle obrat je trochu &quot;na bednu&quot;, proto¾e jeho
</I>&gt;<i>fungování je v referenèní pøíruèce (6.3 Assignment
</I>&gt;<i>statements) popsán trochu komplikovanì (ono to asi
</I>&gt;<i>jednodu¹eji popsat nejde):
</I>&gt;<i>
</I>&gt;<i>    If the target is a slicing: The primary expression
</I>&gt;<i>    in the reference is evaluated. It should yield a
</I>&gt;<i>    mutable sequence object (such as a list). The
</I>&gt;<i>    assigned object should be a sequence object of the
</I>&gt;<i>    same type. Next, the lower and upper bound
</I>&gt;<i>    expressions are evaluated, insofar they are
</I>&gt;<i>    present; defaults are zero and the sequence's
</I>&gt;<i>    length. The bounds should evaluate to (small)
</I>&gt;<i>    integers. If either bound is negative, the
</I>&gt;<i>    sequence's length is added to it. The resulting
</I>&gt;<i>    bounds are clipped to lie between zero and the
</I>&gt;<i>    sequence's length, inclusive. Finally, the sequence
</I>&gt;<i>    object is asked to replace the slice with the items
</I>&gt;<i>    of the assigned sequence. The length of the slice
</I>&gt;<i>    may be different from the length of the assigned
</I>&gt;<i>    sequence, thus changing the length of the target
</I>&gt;<i>    sequence, if the object allows it.
</I>&gt;<i>    
</I>&gt;<i>V na¹em pøíkladu jde o speciální pøípad, kdy
</I>&gt;<i>mechanismem slice vymezíme v¹echny prvky seznamu a na
</I>&gt;<i>základì vý¹e popsaného chování se nahradí v¹emi prvky z
</I>&gt;<i>pravé strany pøiøazení. Modifikuje se tedy pùvodní
</I>&gt;<i>seznam. Lépe se to mo¾ná dá pochopit na ménì speciálním
</I>&gt;<i>pøípadu, kdy slice pou¾ijeme jen na èást seznamu:
</I>&gt;<i>
</I>&gt;<i>  
</I>&gt;<i>
</I>&gt;&gt;&gt;&gt;<i>a = [1, 2, 3, 4]
</I>&gt;&gt;&gt;&gt;<i>a[1:3]
</I>&gt;&gt;&gt;&gt;<i>        
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;<i>[2, 3]
</I>&gt;<i>  
</I>&gt;<i>
</I>&gt;&gt;&gt;&gt;<i>a[1:3] = [8, 9, 10]
</I>&gt;&gt;&gt;&gt;<i>a
</I>&gt;&gt;&gt;&gt;<i>        
</I>&gt;&gt;&gt;&gt;<i>
</I>&gt;<i>[1, 8, 9, 10, 4]
</I>&gt;<i>
</I>&gt;<i>Ten popis chování by se dal pro tento konkrétní pøípad
</I>&gt;<i>pøelo¾it takto:
</I>&gt;<i>
</I>&gt;<i>   Na levé stranì pøiøazení je zápisem a[1:3] vymezen
</I>&gt;<i>   podseznam s prvky 2 a 3. Tato èást je odstranìna a
</I>&gt;<i>   nahrazena prvky seznamu z pravé strany pøiøazení. 
</I>&gt;<i>    
</I>&gt;<i>Snad je to teï (i mnì ;) trochu jasnìj¹í...
</I>&gt;<i>
</I>&gt;<i>pepr
</I>&gt;<i>_______________________________________________
</I>&gt;<i>Python mailing list
</I>&gt;<i><A HREF="http://www.py.cz/mailman/listinfo/python">Python na py.cz</A>
</I>&gt;<i><A HREF="http://www.py.cz/mailman/listinfo/python">http://www.py.cz/mailman/listinfo/python</A>
</I>&gt;<i>
</I>&gt;<i>  
</I>&gt;<i>
</I>

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Pøedchozí pøíspìvek: <A HREF="http://www.py.cz/pipermail/python/2006-February/004017.html">[python] Referencia
</A></li>
	<LI>Následující pøíspìvek: <A HREF="http://www.py.cz/pipermail/python/2006-February/004019.html">[python] Referencia
</A></li>
         <LI> <B>Zprávy tøídìné podle:</B> 
              <a href="http://www.py.cz/pipermail/python/2006-February/date.html#4018">[ data ]</a>
              <a href="http://www.py.cz/pipermail/python/2006-February/thread.html#4018">[ vlákna ]</a>
              <a href="http://www.py.cz/pipermail/python/2006-February/subject.html#4018">[ subjektu ]</a>
              <a href="http://www.py.cz/pipermail/python/2006-February/author.html#4018">[ autora ]</a>
         </LI>
       </UL>
<hr>
<a href="http://www.py.cz/mailman/listinfo/python">Dal¹í informace o konferenci Python</a><br>
</body>
<!-- Mirrored from www.py.cz/pipermail/python/2006-February/004018.html by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 20 Mar 2016 21:25:49 GMT -->
</html>
