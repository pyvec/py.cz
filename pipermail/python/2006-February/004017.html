<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 
<!-- Mirrored from www.py.cz/pipermail/python/2006-February/004017.html by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 20 Mar 2016 21:25:49 GMT -->
<HEAD>
   <TITLE> [python] Referencia
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:python%40py.cz?Subject=%5Bpython%5D%20Referencia&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=iso-8859-2">
   <LINK REL="Previous"  HREF="http://www.py.cz/pipermail/python/2006-February/004016.html">
   <LINK REL="Next"  HREF="http://www.py.cz/pipermail/python/2006-February/004018.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[python] Referencia</H1>
    <B>Petr Prikryl</B> 
    <A HREF="mailto:python%40py.cz?Subject=%5Bpython%5D%20Referencia&In-Reply-To="
       TITLE="[python] Referencia">PrikrylP na skil.cz
       </A><BR>
    <I>Pátek Únor  3 10:40:31 CET 2006</I>
    <P><UL>
        <LI>Pøedchozí pøíspìvek: <A HREF="http://www.py.cz/pipermail/python/2006-February/004016.html">[python] (no subject)
</A></li>
        <LI>Následující pøíspìvek: <A HREF="http://www.py.cz/pipermail/python/2006-February/004018.html">[python] Referencia
</A></li>
         <LI> <B>Zprávy tøídìné podle:</B> 
              <a href="http://www.py.cz/pipermail/python/2006-February/date.html#4017">[ data ]</a>
              <a href="http://www.py.cz/pipermail/python/2006-February/thread.html#4017">[ vlákna ]</a>
              <a href="http://www.py.cz/pipermail/python/2006-February/subject.html#4017">[ subjektu ]</a>
              <a href="http://www.py.cz/pipermail/python/2006-February/author.html#4017">[ autora ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Zkusím to celé shrnout a vysvìtlit po svém...

balky napsal:
&gt;<i> [...] pokial viem, tak ak do premennej priradim nieco,
</I>&gt;<i> nepriradil som vlastne obsah tej premennej, ale iba
</I>&gt;<i> odkaz (pointer) na ten objekt.
</I>&gt;<i>
</I>&gt;<i> &gt;&gt;&gt; a = [1,2,3]
</I>&gt;<i> &gt;&gt;&gt; b = a
</I>&gt;<i> &gt;&gt;&gt; print b
</I>&gt;<i> [1,2,3]
</I>&gt;<i> &gt;&gt;&gt; a = [3,3,3]
</I>&gt;<i> &gt;&gt;&gt; print a
</I>&gt;<i> [3,3,3]
</I>&gt;<i> &gt;&gt;&gt; print b
</I>&gt;<i> [1,2,3]
</I>&gt;<i>
</I>&gt;<i> Ako zabezpecim, aby sa pri zmene hodnoty a zmenila aj
</I>&gt;<i> hodnota v b? Nie je b iba odkaz na a? Alebo je to
</I>&gt;<i> odkaz na ine a?
</I>
JP reagoval:
&gt;<i> zapomen na to, co znas z Pascalu, C apod. Neexistuji
</I>&gt;<i> zadne promenne 'a' a 'b'. Jsou to jenom dve jmena,
</I>&gt;<i> kterym je prirazeny objekt. Kdyz napises b = a, tak
</I>&gt;<i> obe dve jmena ukazuji na stejny objekt a jakmile
</I>&gt;<i> napises a = [3,3,3], tak uz a neodkazuje na puvodni
</I>&gt;<i> objekt, zatimco b ano.
</I>
Je to tak trochu napùl. V Pascalu i v C++ (a myslím, ¾e
i v novìj¹í normì C) existuje nìco, èemu se øíká
reference. V Pascalu ji najdeme jen v podobì parametru
procedury/funkce pøedávaného odkazem (var). V C++ jde o
jeden ze základních typù a pøi pou¾ití se chová podobnì
jako v Pythonu. Reference se od ukazatele (pointeru)
li¹í tím, ¾e se pøi pou¾ití jména provádí automatická
dereference. Referenci se kromì toho nedá pøiøadit nìco
jako prázdný odkaz (nelze simulovat NULL pointer).
Pou¾ití jména promìnné typu reference se tedy jeví jako
kdybychom pøejmenovali pùvodní objekt.

V Pascalu, C/C++ a v jiných kompilovaných jazycích ale
jméno pùvodního objektu mù¾e vystupovat i jinak, ne¾ v
Pythonu a podobných jazycích. Mù¾e být pøi pøekladu
nahrazeno pøímou adresou umístìní objektu. Narozdíl od
reference (a od ukazatele) takové jméno není spojeno s
pøidìlením dal¹ího pamì»ového prostoru za bìhu
aplikace.

V Pythonu se v podstatì pracuje jen s referencemi.
Pamì»ový prostor, který za bìhu programu zabírají, se
nachází v systémovém slovníku v podobì zachycení vztahu
'jméno': 'odkaz na objekt').


Yeti poznamenal:
&gt;<i> [...] Kdyby se pøiøazení v Pythonu øíkalo pojmenování,
</I>&gt;<i> asi by se mnohé vyjasnilo.
</I>&gt;<i>
</I>&gt;<i> &gt;&gt;&gt; a = [1,2,3]
</I>&gt;<i> &gt;&gt;&gt; b = a
</I>&gt;<i> &gt;&gt;&gt; print b
</I>&gt;<i> [1,2,3]
</I>&gt;<i> &gt;&gt;&gt; a = [3,3,3]
</I>&gt;<i>
</I>&gt;<i> Tento øádek vytvoøí nový objekt [3,3,3] a pojmenuje ho
</I>&gt;<i> a. Na objekt [1,2,3] u¾ pak existuje jen odkaz jménem
</I>&gt;<i> b. [...] b není odkaz na ¾ádné a; jména a a b jsou dvì
</I>&gt;<i> jména tého¾ objektu (resp. byla, ne¾ jsi jménem a
</I>&gt;<i> pojmenoval jiný objekt).
</I>&gt;<i>
</I>&gt;<i> Nevím, èeho se pøesnì sna¾í¹ dosáhnout, ale zkus se
</I>&gt;<i> prostì podívat na pøiøazení jako na pojmenování.
</I>
Python vazbì mezi jménem a objektem skuteènì øíká
&quot;vazba&quot; (binding). O pøiøazení objektu jménu øíká, ¾e
jde o vytvoøení vazby mezi jménem a objektem. V
kompilovaných jazycích se tomu øíká reference, ale
Python je speciální v tom, ¾e v¹echny reference
uchovává v systémových slovnících (globálním a
lokálních), kde jméno vystupuje jako klíè k hodnotì
reference.

Pro pøíchozí ze svìta staticky kompilovaných jazykù by
se mnohé vyjasnilo spí¹ tím, kdyby ony jazyky bì¾nì
pracovaly s pojmem reference (jako C++). Yetiho dal¹í
poznámku bych pak mohl pro ekvivalent v kompilovaných
jazycích pøeformulovat takto:

   Tento øádek vytvoøí nový objekt [3,3,3] a referenci
   pøiøadí do promìnné a. Tím se pùvodní reference na
   objekt [1,2,3] pøepí¹e novou hodnotou. Na pùvodní
   objekt [1,2,3] se pak dostaneme jen pøes referenci
   b. [...] b není reference na (refernci) a; a i b
   jsou zpoèátku dvì reference na tentý¾ objekt
   seznamu.


Jirka Vít ¹ikovnì navedl na pou¾ití zabudované funkce
id(), která v souèasných implementacích Pythonu vrací
adresu skuteèného umístìní objektu:

&gt;<i> &gt;&gt;&gt; a=[1,2,3]
</I>&gt;<i> &gt;&gt;&gt; b = a
</I>&gt;<i> &gt;&gt;&gt; id(a)
</I>&gt;<i> 9596640
</I>&gt;<i> &gt;&gt;&gt; id(b)
</I>&gt;<i> 9596640
</I>
Snad by pro pochopení pomohlo, kdyby se pøiøazení
objektu [3, 3, 3] provedlo na dva kroky. Nejdøíve jej
pojmenujeme c (pythonovský ekvivalent pøiøazení
reference) a pak hodnotì b pøiøadíme hodnotu c. Mù¾eme
uva¾ovat, ¾e jména jsou &quot;promìnné v Pascalovském
smyslu&quot;, kterým pøiøazujeme hodnoty identifikací 
skuteèných objektù a pøi pou¾ití jmen se provádí
automatické zpøístupnìní tìchto objektù:

&gt;&gt;&gt;<i> a = [1, 2, 3]
</I>&gt;&gt;&gt;<i> id(a)
</I>9592464
&gt;&gt;&gt;<i> b = a
</I>&gt;&gt;&gt;<i> id(b)
</I>9592464
&gt;&gt;&gt;<i> c = [3, 3, 3]
</I>&gt;&gt;&gt;<i> id(c)
</I>9591744
&gt;&gt;&gt;<i> b = c
</I>&gt;&gt;&gt;<i> id(b)
</I>9591744

Tomá¹ Fujtalar správnì poznamenal, ¾e

&gt;<i> Ve Vasem pripade jste ale do a priradil novy objekt,
</I>&gt;<i> o cemz zakonite objekt b &quot;nema paru&quot;.
</I>
a pøidal...
&gt;<i> nebo muzete obsah celeho seznamu a prepsat novym:
</I>&gt;<i> &gt;&gt;&gt; a[:] = [4,5,6,7]
</I>&gt;<i> &gt;&gt;&gt;print b
</I>&gt;<i> [4,5,6,7]
</I>
Stejný obrat pou¾il i Jan Martínek a pí¹e:
&gt;<i> a nadále platí, ¾e id(a) == id(b)
</I> 
Tenhle obrat je trochu &quot;na bednu&quot;, proto¾e jeho
fungování je v referenèní pøíruèce (6.3 Assignment
statements) popsán trochu komplikovanì (ono to asi
jednodu¹eji popsat nejde):

    If the target is a slicing: The primary expression
    in the reference is evaluated. It should yield a
    mutable sequence object (such as a list). The
    assigned object should be a sequence object of the
    same type. Next, the lower and upper bound
    expressions are evaluated, insofar they are
    present; defaults are zero and the sequence's
    length. The bounds should evaluate to (small)
    integers. If either bound is negative, the
    sequence's length is added to it. The resulting
    bounds are clipped to lie between zero and the
    sequence's length, inclusive. Finally, the sequence
    object is asked to replace the slice with the items
    of the assigned sequence. The length of the slice
    may be different from the length of the assigned
    sequence, thus changing the length of the target
    sequence, if the object allows it.
    
V na¹em pøíkladu jde o speciální pøípad, kdy
mechanismem slice vymezíme v¹echny prvky seznamu a na
základì vý¹e popsaného chování se nahradí v¹emi prvky z
pravé strany pøiøazení. Modifikuje se tedy pùvodní
seznam. Lépe se to mo¾ná dá pochopit na ménì speciálním
pøípadu, kdy slice pou¾ijeme jen na èást seznamu:

&gt;&gt;&gt;<i> a = [1, 2, 3, 4]
</I>&gt;&gt;&gt;<i> a[1:3]
</I>[2, 3]
&gt;&gt;&gt;<i> a[1:3] = [8, 9, 10]
</I>&gt;&gt;&gt;<i> a
</I>[1, 8, 9, 10, 4]

Ten popis chování by se dal pro tento konkrétní pøípad
pøelo¾it takto:

   Na levé stranì pøiøazení je zápisem a[1:3] vymezen
   podseznam s prvky 2 a 3. Tato èást je odstranìna a
   nahrazena prvky seznamu z pravé strany pøiøazení. 
    
Snad je to teï (i mnì ;) trochu jasnìj¹í...

pepr

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Pøedchozí pøíspìvek: <A HREF="http://www.py.cz/pipermail/python/2006-February/004016.html">[python] (no subject)
</A></li>
	<LI>Následující pøíspìvek: <A HREF="http://www.py.cz/pipermail/python/2006-February/004018.html">[python] Referencia
</A></li>
         <LI> <B>Zprávy tøídìné podle:</B> 
              <a href="http://www.py.cz/pipermail/python/2006-February/date.html#4017">[ data ]</a>
              <a href="http://www.py.cz/pipermail/python/2006-February/thread.html#4017">[ vlákna ]</a>
              <a href="http://www.py.cz/pipermail/python/2006-February/subject.html#4017">[ subjektu ]</a>
              <a href="http://www.py.cz/pipermail/python/2006-February/author.html#4017">[ autora ]</a>
         </LI>
       </UL>
<hr>
<a href="http://www.py.cz/mailman/listinfo/python">Dal¹í informace o konferenci Python</a><br>
</body>
<!-- Mirrored from www.py.cz/pipermail/python/2006-February/004017.html by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 20 Mar 2016 21:25:49 GMT -->
</html>
