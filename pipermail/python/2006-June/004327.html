<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 
<!-- Mirrored from www.py.cz/pipermail/python/2006-June/004327.html by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 20 Mar 2016 21:25:29 GMT -->
<HEAD>
   <TITLE> [python] ukonèení interpretu, znièení objektu
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:python%40py.cz?Subject=%5Bpython%5D%0A%09%3D%3Fiso-8859-2%3Fq%3Fukon%3DE8en%3DED_interpretu%3D2C_zni%3DE8en%3DED_ob%3F%3D%0A%09%3D%3Fiso-8859-2%3Fq%3Fjektu%3F%3D&In-Reply-To=">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=iso-8859-2">
   <LINK REL="Previous"  HREF="http://www.py.cz/pipermail/python/2006-June/004337.html">
   <LINK REL="Next"  HREF="http://www.py.cz/pipermail/python/2006-June/004328.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[python] ukonèení interpretu, znièení objektu</H1>
    <B>Petr Prikryl</B> 
    <A HREF="mailto:python%40py.cz?Subject=%5Bpython%5D%0A%09%3D%3Fiso-8859-2%3Fq%3Fukon%3DE8en%3DED_interpretu%3D2C_zni%3DE8en%3DED_ob%3F%3D%0A%09%3D%3Fiso-8859-2%3Fq%3Fjektu%3F%3D&In-Reply-To="
       TITLE="[python] ukonèení interpretu, znièení objektu">PrikrylP na skil.cz
       </A><BR>
    <I>Úterý Èerven  6 11:04:45 CEST 2006</I>
    <P><UL>
        <LI>Pøedchozí pøíspìvek: <A HREF="http://www.py.cz/pipermail/python/2006-June/004337.html">[python] font v TK menu
</A></li>
        <LI>Následující pøíspìvek: <A HREF="http://www.py.cz/pipermail/python/2006-June/004328.html">[python] ukonèení interpretu, znièení objektu
</A></li>
         <LI> <B>Zprávy tøídìné podle:</B> 
              <a href="http://www.py.cz/pipermail/python/2006-June/date.html#4327">[ data ]</a>
              <a href="http://www.py.cz/pipermail/python/2006-June/thread.html#4327">[ vlákna ]</a>
              <a href="http://www.py.cz/pipermail/python/2006-June/subject.html#4327">[ subjektu ]</a>
              <a href="http://www.py.cz/pipermail/python/2006-June/author.html#4327">[ autora ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Jan Martínek napsal...
&gt;<i> class M:
</I>&gt;<i>    b = 0
</I>&gt;<i>    def __del__(self):
</I>&gt;<i>      M.b
</I>&gt;<i>
</I>&gt;<i> a1 = M()
</I>&gt;<i>
</I>&gt;<i> vyhodí výjimku
</I>&gt;<i> Exception exceptions.AttributeError: &quot;'NoneType' object 
</I>&gt;<i> has no attribute 'b'&quot; in &lt;bound method M.__del__ of 
</I>&gt;<i> &lt;__main__.M instance at 0x2aaaaab50a28
</I>&gt;<i> ignored   
</I>
a pozdìji...
&gt;<i> Dìje se tak na Linuxu ve verzích Pythonu 2.4.2 i 2.4.3.
</I>
[Funguje to, pokud se místo &quot;a1&quot; uvede &quot;a&quot;.] Potvrzuji
stejné chování pro Python 2.4.3 pod Windows.

Radek Kaòovský reagoval...
&gt;<i> Ja myslim, ze tohle chovani je v poradku. Metoda __del__ se
</I>&gt;<i> muze spolehnout v podstate jenom na jmeno `self'. Globalni
</I>&gt;<i> objekty uz mohou byt odalokovane.
</I>
Jan Janech...
&gt;<i> Ja viem, ze globalne objekty uz mozu byt zrusene garbage
</I>&gt;<i> collectorom, ale ja som sa prave snazil ukazat ze u tej
</I>&gt;<i> classy to tak nieje. Prave to sa mi zda zvlastne, ze
</I>&gt;<i> premenna ma nastavenu hodnotu None, ale objekt triedy este
</I>&gt;<i> existuje v pamati a moze byt referencovany... okrem toho,
</I>&gt;<i> pri tom ako je python spraveny si neviem predstavit ako by
</I>&gt;<i> niekto chcel zrusit najskor instanciu class objektu a az
</I>&gt;<i> potom instanciu danej triedy...
</I>
Radek Kaòovský reagoval...
&gt;<i> On tu tridu nezrusi driv nez instanci, pouze neni trida
</I>&gt;<i> dostupna pres nazev tridy z namespacu modulu. Pres
</I>&gt;<i> `self.__class__' se da trida ziskat. Nekde se proste s
</I>&gt;<i> rusenim referenci musi zacit.
</I>
Svatá pravda. Dokumentace pro __del__ øíká:

   Warning: [...] Also, when __del__() is invoked in
   response to a module being deleted (e.g., when execution
   of the program is done), other globals referenced by the
   __del__() method may already have been deleted. For this
   reason, __del__() methods should do the absolute minimum
   needed to maintain external invariants. [...]
   
   Èesky: Pokud se __del__() volá v rámci ru¹ení modulu
   (napø. pøi ukonèení programu), mohou ji¾ být ostatní
   globální jména, na které se metoda __del__() odkazuje,
   zru¹eny. Z tohoto dùvodu by toho mìla metoda __del__()
   z pohledu udr¾ování externích invariantù dìlat co nejménì.

A co se vlatnì dìje, kdy¾ to s &quot;a&quot; nefunguje a s &quot;a1&quot;
funguje&quot;? Kdy¾ se ru¹í jména z globálního slovníku,
vyvolávají se akce související s ru¹ením pøíslu¹ných
objektù. Objekt se nezru¹í, pokud na nìj existuje nìjaká
reference, ale v tomto pøípadì se neuva¾ují reference z
onoho ru¹eného globálního slovníku (to by se nedalo zru¹it
nic). Globální slovník se prochází pravdìpodobnì v poøadí
urèeném hash hodnotou, která souvisí s jménem. Jen¾e u hash
hodnoty nelze øíci (bez znalosti implementace), zde je pro
&quot;a&quot; men¹í nebo vìt¹í, ne¾ pro &quot;M&quot;. Pøi _vhodném_ jménì tøídy
a nebo odkazu na instanci tøídy lze dosáhnout rùzného
poøadí. Kdy¾ se ru¹í nejdøíve &quot;a&quot;, pak v okam¾iku volání
a.__del__() jméno &quot;M&quot; je¹tì existuje a ve slovníku se najde.
Pokud je to naopak (tj. nejdøíve se zru¹í &quot;M&quot; -- pøi nìm se
__del__() nevolá), pak se pøi ru¹ení &quot;a&quot; volá a.__del__() a
jméno &quot;M&quot; se nenalezne. Lépe øeèeno, polo¾ka slovníku &quot;M&quot;
není zcela zru¹ena, jméno stále existuje, ale kvùli
odstranìní co nejvíce vzájemných referencí byla jménu &quot;M&quot;
pøidìlena reference None (proto NoneType).
 
Dokumentace na stejném místì pokraèuje...

   Starting with version 1.5, Python guarantees that globals
   whose name begins with a single underscore are deleted
   from their module before other globals are deleted; if no
   other references to such globals exist, this may help in
   assuring that imported modules are still available at the
   time when the __del__() method is called.
   
   Èesky: Od verze 1.5 Python zaruèuje, ¾e globální [vìci],
   jejich¾ jméno zaèítá jedním podtr¾ítkem, jsou v jejich
   vlastním modulu zru¹eny døíve, ne¾ ostatní globální
   [vìci] [...atd]
   
Tak¾e stejné chybné chování v pùvodnì fungujícím pøíkladu
lze navodit tak, ¾e tøídì pøidáme k jménu podtr¾ítko. Tak¾e
tohle funguje...

    class M:
       b = 0
       def __del__(self):
           M.b = 1
    a = M()

a tohle ne:    

    class _M:
       b = 0
       def __del__(self):
           _M.b = 1
    a = _M()

A kde se stala chyba? Metoda __del__() se nesna¾í pøímo
odkazovat na vlastní tøídu, ale hledá jméno v globálním
slovníku, který se právì vyprazdòuje (jménu &quot;M&quot; byla mezi
tím pøidìlena reference None). Ale dìlá tak jen proto, aby
zjistila odkaz na vlastní tøídu. Jen¾e odkaz na vlastní
tøídu nemusíme zji¹»ovat pøes globální slovník, proto¾e
ka¾dá instance jej zná. Podle mì tedy nejèist¹í øe¹ení
naznaèil u¾ Radek Kaòkovský (schválnì tam dávám &quot;a1&quot;, které
nefungovalo):

    class M:
       b = 0
       def __del__(self):
           self.__class__.b = 1
    a1 = M()

pepr    
</PRE>







<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Pøedchozí pøíspìvek: <A HREF="http://www.py.cz/pipermail/python/2006-June/004337.html">[python] font v TK menu
</A></li>
	<LI>Následující pøíspìvek: <A HREF="http://www.py.cz/pipermail/python/2006-June/004328.html">[python] ukonèení interpretu, znièení objektu
</A></li>
         <LI> <B>Zprávy tøídìné podle:</B> 
              <a href="http://www.py.cz/pipermail/python/2006-June/date.html#4327">[ data ]</a>
              <a href="http://www.py.cz/pipermail/python/2006-June/thread.html#4327">[ vlákna ]</a>
              <a href="http://www.py.cz/pipermail/python/2006-June/subject.html#4327">[ subjektu ]</a>
              <a href="http://www.py.cz/pipermail/python/2006-June/author.html#4327">[ autora ]</a>
         </LI>
       </UL>
<hr>
<a href="http://www.py.cz/mailman/listinfo/python">Dal¹í informace o konferenci Python</a><br>
</body>
<!-- Mirrored from www.py.cz/pipermail/python/2006-June/004327.html by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 20 Mar 2016 21:25:29 GMT -->
</html>
