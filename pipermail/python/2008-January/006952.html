<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 
<!-- Mirrored from www.py.cz/pipermail/python/2008-January/006952.html by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 20 Mar 2016 21:21:46 GMT -->
<HEAD>
   <TITLE> [python] problem
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:python%40py.cz?Subject=%5Bpython%5D%20problem&In-Reply-To=020a01c84ee6%2472fbd350%240a0d16ac%40jvrana">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=iso-8859-2">
   <LINK REL="Previous"  HREF="http://www.py.cz/pipermail/python/2008-January/006951.html">
   <LINK REL="Next"  HREF="http://www.py.cz/pipermail/python/2008-January/006953.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[python] problem</H1>
    <B>superman</B> 
    <A HREF="mailto:python%40py.cz?Subject=%5Bpython%5D%20problem&In-Reply-To=020a01c84ee6%2472fbd350%240a0d16ac%40jvrana"
       TITLE="[python] problem">feed na centrum.cz
       </A><BR>
    <I>Pátek Leden  4 17:00:59 CET 2008</I>
    <P><UL>
        <LI>Pøedchozí pøíspìvek: <A HREF="http://www.py.cz/pipermail/python/2008-January/006951.html">[python] problem
</A></li>
        <LI>Následující pøíspìvek: <A HREF="http://www.py.cz/pipermail/python/2008-January/006953.html">[python] Optimalizátor - doplnìní
</A></li>
         <LI> <B>Zprávy tøídìné podle:</B> 
              <a href="http://www.py.cz/pipermail/python/2008-January/date.html#6952">[ data ]</a>
              <a href="http://www.py.cz/pipermail/python/2008-January/thread.html#6952">[ vlákna ]</a>
              <a href="http://www.py.cz/pipermail/python/2008-January/subject.html#6952">[ subjektu ]</a>
              <a href="http://www.py.cz/pipermail/python/2008-January/author.html#6952">[ autora ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>&gt;<i> No pravda pokud je vynalozene usily nekonecne tak jiste neni problem ani 
</I>&gt;<i> extremni varianta ze podle projevu to napisete znovu.
</I>
No v pøípadì Pythoního byte kódu je potøeba celkem malé úsilí. Vìøte mi.

&gt;<i> Nikdy jsem to nezkoumal ale predpokladam ze compilator se hlavne snazi 
</I>&gt;<i> optimalizovat a urychlit zpracovani. Nejedna se tedy jen o nejake 
</I>&gt;<i> zakodovani do necitelne formy.
</I>
Zase dal¹í utopista. Zase dal¹í, co nohama není na zemi a pluje kdesi ve 
virtuální realitì.

Tak znovu u¾ po tisícté: Optimalizace stojí èas, èas a zase èas! Kdy¾ 
kompilátor pøekládá tøeba moje C++ zdrojáky, tak vìt¹í programy na velmi 
výkonném poèítaèi do release (tedy optimalizované) verze je schopen 
pøekládat mnoho minut a¾ hodin. Selským rozumem pøijdete na to, ¾e 
nastartujete Python a program jede - tedy ÈASU NA OPTIMALIZACI PYTHON 
MOC NEMÁ. Je to odvìká bolístka v¹ech interpretovaných programù, které 
cokoli optimalizují/kompilují za bìhu programu - chybí jim ÈAS na 
poøádnou optimalizaci, tak¾e se optimalizuje naprosto minimálnì, obèas 
velmi èasto vùbec.

Druhá vìc je, ¾e dobrá optimalizace je VELMI SLO®ITÝ SW PROBLÉM. Pro 
pøedstavu ve stávajících kompilátorech je 99% v¹eho kódu optimalizaèní 
jednotka. Je to to absolutnì nejdùle¾itìj¹í, nejslo¾itìj¹í, 
nejnamakanìj¹í a to nejvíce machrovina, co mù¾ete v sw napsat. Je 
tisíckrát jednodu¹¹í napsat jádro skvìlého operaèního systém, nebo tøeba 
celý dokonalý interpretr Pythonu, ale je velmi a¾ nechutnì slo¾ité 
napsat dobrý neøku-li vynikající optimalizátor - je to IMHO ta nejvy¹¹í 
meta jak dokázat svoje kvality jako programátor.

Tøetí a velmi podstatná vìc je, ¾e optimalizátory pøímo magicky 
pøitahují ty nejhor¹í mo¾né druhy chyb. Samotný optimalizátor díky své 
slo¾itosti a implementaci mnoha velmi sofistikovaných trikù je vùbec 
problém odladit, ale musíte si uvìdomit, ¾e jakákoli chyba, která 
zùstane v optimalizátoru vlastnì potencionálnì zpùsobuje chybný bìh a 
chybnou interpretaci v¹ech programù v tomto jazyce/prostøedí spu¹tìném. 
Proto se na spolehlivost optimalizátorù kladou obrovské názroky a 
vìt¹inou se radìji udìlá hor¹í optimalizátor, ne¾ aby byl nespolehlivý. 
Chronicky nespolehlivé jsou tøeba kompilátory firmy Borland, kde v 
pøípadì chyby není obèas od vìci se podívat do strojáku, zda kompilátor 
skueènì pøelo¾il co je ve zdrojovém kódu.

Tedy ètvrtá vìc - Python s dobrým optimalizátorem by mìl asi tak stokrát 
a¾ tisíckrát více øádek zdrojového kódu, ne¾ je nyní a jeho vývoj by 
stál pøíslu¹ný násobek èasu.

Vzhledem k tomu, ¾e autor Pythonu stále øe¹í gramatické stromy a vnitøní 
reprezentaci syntaktického stromu - alespoò tak to pamatuji, kdy¾ jsem 
dìní v Pythonu sledoval - a vzhledem k tomu, ¾e zdrojové kódu 
interpretetu Pythonu jsem studoval - mohu prohlásit, ¾e optimalizace v 
Pythonu se blí¾í nula, není prakticky ¾ádná.

&gt;<i> Ale z kodu se odstrani vsechny nepotrebnosti jako jsou treba komentare, 
</I>&gt;<i> nazvy promenych, bloky ktere nemuzou nikdy nastat (if(0==1):).
</I>
Pokud alespoò pár hodin jste programoval v Pythonu a napsal v nìm 
minimálnì &quot;Hello world program&quot;, tak jistì víte, ¾e názvy promìnných 
jsou ve skuteènosti jen jména v prostoru jmen, a ¾e vzhledem k povaze 
Pythonu dost dobøe nelze odstraòovat jména promìnných a je dost ztí¾ené 
i jejich fal¹ování. Proto¾e tì¾ko vysvìtlíte nadøazenému modulu, ¾e se k 
promìnné pod pravým názvem jaksi nemohou dostat.

Jinak odstraòování blokù, které nikdy nemohou nastat je mo¾né, ale 
pøedpokládá to dost znaènou inteligenci optimalizátoru - a pak platí ty 
vìci co jsem psal o optimalizaci viz vý¹e.

&gt;<i> Optimalizator by mohl ke stejnymu kusu bytekodu dojit vice cestama. 
</I>&gt;<i> Napriklad ruzne moznosti pro vytvoreni cyklu ktere ve vysledku mohou byt 
</I>&gt;<i> zkompilovany stejne.
</I>
Ano, to teoreticky mohl. Ale prosím, projdìte si Python, jeho mo¾nosti a 
bude Vám to jasné. Python moc záludností pro byte kód neskrývá, 
prakticky ¾ádnou.

&gt;<i> Takze to co dostanete dekompilaci se vasemu puvodnimu zdrojaku podoba, 
</I>&gt;<i> stejne se to chova ale vas puvodni zdrojak to neni.
</I>
Ne, pùvodní zdroják to není, ale bude velice velice vìrnì odrá¾et 
pùvodní zdroják. Zvlá¹tì v Pythonu dokonce i do takových detailù jako je 
tøeba dodr¾ení øádek zdrojového kódu (proto¾e nucené odsazení a proto¾e 
i v byte kódu jsou informace o øádkách zdrojového kódu a dal¹í vìci). V 
podstatì po dekompilaci byte kódu získám velmi dobrý zdrojový kód, který 
  mohu dále pou¾ít pro dal¹í vývoj programu a který se bude maximálnì 
podobat originálnímu zdrojáku. Na 99,9% bude stejný s mírnými 
odchylkami. Názvy promìnných, objektù, funkcí, stejné konstrukce, 
naprosto stejné algoritmy jako originální zdroják., Odchylky budou 
naprosto nepodstatné.

&gt;<i> Nebo opravdu compilator jen zakoduje zdrojak do strojove lepe citelneho 
</I>&gt;<i> tvaru nad kterym uz nemusi provadet syntaktickou analyzu?
</I>
V podstatì jste velmi blízko skuteènosti :-)

Miloslav Ponkrác


</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Pøedchozí pøíspìvek: <A HREF="http://www.py.cz/pipermail/python/2008-January/006951.html">[python] problem
</A></li>
	<LI>Následující pøíspìvek: <A HREF="http://www.py.cz/pipermail/python/2008-January/006953.html">[python] Optimalizátor - doplnìní
</A></li>
         <LI> <B>Zprávy tøídìné podle:</B> 
              <a href="http://www.py.cz/pipermail/python/2008-January/date.html#6952">[ data ]</a>
              <a href="http://www.py.cz/pipermail/python/2008-January/thread.html#6952">[ vlákna ]</a>
              <a href="http://www.py.cz/pipermail/python/2008-January/subject.html#6952">[ subjektu ]</a>
              <a href="http://www.py.cz/pipermail/python/2008-January/author.html#6952">[ autora ]</a>
         </LI>
       </UL>
<hr>
<a href="http://www.py.cz/mailman/listinfo/python">Dal¹í informace o konferenci Python</a><br>
</body>
<!-- Mirrored from www.py.cz/pipermail/python/2008-January/006952.html by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 20 Mar 2016 21:21:46 GMT -->
</html>
