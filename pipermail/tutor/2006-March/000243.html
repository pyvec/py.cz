<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
 
<!-- Mirrored from www.py.cz/pipermail/tutor/2006-March/000243.html by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 20 Mar 2016 21:36:10 GMT -->
<HEAD>
   <TITLE> [Tutor PyCZ] Roboti Pøicházejí - Final(?)
   </TITLE>
   <LINK REL="Index" HREF="index.html" >
   <LINK REL="made" HREF="mailto:tutor%40py.cz?Subject=%5BTutor%20PyCZ%5D%0A%20%3D%3Fiso-8859-2%3Fq%3FRoboti_P%3DF8ich%3DE1zej%3DED_-_Final%3D28%3D3F%3F%3D%0A%20%3D%3Fiso-8859-2%3Fq%3F%3D29%3F%3D&In-Reply-To=ca0bf9ff0603230949seb78cdcg%40mail.gmail.com">
   <META NAME="robots" CONTENT="index,nofollow">
   <META http-equiv="Content-Type" content="text/html; charset=iso-8859-2">
   <LINK REL="Previous"  HREF="http://www.py.cz/pipermail/tutor/2006-March/000242.html">
   <LINK REL="Next"  HREF="http://www.py.cz/pipermail/tutor/2006-March/000244.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Tutor PyCZ] Roboti Pøicházejí - Final(?)</H1>
    <B>geon</B> 
    <A HREF="mailto:tutor%40py.cz?Subject=%5BTutor%20PyCZ%5D%0A%20%3D%3Fiso-8859-2%3Fq%3FRoboti_P%3DF8ich%3DE1zej%3DED_-_Final%3D28%3D3F%3F%3D%0A%20%3D%3Fiso-8859-2%3Fq%3F%3D29%3F%3D&In-Reply-To=ca0bf9ff0603230949seb78cdcg%40mail.gmail.com"
       TITLE="[Tutor PyCZ] Roboti Pøicházejí - Final(?)">geon na post.cz
       </A><BR>
    <I>Pátek Bøezen 24 18:35:45 CET 2006</I>
    <P><UL>
        <LI>Pøedchozí pøíspìvek: <A HREF="http://www.py.cz/pipermail/tutor/2006-March/000242.html">[Tutor PyCZ] Roboti Pøicházejí - Final(?)
</A></li>
        <LI>Následující pøíspìvek: <A HREF="http://www.py.cz/pipermail/tutor/2006-March/000244.html">[Tutor PyCZ] Roboti Pøicházejí - Final(?)
</A></li>
         <LI> <B>Zprávy tøídìné podle:</B> 
              <a href="http://www.py.cz/pipermail/tutor/2006-March/date.html#243">[ data ]</a>
              <a href="http://www.py.cz/pipermail/tutor/2006-March/thread.html#243">[ vlákna ]</a>
              <a href="http://www.py.cz/pipermail/tutor/2006-March/subject.html#243">[ subjektu ]</a>
              <a href="http://www.py.cz/pipermail/tutor/2006-March/author.html#243">[ autora ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Tomá¹ Bìlono¾ník napsal(a):
&gt;<i> Ahoj,
</I>&gt;<i> tak jsem se rozhodl ¾e vám sem postnu link na dodìlanou hru Roboti
</I>&gt;<i> Pøicházejí. 
</I> &gt; # Funkce na výrobu robotova tìla.
 &gt; def vyrobRobota(hrac, seznam):
    &gt; p = 0
    &gt; for i in range(20):
        &gt; robot = Robot()
        &gt; robot.x=random.randint(1, 63)                  
        &gt; robot.y=random.randint(1, 47)

Tyto (horní) dva øádky, se ti v programu minimálnì dvakrát --&gt; je 
vhodnìj¹í z toho udìlat funkci


        &gt; robot.xsrot = 0
        &gt; robot.ysrot = 0

TO jsem moc nepochopil -- proc zjistujes a nastavujes x,y souradnice 
srotu? Vzdyt muzes pouzit poslední souradnice pred smrtí... (pak se ji¾ 
nehýbe)

        &gt; robot.srot = 0
        &gt; # Èást funkce zaji¹»ující, ¾e hráè a robot nezaènou na sobì.
        &gt; while robot.x == hrac.x and robot.y == hrac.y:
            &gt; robot.x=random.randint(1, 63)
            &gt; robot.y=random.randint(1, 47)
        &gt; # Èást, která by mìla zaji¹»ovat, ¾e roboti nezaènou na sobì.
        &gt; # Výsledek asi hodinového uva¾ování. Základ ostatních funkcí 
kontroly kolizí.
        &gt; for n in range(p):
            &gt; if robot.x == seznam[n].x and robot.y == seznam[n].y:
                &gt; robot.x = random.randint(1, 63)
                &gt; robot.y = random.randint(1, 47)

Jinými slovy - horní øádky kontrolují, jestli se robot nesrazil s jinými 
roboty.. ale to by mìlo být velmi stejné jako pøi kontrole obyèejných 
srá¾ek ---&gt; funkce

        &gt; p = p+1
        &gt; seznam.append(robot)
 &gt;           
        &gt; robot.telo = 
box(robot.x*10-5,robot.y*10-5,robot.x*10+5,robot.y*10+5, filled=1, 
colour=Colour.dark_blue)    # Popis tìla robota
    &gt; return robot, seznam
 &gt;    
 &gt; # Mìní hráèovy koordináty dle stiskù kláves, ale nepohybuje jím.
 &gt; # Je tu i mo¾nost 5x se nechat pøesunout na náhodné místo plochy - 
&quot;teleportace&quot;.
 &gt; def zmena_XY_hr(hrac, teleportace):
        &gt; if &quot;2&quot; in klavesy:                     
            &gt; hrac.y = hrac.y - 1   
        &gt; elif &quot;8&quot; in klavesy:
            &gt; hrac.y = hrac.y + 1
        &gt; elif &quot;4&quot; in klavesy:
            &gt; hrac.x = hrac.x - 1
        &gt; elif &quot;6&quot; in klavesy:
            &gt; hrac.x = hrac.x + 1
        &gt; elif &quot;1&quot; in klavesy:
            &gt; hrac.x = hrac.x - 1
            &gt; hrac.y = hrac.y - 1
        &gt; elif &quot;3&quot; in klavesy:
            &gt; hrac.x = hrac.x + 1
            &gt; hrac.y = hrac.y - 1
        &gt; elif &quot;7&quot; in klavesy:
            &gt; hrac.x = hrac.x - 1
            &gt; hrac.y = hrac.y + 1
        &gt; elif &quot;9&quot; in klavesy:
            &gt; hrac.x = hrac.x + 1
            &gt; hrac.y = hrac.y + 1
        &gt; elif teleportace &lt; 5:


moooc velký krok --- já jsem experimentálnì urèil krok=0.02 a pro roboty 
tøetinový (aby se v¾dy vyhrálo ;-) )
Znám jednu pouèku, která øíká, ¾e mnoho if/elif se dá øe¹it elegantnìji 
nìjakou datovou strukturou. Ale v tomto pøípadì mì nic nenapadá. Vìdìl 
by nìkdo?

            &gt; if &quot;t&quot; in klavesy:
                &gt; hrac.x = random.randint(1, 63)
                &gt; hrac.y = random.randint(1, 47)
                &gt; teleportace = teleportace + 1
                &gt; sleep(0.1)
        &gt; return hrac, teleportace
 &gt;
 &gt; # Funkce, která posouvá robotem do osmi smìrù tak, aby pronásledoval 
hráèe.
 &gt; # Dále kontroluje kolize robot-robot a vytváøí ¹rot.
 &gt; def posunRobota(robot):
    &gt; p = 0
    &gt; for robot in seznam:
        &gt; if robot.srot == 0:
            &gt; if robot.x &lt; hrac.x:
                &gt; robot.x = float(robot.x) + 0.5
            &gt; elif robot.x &gt; hrac.x:
                &gt; robot.x = float(robot.x) - 0.5
            &gt; if robot.y &lt; hrac.y:
                &gt; robot.y = float(robot.y) + 0.5
            &gt; elif robot.y &gt; hrac.y:
                &gt; robot.y = float(robot.y) - 0.5
            &gt; move_to(robot.telo, float(robot.x)*10, float(robot.y)*10)
            &gt; for n in range(p):
                &gt; if robot.x == seznam[n].x and robot.y == seznam[n].y:
                    &gt; remove_from_screen(robot.telo)
                    &gt; robot.xsrot = robot.x
                    &gt; robot.ysrot = robot.y
                    &gt; robot.srotelo = 
box(robot.xsrot*10-5,robot.ysrot*10-5,robot.xsrot*10+5,robot.ysrot*10+5, 
filled=0, colour=Colour.dark_blue)
                    &gt; robot.x = 0
                    &gt; robot.y = 0
                    &gt; robot.srot = 1
                    &gt; return robot

[1] myslím, ¾e kdy¾ se srazí dva roboti, tak jeden musí zmizet a z 
druhého se stane srot. Musí zmizet ze seznamu a z druhého je srot (bez 
ohledu na to, jestli jiz srotem byl), který v seznamu zùstává. 

            &gt; p = p+1
        &gt; sleep(0.0025)

to bych dal pryè, proto¾e jsme zjemnili krok

 &gt;        
 &gt; # Tato funkce pohne hráèem podle koordinátù upravených ve funkci 
zmena_XY       
 &gt; def posunHrace():                              
    &gt; move_to(hrac.telo, hrac.x*10, hrac.y*10)
 &gt;
 &gt; # Funkce znemo¾òující hráèùv pohyb za okraj hrací plochy
 &gt; def kontrola_plochy(hrac):
    &gt; if hrac.x &lt; 1:
       &gt; hrac.x = 1
 &gt;       
    &gt; elif hrac.x &gt; 63:
       &gt; hrac.x = 63
 &gt;       
    &gt; if hrac.y &lt; 1:
       &gt; hrac.y = 1
 &gt;       
    &gt; elif hrac.y &gt; 47:
       &gt; hrac.y = 47
    &gt; move_to(hrac.telo, hrac.x*10, hrac.y*10)
    &gt; return hrac
 &gt;    
 &gt; # Kontrola srá¾ky hráèe s robotem
 &gt; def kontrola_srazky(konec_sub):
    &gt; for robot in seznam:
        &gt; if float(robot.x) == float(hrac.x)  and float(robot.y) == 
float(hrac.y):

tady si myslím ¾e je nejvìt¹í chyba - takto se souøadnice musí shodovat 
absolutnì pøesnì - proto èasto &quot;oèividné&quot; srá¾ky nezpùsobí nic. Je lep¹í 
pou¾ít nepøesnìj¹í, zato pøirozenìj¹í funkci round()
            &gt; konec_sub = 1
            &gt; return konec_sub
        &gt; elif robot.xsrot == hrac.x and robot.ysrot == hrac.y:
            &gt; konec_sub = 1
            &gt; return konec_sub
 &gt;
 &gt; # Kontrola srá¾ky robota se ¹rotem
 &gt; def kontrola_srazky_robotu(robot):
    &gt; p = 0
    &gt; for robot in seznam:
        &gt; for n in range(10):
            &gt; if robot.x == seznam[n].xsrot and robot.y == seznam[n].ysrot:
                &gt; remove_from_screen(robot.telo)
                &gt; robot.x = 800
                &gt; robot.y = 800
                &gt; robot.srot = 2
                &gt; return robot

tak nevím,  - -já myslel ¾e tohle testování je u¾ tam nahoøe [1]- 
pøipadá mi to tu dvojité

        &gt; p = p+1
 &gt;
 &gt; # Funkce kontrolující, jestli hráè nezvítìzil.
 &gt; def vyhra():
    &gt; check = 0
    &gt; vyhra_seznam = []
    &gt; for robot in seznam:
        &gt; if robot.srot != 0:
            &gt; vyhra_seznam.append(&quot;yes&quot;)
        &gt; else:
            &gt; vyhra_seznam.append(&quot;no&quot;)
    &gt; for n in range(20):
        &gt; if vyhra_seznam[n] == &quot;yes&quot;:
            &gt; check = check + 1
    &gt; if check == 20:
        &gt; vyhra_v = 1
        &gt; return vyhra_v

pokud se hrac srazi s robotem (at zivim nebo mrtvým), tak to je jasné, 
to øe¹í¹ jinde. tady se øe¹í jak poznat, jestli tam ji¾ není ¾ádný 
&quot;¾ivý&quot; robot, ¾e jo? nedá se to nìjak jednodu¹eji?napø. pøi posunu 
robotù poèítat, kolik jsme jich posunuly (kolik jeich není srotem). No a 
pokud je to èíslo 0, tak huuuurrrrááááá!

 &gt;    
 &gt;        
 &gt; ###################   
 &gt; # SAMOTNÝ PROGRAM #
 &gt; ###################
 &gt;
 &gt; # Vytváøí okraj hrací plochy
 &gt; box(4,4,636,476)
 &gt; box(5,5,635,475)                       
 &gt; # Výroba objektù
 &gt; hrac = vyrobHrace()       
 &gt; robot, seznam = vyrobRobota(hrac, seznam)
 &gt; # Poèátek herního cyklu
 &gt; while konec != 2:
    &gt; klavesy = keys_pressed()
    &gt; # Spu¹tení hráèovy posunové dvoj-funkce
    &gt; hrac, teleportace = zmena_XY_hr(hrac, teleportace)
    &gt; posunHrace()
    &gt; # Kontrola, jestli není hráè za okrajem plochy, posunutí robotem a 
pøípadné vyhodnocení kolize
    &gt; hrac = kontrola_plochy(hrac)
    &gt; # Posun robotem a kontrola kolizi
    &gt; robot = posunRobota(robot)
    &gt; konec_sub = kontrola_srazky(konec_sub)
    &gt; robot = kontrola_srazky_robotu(robot)
    &gt; # Funkce kontrolující, jestli hráè nezvítìzil.
    &gt; vyhra_v = vyhra()
    &gt; # Ukonèení hry v pøípadì srá¾ky.
    &gt; if konec_sub == 1:
        &gt; print &quot;Prohrál jsi!&quot;
        &gt; konec = 2
    &gt; # Ukonèení hry v pøípadì výhry.
    &gt; elif vyhra_v == 1:
        &gt; print &quot;Vyhrál jsi!&quot;
        &gt; konec = 2
    &gt; # Pøeru¹ení hry u¾ivatelem.
    &gt; if &quot;q&quot; in klavesy:
        &gt; konec = 2
 &gt;        
 &gt; end_graphics()  # Tjádadýdadá...to je konec.          


nebylo by to pøehlednìj¹í nìjak takto?


while not koncime:
    posunHrace()
    posunRobota()
    kontrolaSrazek()


Pokud bude¹ chtít, po¹lu ti mé øe¹ení, ale rad¹i to sem nedávám rovnou, 
abych ti nekazil radost.

Ahoj!!!

-- 
geon
volume doprava.

</PRE>


<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Pøedchozí pøíspìvek: <A HREF="http://www.py.cz/pipermail/tutor/2006-March/000242.html">[Tutor PyCZ] Roboti Pøicházejí - Final(?)
</A></li>
	<LI>Následující pøíspìvek: <A HREF="http://www.py.cz/pipermail/tutor/2006-March/000244.html">[Tutor PyCZ] Roboti Pøicházejí - Final(?)
</A></li>
         <LI> <B>Zprávy tøídìné podle:</B> 
              <a href="http://www.py.cz/pipermail/tutor/2006-March/date.html#243">[ data ]</a>
              <a href="http://www.py.cz/pipermail/tutor/2006-March/thread.html#243">[ vlákna ]</a>
              <a href="http://www.py.cz/pipermail/tutor/2006-March/subject.html#243">[ subjektu ]</a>
              <a href="http://www.py.cz/pipermail/tutor/2006-March/author.html#243">[ autora ]</a>
         </LI>
       </UL>
<hr>
<a href="http://www.py.cz/mailman/listinfo/tutor">Dal¹í informace o konferenci Tutor</a><br>
</body>
<!-- Mirrored from www.py.cz/pipermail/tutor/2006-March/000243.html by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 20 Mar 2016 21:36:10 GMT -->
</html>
