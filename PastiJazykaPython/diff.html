<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"
      lang="en">
                         
  
<!-- Mirrored from www.py.cz/PastiJazykaPython/diff by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 20 Mar 2016 21:03:29 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta http-equiv="Content-Type"
          content="text/html;charset=utf-8" />
    
    <link rel="stylesheet" type="text/css"
          href="../FrontPage/stylesheet.css" />
    <title>PyCZ: Programovací jazyk Python, aplikační servery a frameworky, atd. PastiJazykaPython</title>
    
    
    <meta name="robots" content="noindex,nofollow" />
  
  
  </head>
  <body>
    
    <div>
      <div id="pageheaderall" class="pageheader">
      <div id="accesskeys">
      <a accesskey="0"
         href="http://www.py.cz/PastiJazykaPython/helpaccesskeys"></a>
      <a accesskey="f" href="http://www.py.cz/FrontPage"></a>
      <a accesskey="c"
         href="http://www.py.cz/FrontPage/contents#PastiJazykaPython"></a>
      <a accesskey="r"
         href="http://www.py.cz/FrontPage/recentchanges"></a>
      <a accesskey="" href="http://www.py.cz/FrontPage"></a>
      
      <a accesskey="i"
         href="http://www.py.cz/FrontPage/wikiindex"></a>
      
      <a accesskey="o"
         href="http://www.py.cz/FrontPage/useroptions?redirectURL=http%3A//www.py.cz/PastiJazykaPython"></a>
      <a accesskey="h" href="http://www.py.cz/HelpPage"></a>
      
      
      <a accesskey="n"
         href="http://www.py.cz/RozhovoryPrednasky"></a>
      <a accesskey="p"
         href="http://www.py.cz/ParalelniPrirazeni"></a>
      <a accesskey="u" href="http://www.py.cz/PythonicWay"></a>
      <a accesskey="v"
         href="http://www.py.cz/PastiJazykaPython"></a>
      <a accesskey="m"
         href="http://www.py.cz/PastiJazykaPython/subscribeform"></a>
      <a accesskey="b"
         href="http://www.py.cz/PastiJazykaPython/backlinks"></a>
      <a accesskey="d"
         href="http://www.py.cz/PastiJazykaPython/diff"></a>
      <a accesskey="y"
         href="http://www.py.cz/PastiJazykaPython/history"></a>
      <a accesskey="e"
         href="http://www.py.cz/PastiJazykaPython/editform"></a>
      
    </div>
      <div id="navlinks" class="linkpanel">
      <table class="shade1" width="100%" border="0" cellspacing="0">
        <tr>
          <td align="right">
            
      <a href="http://www.py.cz/FrontPage"
         title="show front page">
      <span>home</span></a>
      <a href="http://www.py.cz/FrontPage/contents#PastiJazykaPython"
         title="show wiki contents">
      <span>contents</span></a>
      <a href="http://www.py.cz/FrontPage/recentchanges"
         title="show wiki recent changes">
      <span>changes</span></a>
      
      <a title="show wiki index"
         href="http://www.py.cz/FrontPage/wikiindex">
      <span>index</span></a>
      
      <a title="show wiki options"
         href="http://www.py.cz/FrontPage/useroptions?redirectURL=http%3A//www.py.cz/PastiJazykaPython">
      <span>options</span></a>
      <a title="show help page"
         href="http://www.py.cz/HelpPage">
      <span>help</span></a>
    
            
      
      <a href="http://www.py.cz/PastiJazykaPython/subscribeform"
         title="configure email subscription to this page or site">
        
      <span>subscribe</span></a>
      
      <a href="http://www.py.cz/PastiJazykaPython/editform"
         title="edit-page (last edited 2 years ago by mol)">
      <span>edit</span></a>
      
    
          </td>
        </tr>
      </table>
    </div>
      <div id="pageheader">
        <form method="GET"
              action="http://www.py.cz/FrontPage/searchwiki">
          <table width="100%" border="0" cellspacing="0">
            <tr>
              <!-- logo -->
              <td id="logo" width="1%" valign="top"
                  class="logo">
                
                  <a title="go to home page"
                     href="http://www.py.cz/FrontPage">
                    
                    <img src="http://www.py.cz/PastiJazykaPython/logo.jpg" border="0" alt="home" />
                    
                  </a>
                  &nbsp;
                
              </td>
              <!-- page name and context (parent topics) -->
              <td align="left" width="79%">
                
                  <small><ul class="outline expandable">
 <li><a href="http://www.py.cz/PythonRoot" name="PythonRoot">PythonRoot</a>
<ul class="outline expandable">
  <li><a href="http://www.py.cz/PythonicWay" name="PythonicWay">PythonicWay</a>
<ul class="outline expandable">
  <li><h1 style="display:inline;"><a href="http://www.py.cz/PastiJazykaPython/backlinks" title="which pages link to this one ?" name="PastiJazykaPython">PastiJazykaPython</a></h1></li>
</ul>
  </li>
</ul>
 </li>
</ul>
</small>
                
                
              </td>
              <!-- search form & page info -->
              <td class="searchbox" width="20%" align="right">
                
                  <input id="searchinput" class="formfield"
                         name="expr" type="text" size="20"
                         maxlength="100" value=""
                         title="search all pages" /><br />
                  <span class="lasteditor">last edited  <a href="http://www.py.cz/PastiJazykaPython/history" title="show last edit" >2 years</a> ago by <b>mol</b></span><br>
                  <span class="creator">created 2006-03-15</span>   
                
                
              </td>
            </tr>
          </table>
        </form>
      </div>
      <div id="ratingform" align="right">  
      <!-- page rating form -->
      <div>
        <a name="ratingform"></a>
        <style type="text/css">
          input.rating {border:none;}
        </style>
        <form method="POST" id="ratingform"
              action="http://www.py.cz/PastiJazykaPython/vote">
           <input type="image" name="vote0" value="0"
                  alt="0" class="rating" width="14"
                  height="13"
                  src="http://www.py.cz/p_/sp"
                  style=""
                  title="click to vote 0 (poor) for this page (0 votes)" /><input
    type="image" name="vote1" value="1" alt="1"
    class="rating" src="http://www.py.cz/PastiJazykaPython/misc_/ZWiki/star_icon" style=""
    title="click to vote 1 (average) for this page (0 votes)" /><input
    type="image" name="vote2" value="2" alt="2"
    class="rating" src="http://www.py.cz/PastiJazykaPython/misc_/ZWiki/blank_star_icon"
    style=""
    title="click to vote 2 (above average) for this page (0 votes)" /><input
    type="image" name="vote3" value="3" alt="3"
    class="rating" src="http://www.py.cz/PastiJazykaPython/misc_/ZWiki/blank_star_icon"
    style=""
    title="click to vote 3 (good) for this page (0 votes)" /><input
    type="image" name="vote4" value="4" alt="4"
    class="rating" src="http://www.py.cz/PastiJazykaPython/misc_/ZWiki/blank_star_icon"
    style=""
    title="click to vote 4 (great) for this page (0 votes)" /><input
    type="image" name="vote5" value="5" alt="5"
    class="rating" src="http://www.py.cz/PastiJazykaPython/misc_/ZWiki/blank_star_icon"
    style=""
    title="click to vote 5 (superb) for this page (0 votes)" />
        </form>
      </div>
    </div>
    </div>
      <h1>Edit detail for PastiJazykaPython revision 2 of 1</h1>
      <div class="formcontent">
        <table border="0" cellspacing="0" width="100%">
          <tr valign="top">

            <td align="left">
              <form style="display:inline"
                    action="http://www.py.cz/PastiJazykaPython">
                <input type="submit" name="history:method"
                       value="Return to edit history" />
                
              </form>
            </td>

            <td align="center">
              <form style="display:inline"
                    action="http://www.py.cz/PastiJazykaPython/diff">
                <input type="hidden" name="rev" />
                
                <input disabled="1" value=" &lt; "
                       type="submit" accesskey="," />
              </form>
              <a style="font-weight:bold"
                 href="http://www.py.cz/PastiJazykaPython/diff?rev=2">2</a>
              <form style="display:inline"
                    action="http://www.py.cz/PastiJazykaPython/diff">
                <input type="hidden" name="rev" />
                
                <input disabled="1" value=" &gt; "
                       type="submit" accesskey="." />
              </form>
            </td>

            <td align="right">
              <form style="display:inline"
                    action="http://www.py.cz/PastiJazykaPython">
                <input type="hidden" name="rev" value="2" />
                <input value="Revert to this version"
                       type="submit" name="revert:method"
                       disabled="disabled" />
              </form>
            </td>

          </tr>
          <tr valign="top">
            <td colspan="3">
              <span>Editor:</span> mol
              <br />
              <span>Time:</span> 2013/09/04 21:58:25 GMT+2
            </td>
          </tr>
          <tr valign="top">
            <td colspan="3">
              <span>Note:</span> <span
    style="font-weight:bold; font-style:italic;">fixed wikilink</span>
            </td>
          </tr>
        </table>
        <hr />
        <pre>
<b>changed:</b><span style="color:red;text-decoration:line-through">
-</span><span style="color:green">
  &lt;h1&gt;10 pastí jazyka Python&lt;/h1&gt;

&lt;hr&gt;
  &lt;p&gt;(C) 2003 &lt;a href=
  &quot;mailto:hans@zephyrfalcon.org?subject=Python%20pitfalls&quot;&gt;Hans
  Nowak&lt;/a&gt;. Written: 2003.08.13. Last update: 2003.09.05.&lt;br&gt;
  Díky Blake Winton, Joe Grossberg, Steve Ferg, Lloyd Kvam za
  hodnotné připomínky.&lt;/p&gt;

  &lt;p&gt;(C) 2005 Překlad &lt;a href=&quot;http://www.geon.wz.cz&quot;&gt;Pavel Kosina&lt;/a&gt;
   a &lt;a href=&quot;http://www.skil.cz/python&quot;&gt;Petr Přikryl&lt;/a&gt;. Přeloženo: srpen 2005&lt;br&gt;
  anglický originál leží
  http://zephyrfalcon.org/labs/python_pitfalls.html&lt;/p&gt;
  
&lt;hr&gt;

  &lt;p&gt;Nejde nutně o vady na kráse či nedodělky. Jsou to spíše vedlejší
  účinky vlastností jazyka, o které často zakopávají nováčci a někdy i
  zkušení programátoři. Při neúplném pochopení podstatných rysů
  chování jazyka Python se můžete spálit.&lt;/p&gt;

  &lt;p&gt;Tento dokument má být jakýmsi průvodcem pro ty, pro které je
  jazyk Python něčím novým. Dozvědět o pastech a léčkách brzy je
  lepší, než narazit na ně ve vytvářeném kódu těsně před termínem
  odevzdání :-} Tento dokument &lt;b&gt;není&lt;/b&gt; míněn jako kritika jazyka.
  Jak jsem již řekl, většina těchto pastí není způsobena vadami
  jazyka.&lt;/p&gt;

  &lt;h3&gt;1. Nepořádné odsazování&lt;/h3&gt;

  &lt;p&gt;Možná trochu laciné téma na úvod. Nicméně, mnozí nováčci mají
  zkušenost s jazyky, kde mezery &quot;nehrají roli&quot;. &lt;em&gt;Cestou slepých
  uliček&lt;/em&gt;&lt;sup class=&quot;trnote&quot; id=&quot;B_indent&quot;
  title=&quot;... jak formuloval jeden nedoceněný český velikán&quot; 
  &gt;&lt;a href=&quot;#P_indent&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt; mohou dojít až k
  nemilému překvapení, že je Python trestá za zlozvyk nepořádného
  odsazování.&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;Řešení&lt;/strong&gt;: Dodržujte správné odsazování. Používejte
  buď mezery, nebo tabulátory&lt;sup class=&quot;trnote&quot; id=&quot;B_spaces&quot;
  title=&quot;Doporučuje se dávat přednost mezerám.&quot;&gt;&lt;a href=&quot;#P_spaces&quot;
  &gt;[2]&lt;/a&gt;&lt;/sup&gt;, ale nikdy to nemíchejte. Kvalitní editor pomáhá.&lt;/p&gt;

  &lt;h3 id=&quot;pitfall2&quot;&gt;2. Přiřazení, neboli jména a objekty&lt;/h3&gt;

  &lt;p&gt;Lidé přicházející od staticky typovaných jazyků, jako je Pascal
  nebo C, často předpokládají, že Python zachází s proměnnými a s
  přiřazováním stejně, jako jejich oblíbený jazyk. Na první pohled to
  tak skutečně vypadá:&lt;/p&gt;
  
&lt;pre&gt;
a = b = 3
a = 4
print a, b  # 4, 3
&lt;/pre&gt;

  &lt;p&gt;Dostávají se však do potíží, když začnou používat měnitelné
  objekty. Často pak hned přicházejí s tvrzením, že Python zachází
  s měnitelnými a neměnitelnými objekty rozdílně.&lt;/p&gt;
  
&lt;pre&gt;
a = [1, 2, 3]
b = a
a.append(4)
print b
# b je nyní také [1, 2, 3, 4]
&lt;/pre&gt;

  &lt;p&gt;Stalo se to, že výraz &lt;code&gt;a = [1, 2, 3]&lt;/code&gt; provedl dvě
  věci: 1. vytvořil objekt, v tomto případě seznam s hodnou [1, 2,
  3]; 2. svázal ho se jménem &lt;code&gt;a&lt;/code&gt; v lokálním prostoru
  jmen. Výraz &lt;code&gt;b = a&lt;/code&gt; pak svázal jméno
  &lt;code&gt;b&lt;/code&gt; s tím samým seznamem (na který již odkazuje
  &lt;code&gt;a&lt;/code&gt;)&lt;sup class=&quot;trnote&quot; id=&quot;B_assign&quot;
  title=&quot;a ještě jinými slovy...&quot;&gt;&lt;a href=&quot;#P_assign&quot;&gt;[3]&lt;/a&gt;&lt;/sup&gt;. 
  Jakmile si toto uvědomíte, bude již méně obtížné pochopit, co
  vlastně &lt;code&gt;a.append(4)&lt;/code&gt; dělá... že mění seznam, na který se
  odkazuje jak &lt;code&gt;a&lt;/code&gt; tak &lt;code&gt;b&lt;/code&gt;.&lt;/p&gt;

  &lt;p&gt;Domněnka, že se s měnitelnými a neměnitelnými objekty při
  přiřazování zachází rozdílně, je mylná. Při přiřazování &lt;code&gt;a =
  3&lt;/code&gt; a &lt;code&gt;b = a&lt;/code&gt; se děje přesně stejná věc, jako u výše
  uvedeného seznamu. Jména &lt;code&gt;a&lt;/code&gt; i &lt;code&gt;b&lt;/code&gt; nyní
  odkazují na stejný objekt &amp;mdash; na číslo s hodnotou 3. Protože
  však čísla jsou neměnitelná (immutable), nepozorujete žádný vedlejší
  efekt &lt;sup class=&quot;trnote&quot; id=&quot;B_assign2&quot; title=&quot;...detaily&quot;&gt;&lt;a 
  href=&quot;#P_assign2&quot;&gt;[4]&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;Řešení&lt;/strong&gt;: Přečtěte si &lt;a href=
  &quot;ObjektyJazykaPython&quot; title=&quot;&quot;&gt;toto&lt;/a&gt;. Abyste se zbavili
  nechtěných vedlejších efektů, kopírujte (používejte metodu copy,
  operátory řezu (slice), atd). Python nikdy implicitně nekopíruje.&lt;/p&gt;

  &lt;h3&gt;3. Operátor +=&lt;/h3&gt;

  &lt;p&gt;V jazycích jako třeba C, jsou rozšířené přiřazovací operátory jako
  &lt;code&gt;+=&lt;/code&gt; zkratkami pro delší výrazy. Například,&lt;/p&gt;
&lt;pre&gt;
x += 42;
&lt;/pre&gt;

  &lt;p&gt;je syntaktická pomůcka (angličani říkají &lt;em&gt;syntactic sugar&lt;/em&gt;) 
  pro&lt;/p&gt;
&lt;pre&gt;
x = x + 42;
&lt;/pre&gt;

  &lt;p&gt;Takže byste si mohli myslet, že tomu tak bude i v jazyce Python. 
  Na první pohled to tak skutečně vypadá:&lt;/p&gt;
&lt;pre&gt;
a = 1
a = a + 42
# a je 43
a = 1
a += 42
# a je 43
&lt;/pre&gt;

  &lt;p&gt;Ale u měnitelných objektů (mutable) zápis &lt;code&gt;x += y&lt;/code&gt;
  nemusí nutně vyjadřovat totéž, jako zápis
  &lt;code&gt;x&amp;nbsp;=&amp;nbsp;x&amp;nbsp;+&amp;nbsp;y&lt;/code&gt;. Uvažujme seznamy:&lt;/p&gt;
  
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; z = [1, 2, 3]
&amp;gt;&amp;gt;&amp;gt; id(z)
24213240
&amp;gt;&amp;gt;&amp;gt; z += [4]
&amp;gt;&amp;gt;&amp;gt; id(z)
24213240
&amp;gt;&amp;gt;&amp;gt; z = z + [5]
&amp;gt;&amp;gt;&amp;gt; id(z)
24226184
&lt;/pre&gt;

  &lt;p&gt;Příkaz &lt;code&gt;x += y&lt;/code&gt; mění seznam na místě a má stejný
  důsledek jako metoda &lt;code&gt;extend&lt;/code&gt;. Příkaz
  &lt;code&gt;z&amp;nbsp;=&amp;nbsp;z&amp;nbsp;+&amp;nbsp;y&lt;/code&gt; vytváří nový seznam a
  sváže ho se znovu použitým jménem &lt;code&gt;z&lt;/code&gt;, což je ale něco
  jiného, než u předchozího příkazu. Jde o jemný rozdíl vedoucí
  k&amp;nbsp;delikátním a těžko zachytitelným chybám.&lt;/p&gt;

  &lt;p&gt;Aby toho nebylo dost, vede to také k překvapivému chování,
  když se míchají měnitelné a neměnitelné kontejnery:&lt;/p&gt;
  &lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; t = ([],)
&amp;gt;&amp;gt;&amp;gt; t[0] += [2, 3]
Traceback (most recent call last):
  File &quot;&amp;lt;input&amp;gt;&quot;, line 1, in ?
TypeError: object doesn't support item assignment
&amp;gt;&amp;gt;&amp;gt; t
([2, 3],)
&lt;/pre&gt;

  &lt;p&gt;N-tice, samozřejmě, nepodporují přiřazování svých prvků. Jenže po
  provedení &lt;code&gt;+=&lt;/code&gt; se seznam uvnitř &lt;b&gt;změnil&lt;/b&gt;! Důvod je
  opět v tom, že &lt;code&gt;+=&lt;/code&gt; mění seznam na místě. Přiřazení prvku
  n-tice sice nefunguje, ale když se stane výjimka, tak prvek již byl
  na místě změněn.&lt;/p&gt;
  
  &lt;p&gt;Tuto léčku já osobně považuji za vadu na kráse&lt;sup class=&quot;trnote&quot;
  id=&quot;B_tmod&quot; title=&quot;Ale co je vlastně špatně?&quot;&gt;&lt;a
  href=&quot;#P_tmod&quot;&gt;[5]&lt;/a&gt;&lt;/sup&gt; :-).&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;Řešení&lt;/strong&gt;: podle vašeho postoje k tomuto
  problému můžete buď se kompletně používání vyvarovat += nebo to
  používat jen pro čísla anebo se s tím naučit žít ...&lt;/p&gt;

  &lt;h3&gt;4. Atributy tříd versus atributy instancí&lt;/h3&gt;

  &lt;p&gt;Zde se chybuje nejméně ve dvou věcech. Tak za prvé, nováčci
  pravidelně přidávají atributy do třídy (místo do instance) a
  diví se, když jsou pak tyto atributy sdíleny mezi instancemi:&lt;/p&gt;
  
  &lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; class Foo:
...     bar = []
...     def __init__(self, x):
...         self.bar.append(x)
...     
&amp;gt;&amp;gt;&amp;gt; f = Foo(42)
&amp;gt;&amp;gt;&amp;gt; g = Foo(100)
&amp;gt;&amp;gt;&amp;gt; f.bar, g.bar
([42, 100], [42, 100])
&lt;/pre&gt;

  &lt;p&gt;Nejde o vadu, ale šikovný rys, kterého můžeme v řadě situací
  využít. Nepochopení vyplývá z faktu, že byly použity atributy třídy
  a ne atributy instance. Může to být i tím, že se atributy instancí v
  Pythonu vytvářejí jinak, než v dalších jazycích. V jazycích C++,
  Object Pascal a dalších se deklarují ve těle třídy.&lt;/p&gt;

  &lt;p&gt;Další (malá) léčka spočívá v tom, že &lt;code&gt;self.foo&lt;/code&gt; může
  odkazovat na dvě věci: na atribut instance &lt;code&gt;foo&lt;/code&gt; nebo
  &amp;mdash; pokud tento neexistuje &amp;mdash; na atribut třídy
  &lt;code&gt;foo&lt;/code&gt;. Porovnejte:&lt;/p&gt;
  
  &lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; class Foo:
...     a = 42
...     def __init__(self):
...         self.a = 43
...     
&amp;gt;&amp;gt;&amp;gt; f = Foo()
&amp;gt;&amp;gt;&amp;gt; f.a
43
&lt;/pre&gt;

  &lt;p&gt;a druhý případ&lt;/p&gt;
  &lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; class Foo:
...     a = 42
...     
&amp;gt;&amp;gt;&amp;gt; f = Foo()
&amp;gt;&amp;gt;&amp;gt; f.a
42
&lt;/pre&gt;

  &lt;p&gt;V prvním příkladě &lt;code&gt;f.a&lt;/code&gt; odkazuje na atribut instance s
  hodnotou 43. Má přednost před atributem třídy s hodnotou 42. V
  druhém příkladě žádný atribut instance &lt;code&gt;a&lt;/code&gt; neexistuje,
  takže &lt;code&gt;f.a&lt;/code&gt; odkazuje na atribut třídy.&lt;/p&gt;

  &lt;p&gt;Následující ukázka oba případy kombinuje:&lt;/p&gt;
  &lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; class Foo:
...     
...     bar = []
...     def __init__(self, x):
...         self.bar = self.bar + [x]
...     
&amp;gt;&amp;gt;&amp;gt; f = Foo(42)
&amp;gt;&amp;gt;&amp;gt; g = Foo(100)
&amp;gt;&amp;gt;&amp;gt; f.bar
[42]
&amp;gt;&amp;gt;&amp;gt; g.bar
[100]
&lt;/pre&gt;

  &lt;p&gt;V příkazu &lt;code&gt;self.bar = self.bar + [x]&lt;/code&gt; neodpovídají
  zápisy obou &lt;code&gt;self.bar&lt;/code&gt; stejnému odkazu... Druhý zápis
  odkazuje na atribut třídy &lt;code&gt;bar&lt;/code&gt;. Výsledek je poté svázán
  s atributem instance.&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;Řešení&lt;/strong&gt;: Tento rozdíl může být matoucí, ale není
  nepochopitelný. Atributy tříd používejte v situacích, když chcete
  něco sdílet mezi více instancemi třídy. Abyste se vyhnuli
  nejednoznačnosti, můžete se na ně odkazovat zápisem
  &lt;code&gt;self.__class__.&lt;em&gt;jmeno&lt;/em&gt;&lt;/code&gt; místo zápisu
  &lt;code&gt;self.&lt;em&gt;jmeno&lt;/em&gt;&lt;/code&gt; i v případech, kdy neexistuje žádný
  atribut instance tohoto jména. Pro atributy, které mohou v každé
  instanci nabývat jiné hodnoty, používejte atributy instancí a
  odkazujete se na ně přes self.&lt;em&gt;jmeno&lt;/em&gt;.&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;Aktualizace:&lt;/strong&gt; Vícero lidí poznamenává, že pasti
  číslo 3 a 4 se dají kombinovat do ještě zábavnějšího hlavolamu:&lt;/p&gt;
  
  &lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; class Foo:
...     bar = []
...     def __init__(self, x):
...             self.bar += [x]
...             
&amp;gt;&amp;gt;&amp;gt; f = Foo(42)
&amp;gt;&amp;gt;&amp;gt; g = Foo(100)
&amp;gt;&amp;gt;&amp;gt; f.bar
[42, 100]
&amp;gt;&amp;gt;&amp;gt; g.bar
[42, 100]
&lt;/pre&gt;

  &lt;p&gt;Důvod pro toto chování je ten, že
  &lt;code&gt;self.bar&amp;nbsp;+=&amp;nbsp;&lt;em&gt;něco&lt;/em&gt;&lt;/code&gt; není stejné jako
  &lt;code&gt;self.bar&amp;nbsp;=&amp;nbsp;self.bar&amp;nbsp;+&amp;nbsp;&lt;code&gt;něco&lt;/code&gt;&lt;/code&gt;.
  Zápis &lt;code&gt;self.bar&lt;/code&gt; zde vyjadřuje odkaz na
  &lt;code&gt;Foo.bar&lt;/code&gt;, takže &lt;code&gt;f&lt;/code&gt; i &lt;code&gt;g&lt;/code&gt;
  aktualizují stejný seznam.&lt;/p&gt;

  &lt;h3&gt;5. Měnitelné implicitní argumenty&lt;/h3&gt;

  &lt;p&gt;Tato past trápí začátečníky znovu a znovu. Ve skutečnosti to
  je varianta pasti číslo 2, kombinovaná s neočekávaným chováním
  implicitních argumentů. Uvažujme následující funkci:&lt;/p&gt;
  &lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; def popo(x=[]):
...     x.append(666)
...     print x
...     
&amp;gt;&amp;gt;&amp;gt; popo([1, 2, 3])
[1, 2, 3, 666]
&amp;gt;&amp;gt;&amp;gt; x = [1, 2]
&amp;gt;&amp;gt;&amp;gt; popo(x)
[1, 2, 666]
&amp;gt;&amp;gt;&amp;gt; x
[1, 2, 666]
&lt;/pre&gt;

  &lt;p&gt;To se dalo čekat. Ale teď:&lt;/p&gt;
  &lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; popo()
[666]
&amp;gt;&amp;gt;&amp;gt; popo()
[666, 666]
&amp;gt;&amp;gt;&amp;gt; popo()
[666, 666, 666]
&lt;/pre&gt;

  &lt;p&gt;Možná jste čekali, že výstup bude ve všech případech [666]...
  vždyť když voláme popo() bez argumentů, bere se přeci [] jako
  implicitní, že jo? Ne. Implicitní argument se volá *jednou* a to
  když se funkce *vytváří* a ne když se volá. (Jinými slovy, u funkce
  &lt;code&gt;f(x=[])&lt;/code&gt; se x nepřiřazuje pokaždé, když se funkce volá.
  Do &lt;code&gt;x&lt;/code&gt; se přiřadí [], jen když se funkce definuje&lt;sup
  class=&quot;trnote&quot; id=&quot;B_mda&quot; title=&quot;... opakování je matka
  moudrosti&quot;&gt;&lt;a href=&quot;#P_mda&quot;&gt;[6]&lt;/a&gt;&lt;/sup&gt;. Pokud se jedná o
  měnitelný objekt, a ten se změnil, bude příští volání funkce za svůj
  implicitní argument považovat stejný seznam, který už ale má jiný
  obsah.&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;Řešení&lt;/strong&gt;: Toto chování může být někdy užitečné.
  Ale obecně byste si na tyto vedlejší efekty měli dávat pozor.&lt;/p&gt;

  &lt;h3&gt;6. !UnboundLocalError&lt;/h3&gt;

  &lt;p&gt;Tato chyba se podle manuálu objeví v případě, kdy se jméno &quot;odkazuje
  na lokální proměnnou, která ještě dosud nebyla navázána (bound)&quot;.
  To zní tajemně. Nejlepší to bude ukázat na malém příkladě:&lt;/p&gt;
  &lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; def p():
...     x = x + 2
...     
&amp;gt;&amp;gt;&amp;gt; p()
Traceback (most recent call last):
  File &quot;&amp;lt;input&amp;gt;&quot;, line 1, in ?
  File &quot;&amp;lt;input&amp;gt;&quot;, line 2, in p
UnboundLocalError: local variable 'x' referenced before assignment
&lt;/pre&gt;

  &lt;p&gt;Uvnitř &lt;code&gt;p&lt;/code&gt; nemůže být výraz &lt;code&gt;x = x + 2&lt;/code&gt;
  proveden, protože &lt;code&gt;x&lt;/code&gt; ve výrazu &lt;code&gt;x + 2&lt;/code&gt;
  ještě nemá žádnou hodnotu. To zní rozumně. Nemůžete se odkazovat
  na jméno, které ještě neexistuje. Ale zvažme následující:&lt;/p&gt;
  &lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; x = 2
&amp;gt;&amp;gt;&amp;gt; def q():
...     print x
...     x = 3
...     print x
...     
&amp;gt;&amp;gt;&amp;gt; q()
Traceback (most recent call last):
  File &quot;&amp;lt;input&amp;gt;&quot;, line 1, in ?
  File &quot;&amp;lt;input&amp;gt;&quot;, line 2, in q
UnboundLocalError: local variable 'x' referenced before assignment
&lt;/pre&gt;

  &lt;p&gt;Tento úsek kódu by se vám mohl zdát správný -- nejprve se
  vytiskne 2 (hodnota globální proměnné x), pak se lokální proměnné x
  přiřadí 3 a její hodnota se vytiskne (3). Takhle to však nefunguje.
  Je to dáno pravidly pro rozsah viditelnosti (platnosti,
  použitelnosti jmen). Jsou vysvětlena v referenční příručce:&lt;/p&gt;

  &lt;blockquote&gt;
  
    &lt;p&gt;Pokud je vazba jména provedena uvnitř bloku, jde o lokální
    proměnnou tohoto bloku. Pokud je vazba jména&lt;sup class=&quot;trnote&quot; 
    id=&quot;B_namebinding&quot; title=&quot;Podrobnější vysvětlení...&quot;&gt;&lt;a 
    href=&quot;#P_namebinding&quot;&gt;[7]&lt;/a&gt;&lt;/sup&gt; provedena na úrovni
    modulu, jde o globální proměnnou. (Proměnné bloku kódu modulu jsou
    lokální a globální.) Pokud je proměnná použita v kódu bloku, ale
    není zde definovaná, jedná se o volnou proměnnou.&lt;/p&gt;
    
    &lt;p&gt;Pokud není jméno vůbec nalezeno, vyvolá se výjimka
    &lt;code&gt;NameError&lt;/code&gt;. Pokud se jméno odkazuje na lokální
    proměnnou, pro kterou dosud nebyla provedena vazba, vyvolá se
    výjimka &lt;code&gt;UnboundLocalError&lt;/code&gt;.&lt;/p&gt;
  
  &lt;/blockquote&gt;

  &lt;p&gt;Jinými slovy: Uvnitř funkce může proměnná být lokální nebo
  globální, ale ne obojetná. (Nezáleží na tom, jestli později
  provedete změnu vazby.) Ve výše uvedeném příkladu Python určí, že
  proměnná &lt;code&gt;x&lt;/code&gt; je lokální (na základě zmíněných pravidel).
  Ale při následném provádění funkce se narazí na příkaz
  &lt;code&gt;print&amp;nbsp;x&lt;/code&gt; a &lt;code&gt;x&lt;/code&gt; ještě nemá žádnou
  hodnotu... a tudíž je to chyba.&lt;/p&gt;

  &lt;p&gt;Povšimněte si, že pokud by bylo tělo funkce složeno pouze z
  jednoho řádku &lt;code&gt;print x&lt;/code&gt; nebo z řádků &lt;code&gt;x = 3; print
  x&lt;/code&gt; bylo by to naprosto v pořádku.&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;Řešení:&lt;/strong&gt; Používání lokálních a globálních
  proměnných tímto způsobem nemíchejte.&lt;/p&gt;

  &lt;h3&gt;7. Chyby při zaokrouhlování desetinných čísel&lt;/h3&gt;

  &lt;p&gt;Při tisku hodnot desetinných čísel (float) může být výsledek
  někdy překvapující. Aby byly věci ještě zajímavějšími, mohou se
  reprezentace vracené funkcemi str() a repr() lišit. Ukázka říká
  vše:&lt;/p&gt;
  
  &lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; c = 0.1
&amp;gt;&amp;gt;&amp;gt; c
0.10000000000000001
&amp;gt;&amp;gt;&amp;gt; repr(c)
'0.10000000000000001'
&amp;gt;&amp;gt;&amp;gt; str(c)
'0.1'
&lt;/pre&gt;

  &lt;p&gt;V dvojkové soustavě (kterou používá procesor) nelze řadu čísel
  vyjádřit přesně. Skutečná hodnota se hodnotě zapsané v desítkové
  soustavě pouze blíží.&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;Řešení&lt;/strong&gt;: Více informací se dozvíte z následujícího
  &lt;a href=&quot;http://vik.sh.cvut.cz/~tnt/python/tut/node14.html&quot;&gt;tutoriálu&lt;/a&gt;.

  &lt;h3&gt;8. Spojování řetězců&lt;/h3&gt;

  &lt;p&gt;&lt;strong&gt;Poznámka překladatele:&lt;/strong&gt; 
  Odstraněno, již neplatí.  Uvádělo se zde, že je méně výhodné několikanásobné slučování (sčítání) řetězců. 
  Místo toho se radilo převézt řetězec na seznam, pak několikanásobné append u seznamu a zpětný převod na řetězec. 
  Následující script ukazuje neplatnost tohoto pravidla u Python 2.5, pravděpodobně vlivem efektivnějšího provádění smyček při operacích s
  řetězci. 
  &lt;pre&gt;
import timeit

def f():
    s = &quot;&quot;
    for i in range(100000):
        s = s + &quot;abcdefg&quot;[i % 7]
    

t=timeit.Timer(&quot;f()&quot;,&quot;from __main__ import f&quot;)
print t.timeit(1)

# vysledek python 2.5: 0.0705371772111


def g():
    z = []
    for i in range(100000):
        z.append(&quot;abcdefg&quot;[i % 7])
    return ''.join(z)
    
t=timeit.Timer(&quot;g()&quot;,&quot;from __main__ import g&quot;)
print t.timeit(1)

# vysledek python 2.5: 0.0885903096623

&lt;/pre&gt;

  &lt;h3&gt;9. Binární režim pro soubory&lt;/h3&gt;

  &lt;p&gt;Nebo spíše, používání binárního režimu &lt;b&gt;není&lt;/b&gt; tím, co
  způsobuje zmatek. Některé operační systémy, jako Windows, dělají
  rozdíl mezi binárními a textovými soubory. Pro ilustraci si uveďme, 
  jak lze v jazyce Python otvírat soubory v binárním nebo textovém
  režimu:&lt;/p&gt;
  
  &lt;pre&gt;
f1 = file(jmenosouboru, &quot;r&quot;)  # text
f2 = file(jmenosouboru, &quot;rb&quot;) # binárně
&lt;/pre&gt;

  &lt;p&gt;V textovém režimu, mohou být řádky zakončované znakem &quot;nová
  řádka&quot; a/nebo &quot;návrat vozíku&quot; (&lt;code&gt;\n&lt;/code&gt;, &lt;code&gt;\r&lt;/code&gt;,
  nebo &lt;code&gt;\r\n&lt;/code&gt;). Binární režim si na něco takového nehraje.
  Když ve
  Windows čteme ze soubor v textovém režimu, reprezentuje Python konce
  řádku znakem &lt;code&gt;\n&lt;/code&gt; (universální). Ale v binárním režimu
  dostaneme &lt;code&gt;\r\n&lt;/code&gt;. Při čtení dat proto můžeme v každém z
  těchto režimů získat velmi rozdílné výsledky.&lt;/p&gt;

  &lt;p&gt;Existují systémy, které nerozlišují mezi textovým a binárním
  režimem. Například v Unixu jsou soubory otevírány vždy v binárním
  módu. Díky tomu může kód psaný pro Unix a otevírající soubor v
  režimu 'r' dávat jiné výsledky při spuštění pod Windows. Může se
  také stát, že někdo přicházející z Unixu může použít příznak 'r' i
  ve Windows a bude nemile překvapen výsledky.&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;Řešení&lt;/strong&gt;: Používejte správné flagy &amp;mdash; 'r' pro
  textový režim (i na Unixu), 'rb' na binární režim.&lt;/p&gt;

  &lt;h3&gt;10. Zachytávání několika výjimek najednou&lt;/h3&gt;

  &lt;p&gt;Někdy potřebujete v jednom &lt;code&gt;except&lt;/code&gt; zachytit několik 
  výjimek v jednom. Automaticky nás napadne nás, že by mohlo fungovat
  následující:&lt;/p&gt;
  
  &lt;pre&gt;
try:
    ...něco co vyvolá chybu...
except IndexError, ValueError:
    # &quot;mělo by&quot; zachytit chyby IndexError a ValueError
    # špatně!
&lt;/pre&gt;

  &lt;p&gt;Tohle bohužel nefunguje. Důvody se stanou jasnějšími při
  porovnání s kódem:&lt;/p&gt;
  &lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; try:
...     1/0
... except ZeroDivisionError, e:
...     print e
...     
integer division or modulo by zero
&lt;/pre&gt;

  &lt;p&gt;První &quot;argument&quot; v klauzuli except uvádí třídu výjimky, druhý
  uvádí volitelné jméno, které bude navázáno na aktuální objekt
  vyvolané výjimky. Takže v předchozím chybném kódu by klauzule
  &lt;code&gt;except&lt;/code&gt; zachytila &lt;code&gt;IndexError&lt;/code&gt; a jméno
  &lt;code&gt;ValueError&lt;/code&gt; by svázala s objektem výjimky. To asi není,
  co jsme chtěli. ;-)&lt;/p&gt;

  &lt;p&gt;Tohle funguje lépe:&lt;/p&gt;
  &lt;pre&gt;
try:
    ...něco co vyvolá chybu...
except (IndexError, ValueError):
    # správně zachytí IndexError a ValueError
&lt;/pre&gt;

  &lt;p&gt;&lt;strong&gt;Řešení&lt;/strong&gt;: Když odchytáváte několik výjimek v jedné
  klausuli &lt;code&gt;except&lt;/code&gt;, používejte závorky na vytvoření n-tice
  s výjimkami.&lt;/p&gt;
  
  &lt;hr&gt;

  &lt;h3&gt;Jaké další nástrahy tu jsou? Napadají mne snad:&lt;/h3&gt;

  &lt;ul&gt;
    &lt;li&gt;zpětné lomítka v řetězcích (bez raw), obzvláště u cest
    Windows/DOS&lt;/li&gt;

    &lt;li&gt;dělení celých čísel (v dalších verzích bude snad
    změněno)&lt;/li&gt;
  &lt;/ul&gt;

  &lt;h3&gt;Příbuzné odkazy:&lt;/h3&gt;

  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&quot;http://www.ferg.org/projects/python_gotchas.html&quot;
    title=&quot;&quot;&gt;Python Gotchas&lt;/a&gt; od Steve Ferg&lt;/li&gt;

    &lt;li&gt;&lt;a href=&quot;http://www.amk.ca/python/writing/warts.html&quot;
    title=&quot;&quot;&gt;Python Warts&lt;/a&gt; od Andrew Kuchling&lt;/li&gt;

    &lt;li&gt;&lt;a href=&quot;http://mechanicalcat.net/cgi-bin/log/2003/09/02#anti-pitfalls&quot;
    title=&quot;&quot;&gt;Python anti-pitfalls&lt;/a&gt; od Richard Jones&lt;/li&gt;

  &lt;/ul&gt;



&lt;hr&gt;

  &lt;p&gt;Poznámky překladatele:&lt;/p&gt;
  
  &lt;table summary=&quot;Poznámky překladatele.&quot;&gt;
  &lt;tr id=&quot;P_indent&quot;&gt;&lt;td&gt;&lt;a href=&quot;#B_indent&quot;&gt;[1]&lt;/a&gt;&lt;/td&gt;
  &lt;td&gt;&lt;em&gt;&quot;... Tudy cesta nevede. Vyfukováním kouře do umyvadla s vodou 
    zlato opravdu nevzniká.&quot;&lt;/em&gt; &amp;ndash; J.C.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr id=&quot;P_spaces&quot;&gt;&lt;td&gt;&lt;a href=&quot;#B_spaces&quot;&gt;[2]&lt;/a&gt;&lt;/td&gt;
  &lt;td&gt;S mezerami nikdy problémy nebyly. S tabulátory ano. Někteří si myslí, 
    že se tabulační pozice nemají nastavovat po 8 sloupcích.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr id=&quot;P_assign&quot;&gt;&lt;td&gt;&lt;a href=&quot;#B_assign&quot;&gt;[3]&lt;/a&gt;&lt;/td&gt;
  &lt;td&gt;Takže v tuto chvíli existuje jeden seznam, jeden objekt, na 
    který ukazují dvě jména.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr id=&quot;P_assign2&quot;&gt;&lt;td&gt;&lt;a href=&quot;#B_assign2&quot;&gt;[4]&lt;/a&gt;&lt;/td&gt;
  &lt;td&gt;Přiřazením &lt;code&gt;a = 4&lt;/code&gt; se zruší vazba na celočíselný 
   objekt s hodnotou 3 a vznikne vazba na celočíselný objekt s 
   hodnotou 4.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr id=&quot;P_tmod&quot;&gt;&lt;td&gt;&lt;a href=&quot;#B_tmod&quot;&gt;[5]&lt;/a&gt;&lt;/td&gt;
  &lt;td&gt;N-tice je sice neměnná, ale udržuje pouze odkazy na jiné objekty. 
    Odkazy se skutečně měnit nemohou. Zápis &lt;code&gt;t[0]&lt;/code&gt; reprezentuje
    odkaz na seznam. Nikde se ale neříká, že by n-tice nemohla obsahovat 
    odkazy na měnitelné objekty, které mohou být navíc navázány i na jiná 
    jména a tudíž měněny odjinud. Chyba tedy nespočívá v tom, že se změnil
    obsah seznamu, ale v tom, že vůbec vznikla výjimka.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr id=&quot;P_mda&quot;&gt;&lt;td&gt;&lt;a href=&quot;#B_mda&quot;&gt;[6]&lt;/a&gt;&lt;/td&gt;
  &lt;td&gt;... když Python při spuštění programu poprvé kód zpracovává
    a u funkcí si zapamatovává právě tyto implicitní argumenty (a také
    proměnné i další deklarace uvnitř funkcí). Vytváří se při tom
    vnitřní objekt, který reprezentuje zkompilovanou funkci. A o tom 
    to je.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr id=&quot;P_namebinding&quot;&gt;&lt;td&gt;&lt;a href=&quot;#B_namebinding&quot;&gt;[7]&lt;/a&gt;&lt;/td&gt;
  &lt;td&gt;Jak již bylo vysvětleno u &lt;a href=&quot;#pitfall2&quot;&gt;pasti číslo 2&lt;/a&gt;,
    proměnnou se v Pythonu rozumí jméno, které se odkazuje na objekt.
    Přiřazením hodnoty proměnné se provede pouze svázání jména
    proměnné s uvedeným objektem tak, že se ve vnitřním slovníku
    vytvoří dvojice &lt;em&gt;(jméno, odkaz na objekt)&lt;/em&gt;. Této akci se
    říká provedení vazby jména. Pokud ve vnitřním slovníku neexistuje
    položka s klíčem odpovídajícím jménu, pak vazba nebyla provedena.
    Zmíněných vnitřních slovníků, které Python využívá, je více. V
    jednom z nich jsou zachyceny vazby jmen globálních proměnných. Pro
    každou lokální úroveň je vytvořen příslušný (jiný, oddělený,
    další) vnitřní slovník.&lt;/td&gt;
  &lt;/tr&gt;
  &lt;/table&gt;</span>
</pre>
        <hr />
        <div>  <h1>10 pastí jazyka Python</h1>

<hr>
  <p>(C) 2003 <a href=
  "mailto:&#104;&#97;&#110;&#115;&#64;&#122;&#101;&#112;&#104;&#121;&#114;&#102;&#97;&#108;&#99;&#111;&#110;&#46;&#111;&#114;&#103;?subject=Python%20pitfalls">Hans
  Nowak</a>. Written: 2003.08.13. Last update: 2003.09.05.<br>
  Díky Blake Winton, Joe Grossberg, Steve Ferg, Lloyd Kvam za
  hodnotné připomínky.</p>

  <p>(C) 2005 Překlad <a href="http://www.geon.wz.cz/">Pavel Kosina</a>
   a <a href="http://www.skil.cz/python">Petr Přikryl</a>. Přeloženo: srpen 2005<br>
  anglický originál leží
  <a href="http://zephyrfalcon.org/labs/python_pitfalls.html">http://zephyrfalcon.org/labs/python_pitfalls.html</a></p>
  
<hr>

  <p>Nejde nutně o vady na kráse či nedodělky. Jsou to spíše vedlejší
  účinky vlastností jazyka, o které často zakopávají nováčci a někdy i
  zkušení programátoři. Při neúplném pochopení podstatných rysů
  chování jazyka Python se můžete spálit.</p>

  <p>Tento dokument má být jakýmsi průvodcem pro ty, pro které je
  jazyk Python něčím novým. Dozvědět o pastech a léčkách brzy je
  lepší, než narazit na ně ve vytvářeném kódu těsně před termínem
  odevzdání :-} Tento dokument <b>není</b> míněn jako kritika jazyka.
  Jak jsem již řekl, většina těchto pastí není způsobena vadami
  jazyka.</p>

  <h3>1. Nepořádné odsazování</h3>

  <p>Možná trochu laciné téma na úvod. Nicméně, mnozí nováčci mají
  zkušenost s jazyky, kde mezery "nehrají roli". <em>Cestou slepých
  uliček</em><sup class="trnote" id="B_indent"
  title="... jak formuloval jeden nedoceněný český velikán" 
  ><a href="#P_indent">[1]</a></sup> mohou dojít až k
  nemilému překvapení, že je Python trestá za zlozvyk nepořádného
  odsazování.</p>

  <p><strong>Řešení</strong>: Dodržujte správné odsazování. Používejte
  buď mezery, nebo tabulátory<sup class="trnote" id="B_spaces"
  title="Doporučuje se dávat přednost mezerám."><a href="#P_spaces"
  >[2]</a></sup>, ale nikdy to nemíchejte. Kvalitní editor pomáhá.</p>

  <h3 id="pitfall2">2. Přiřazení, neboli jména a objekty</h3>

  <p>Lidé přicházející od staticky typovaných jazyků, jako je Pascal
  nebo C, často předpokládají, že Python zachází s proměnnými a s
  přiřazováním stejně, jako jejich oblíbený jazyk. Na první pohled to
  tak skutečně vypadá:</p>
  
<pre>
a = b = 3
a = 4
print a, b  # 4, 3
</pre>

  <p>Dostávají se však do potíží, když začnou používat měnitelné
  objekty. Často pak hned přicházejí s tvrzením, že Python zachází
  s měnitelnými a neměnitelnými objekty rozdílně.</p>
  
<pre>
a = [1, 2, 3]
b = a
a.append(4)
print b
# b je nyní také [1, 2, 3, 4]
</pre>

  <p>Stalo se to, že výraz <code>a = [1, 2, 3]</code> provedl dvě
  věci: 1. vytvořil objekt, v tomto případě seznam s hodnou [1, 2,
  3]; 2. svázal ho se jménem <code>a</code> v lokálním prostoru
  jmen. Výraz <code>b = a</code> pak svázal jméno
  <code>b</code> s tím samým seznamem (na který již odkazuje
  <code>a</code>)<sup class="trnote" id="B_assign"
  title="a ještě jinými slovy..."><a href="#P_assign">[3]</a></sup>. 
  Jakmile si toto uvědomíte, bude již méně obtížné pochopit, co
  vlastně <code>a.append(4)</code> dělá... že mění seznam, na který se
  odkazuje jak <code>a</code> tak <code>b</code>.</p>

  <p>Domněnka, že se s měnitelnými a neměnitelnými objekty při
  přiřazování zachází rozdílně, je mylná. Při přiřazování <code>a =
  3</code> a <code>b = a</code> se děje přesně stejná věc, jako u výše
  uvedeného seznamu. Jména <code>a</code> i <code>b</code> nyní
  odkazují na stejný objekt &mdash; na číslo s hodnotou 3. Protože
  však čísla jsou neměnitelná (immutable), nepozorujete žádný vedlejší
  efekt <sup class="trnote" id="B_assign2" title="...detaily"><a 
  href="#P_assign2">[4]</a></sup>.</p>

  <p><strong>Řešení</strong>: Přečtěte si <a href=
  "http://www.py.cz/PastiJazykaPython/ObjektyJazykaPython" title="">toto</a>. Abyste se zbavili
  nechtěných vedlejších efektů, kopírujte (používejte metodu copy,
  operátory řezu (slice), atd). Python nikdy implicitně nekopíruje.</p>

  <h3>3. Operátor +=</h3>

  <p>V jazycích jako třeba C, jsou rozšířené přiřazovací operátory jako
  <code>+=</code> zkratkami pro delší výrazy. Například,</p>
<pre>
x += 42;
</pre>

  <p>je syntaktická pomůcka (angličani říkají <em>syntactic sugar</em>) 
  pro</p>
<pre>
x = x + 42;
</pre>

  <p>Takže byste si mohli myslet, že tomu tak bude i v jazyce Python. 
  Na první pohled to tak skutečně vypadá:</p>
<pre>
a = 1
a = a + 42
# a je 43
a = 1
a += 42
# a je 43
</pre>

  <p>Ale u měnitelných objektů (mutable) zápis <code>x += y</code>
  nemusí nutně vyjadřovat totéž, jako zápis
  <code>x&nbsp;=&nbsp;x&nbsp;+&nbsp;y</code>. Uvažujme seznamy:</p>
  
<pre>
&gt;&gt;&gt; z = [1, 2, 3]
&gt;&gt;&gt; id(z)
24213240
&gt;&gt;&gt; z += [4]
&gt;&gt;&gt; id(z)
24213240
&gt;&gt;&gt; z = z + [5]
&gt;&gt;&gt; id(z)
24226184
</pre>

  <p>Příkaz <code>x += y</code> mění seznam na místě a má stejný
  důsledek jako metoda <code>extend</code>. Příkaz
  <code>z&nbsp;=&nbsp;z&nbsp;+&nbsp;y</code> vytváří nový seznam a
  sváže ho se znovu použitým jménem <code>z</code>, což je ale něco
  jiného, než u předchozího příkazu. Jde o jemný rozdíl vedoucí
  k&nbsp;delikátním a těžko zachytitelným chybám.</p>

  <p>Aby toho nebylo dost, vede to také k překvapivému chování,
  když se míchají měnitelné a neměnitelné kontejnery:</p>
  <pre>
&gt;&gt;&gt; t = ([],)
&gt;&gt;&gt; t[0] += [2, 3]
Traceback (most recent call last):
  File "&lt;input&gt;", line 1, in ?
TypeError: object doesn't support item assignment
&gt;&gt;&gt; t
([2, 3],)
</pre>

  <p>N-tice, samozřejmě, nepodporují přiřazování svých prvků. Jenže po
  provedení <code>+=</code> se seznam uvnitř <b>změnil</b>! Důvod je
  opět v tom, že <code>+=</code> mění seznam na místě. Přiřazení prvku
  n-tice sice nefunguje, ale když se stane výjimka, tak prvek již byl
  na místě změněn.</p>
  
  <p>Tuto léčku já osobně považuji za vadu na kráse<sup class="trnote"
  id="B_tmod" title="Ale co je vlastně špatně?"><a
  href="#P_tmod">[5]<a class="new visualNoPrint" href="http://www.py.cz/PastiJazykaPython/createform?page=5" title="create this page">?</a></a></sup> :-).</p>

  <p><strong>Řešení</strong>: podle vašeho postoje k tomuto
  problému můžete buď se kompletně používání vyvarovat += nebo to
  používat jen pro čísla anebo se s tím naučit žít ...</p>

  <h3>4. Atributy tříd versus atributy instancí</h3>

  <p>Zde se chybuje nejméně ve dvou věcech. Tak za prvé, nováčci
  pravidelně přidávají atributy do třídy (místo do instance) a
  diví se, když jsou pak tyto atributy sdíleny mezi instancemi:</p>
  
  <pre>
&gt;&gt;&gt; class Foo:
...     bar = []
...     def __init__(self, x):
...         self.bar.append(x)
...     
&gt;&gt;&gt; f = Foo(42)
&gt;&gt;&gt; g = Foo(100)
&gt;&gt;&gt; f.bar, g.bar
([42, 100], [42, 100])
</pre>

  <p>Nejde o vadu, ale šikovný rys, kterého můžeme v řadě situací
  využít. Nepochopení vyplývá z faktu, že byly použity atributy třídy
  a ne atributy instance. Může to být i tím, že se atributy instancí v
  Pythonu vytvářejí jinak, než v dalších jazycích. V jazycích C++,
  Object Pascal a dalších se deklarují ve těle třídy.</p>

  <p>Další (malá) léčka spočívá v tom, že <code>self.foo</code> může
  odkazovat na dvě věci: na atribut instance <code>foo</code> nebo
  &mdash; pokud tento neexistuje &mdash; na atribut třídy
  <code>foo</code>. Porovnejte:</p>
  
  <pre>
&gt;&gt;&gt; class Foo:
...     a = 42
...     def __init__(self):
...         self.a = 43
...     
&gt;&gt;&gt; f = Foo()
&gt;&gt;&gt; f.a
43
</pre>

  <p>a druhý případ</p>
  <pre>
&gt;&gt;&gt; class Foo:
...     a = 42
...     
&gt;&gt;&gt; f = Foo()
&gt;&gt;&gt; f.a
42
</pre>

  <p>V prvním příkladě <code>f.a</code> odkazuje na atribut instance s
  hodnotou 43. Má přednost před atributem třídy s hodnotou 42. V
  druhém příkladě žádný atribut instance <code>a</code> neexistuje,
  takže <code>f.a</code> odkazuje na atribut třídy.</p>

  <p>Následující ukázka oba případy kombinuje:</p>
  <pre>
&gt;&gt;&gt; class Foo:
...     
...     bar = []
...     def __init__(self, x):
...         self.bar = self.bar + [x]
...     
&gt;&gt;&gt; f = Foo(42)
&gt;&gt;&gt; g = Foo(100)
&gt;&gt;&gt; f.bar
[42]
&gt;&gt;&gt; g.bar
[100]
</pre>

  <p>V příkazu <code>self.bar = self.bar + [x]</code> neodpovídají
  zápisy obou <code>self.bar</code> stejnému odkazu... Druhý zápis
  odkazuje na atribut třídy <code>bar</code>. Výsledek je poté svázán
  s atributem instance.</p>

  <p><strong>Řešení</strong>: Tento rozdíl může být matoucí, ale není
  nepochopitelný. Atributy tříd používejte v situacích, když chcete
  něco sdílet mezi více instancemi třídy. Abyste se vyhnuli
  nejednoznačnosti, můžete se na ně odkazovat zápisem
  <code>self.__class__.<em>jmeno</em></code> místo zápisu
  <code>self.<em>jmeno</em></code> i v případech, kdy neexistuje žádný
  atribut instance tohoto jména. Pro atributy, které mohou v každé
  instanci nabývat jiné hodnoty, používejte atributy instancí a
  odkazujete se na ně přes self.<em>jmeno</em>.</p>

  <p><strong>Aktualizace:</strong> Vícero lidí poznamenává, že pasti
  číslo 3 a 4 se dají kombinovat do ještě zábavnějšího hlavolamu:</p>
  
  <pre>
&gt;&gt;&gt; class Foo:
...     bar = []
...     def __init__(self, x):
...             self.bar += [x]
...             
&gt;&gt;&gt; f = Foo(42)
&gt;&gt;&gt; g = Foo(100)
&gt;&gt;&gt; f.bar
[42, 100]
&gt;&gt;&gt; g.bar
[42, 100]
</pre>

  <p>Důvod pro toto chování je ten, že
  <code>self.bar&nbsp;+=&nbsp;<em>něco</em></code> není stejné jako
  <code>self.bar&nbsp;=&nbsp;self.bar&nbsp;+&nbsp;<code>něco</code></code>.
  Zápis <code>self.bar</code> zde vyjadřuje odkaz na
  <code>Foo.bar</code>, takže <code>f</code> i <code>g</code>
  aktualizují stejný seznam.</p>

  <h3>5. Měnitelné implicitní argumenty</h3>

  <p>Tato past trápí začátečníky znovu a znovu. Ve skutečnosti to
  je varianta pasti číslo 2, kombinovaná s neočekávaným chováním
  implicitních argumentů. Uvažujme následující funkci:</p>
  <pre>
&gt;&gt;&gt; def popo(x=[]):
...     x.append(666)
...     print x
...     
&gt;&gt;&gt; popo([1, 2, 3])
[1, 2, 3, 666]
&gt;&gt;&gt; x = [1, 2]
&gt;&gt;&gt; popo(x)
[1, 2, 666]
&gt;&gt;&gt; x
[1, 2, 666]
</pre>

  <p>To se dalo čekat. Ale teď:</p>
  <pre>
&gt;&gt;&gt; popo()
[666]
&gt;&gt;&gt; popo()
[666, 666]
&gt;&gt;&gt; popo()
[666, 666, 666]
</pre>

  <p>Možná jste čekali, že výstup bude ve všech případech [666]<a class="new visualNoPrint" href="http://www.py.cz/PastiJazykaPython/createform?page=666" title="create this page">?</a>...
  vždyť když voláme popo() bez argumentů, bere se přeci [] jako
  implicitní, že jo? Ne. Implicitní argument se volá *jednou* a to
  když se funkce *vytváří* a ne když se volá. (Jinými slovy, u funkce
  <code>f(x=[])</code> se x nepřiřazuje pokaždé, když se funkce volá.
  Do <code>x</code> se přiřadí [], jen když se funkce definuje<sup
  class="trnote" id="B_mda" title="... opakování je matka
  moudrosti"><a href="#P_mda">[6]</a></sup>. Pokud se jedná o
  měnitelný objekt, a ten se změnil, bude příští volání funkce za svůj
  implicitní argument považovat stejný seznam, který už ale má jiný
  obsah.</p>

  <p><strong>Řešení</strong>: Toto chování může být někdy užitečné.
  Ale obecně byste si na tyto vedlejší efekty měli dávat pozor.</p>

  <h3>6. UnboundLocalError</h3>

  <p>Tato chyba se podle manuálu objeví v případě, kdy se jméno "odkazuje
  na lokální proměnnou, která ještě dosud nebyla navázána (bound)".
  To zní tajemně. Nejlepší to bude ukázat na malém příkladě:</p>
  <pre>
&gt;&gt;&gt; def p():
...     x = x + 2
...     
&gt;&gt;&gt; p()
Traceback (most recent call last):
  File "&lt;input&gt;", line 1, in ?
  File "&lt;input&gt;", line 2, in p
UnboundLocalError: local variable 'x' referenced before assignment
</pre>

  <p>Uvnitř <code>p</code> nemůže být výraz <code>x = x + 2</code>
  proveden, protože <code>x</code> ve výrazu <code>x + 2</code>
  ještě nemá žádnou hodnotu. To zní rozumně. Nemůžete se odkazovat
  na jméno, které ještě neexistuje. Ale zvažme následující:</p>
  <pre>
&gt;&gt;&gt; x = 2
&gt;&gt;&gt; def q():
...     print x
...     x = 3
...     print x
...     
&gt;&gt;&gt; q()
Traceback (most recent call last):
  File "&lt;input&gt;", line 1, in ?
  File "&lt;input&gt;", line 2, in q
UnboundLocalError: local variable 'x' referenced before assignment
</pre>

  <p>Tento úsek kódu by se vám mohl zdát správný -- nejprve se
  vytiskne 2 (hodnota globální proměnné x), pak se lokální proměnné x
  přiřadí 3 a její hodnota se vytiskne (3). Takhle to však nefunguje.
  Je to dáno pravidly pro rozsah viditelnosti (platnosti,
  použitelnosti jmen). Jsou vysvětlena v referenční příručce:</p>

  <blockquote>
  
    <p>Pokud je vazba jména provedena uvnitř bloku, jde o lokální
    proměnnou tohoto bloku. Pokud je vazba jména<sup class="trnote" 
    id="B_namebinding" title="Podrobnější vysvětlení..."><a 
    href="#P_namebinding">[7]</a></sup> provedena na úrovni
    modulu, jde o globální proměnnou. (Proměnné bloku kódu modulu jsou
    lokální a globální.) Pokud je proměnná použita v kódu bloku, ale
    není zde definovaná, jedná se o volnou proměnnou.</p>
    
    <p>Pokud není jméno vůbec nalezeno, vyvolá se výjimka
    <code>NameError</code>. Pokud se jméno odkazuje na lokální
    proměnnou, pro kterou dosud nebyla provedena vazba, vyvolá se
    výjimka <code>UnboundLocalError</code>.</p>
  
  </blockquote>

  <p>Jinými slovy: Uvnitř funkce může proměnná být lokální nebo
  globální, ale ne obojetná. (Nezáleží na tom, jestli později
  provedete změnu vazby.) Ve výše uvedeném příkladu Python určí, že
  proměnná <code>x</code> je lokální (na základě zmíněných pravidel).
  Ale při následném provádění funkce se narazí na příkaz
  <code>print&nbsp;x</code> a <code>x</code> ještě nemá žádnou
  hodnotu... a tudíž je to chyba.</p>

  <p>Povšimněte si, že pokud by bylo tělo funkce složeno pouze z
  jednoho řádku <code>print x</code> nebo z řádků <code>x = 3; print
  x</code> bylo by to naprosto v pořádku.</p>

  <p><strong>Řešení:</strong> Používání lokálních a globálních
  proměnných tímto způsobem nemíchejte.</p>

  <h3>7. Chyby při zaokrouhlování desetinných čísel</h3>

  <p>Při tisku hodnot desetinných čísel (float) může být výsledek
  někdy překvapující. Aby byly věci ještě zajímavějšími, mohou se
  reprezentace vracené funkcemi str() a repr() lišit. Ukázka říká
  vše:</p>
  
  <pre>
&gt;&gt;&gt; c = 0.1
&gt;&gt;&gt; c
0.10000000000000001
&gt;&gt;&gt; repr(c)
'0.10000000000000001'
&gt;&gt;&gt; str(c)
'0.1'
</pre>

  <p>V dvojkové soustavě (kterou používá procesor) nelze řadu čísel
  vyjádřit přesně. Skutečná hodnota se hodnotě zapsané v desítkové
  soustavě pouze blíží.</p>

  <p><strong>Řešení</strong>: Více informací se dozvíte z následujícího
  <a href="http://vik.sh.cvut.cz/~tnt/python/tut/node14.html">tutoriálu</a>.

  <h3>8. Spojování řetězců</h3>

  <p><strong>Poznámka překladatele:</strong> 
  Odstraněno, již neplatí.  Uvádělo se zde, že je méně výhodné několikanásobné slučování (sčítání) řetězců. 
  Místo toho se radilo převézt řetězec na seznam, pak několikanásobné append u seznamu a zpětný převod na řetězec. 
  Následující script ukazuje neplatnost tohoto pravidla u Python 2.5, pravděpodobně vlivem efektivnějšího provádění smyček při operacích s
  řetězci. 
  <pre>
import timeit

def f():
    s = ""
    for i in range(100000):
        s = s + "abcdefg"[i % 7]
    

t=timeit.Timer("f()","from __main__ import f")
print t.timeit(1)

# vysledek python 2.5: 0.0705371772111


def g():
    z = []
    for i in range(100000):
        z.append("abcdefg"[i % 7])
    return ''.join(z)
    
t=timeit.Timer("g()","from __main__ import g")
print t.timeit(1)

# vysledek python 2.5: 0.0885903096623

</pre>

  <h3>9. Binární režim pro soubory</h3>

  <p>Nebo spíše, používání binárního režimu <b>není</b> tím, co
  způsobuje zmatek. Některé operační systémy, jako Windows, dělají
  rozdíl mezi binárními a textovými soubory. Pro ilustraci si uveďme, 
  jak lze v jazyce Python otvírat soubory v binárním nebo textovém
  režimu:</p>
  
  <pre>
f1 = file(jmenosouboru, "r")  # text
f2 = file(jmenosouboru, "rb") # binárně
</pre>

  <p>V textovém režimu, mohou být řádky zakončované znakem "nová
  řádka" a/nebo "návrat vozíku" (<code>\n</code>, <code>\r</code>,
  nebo <code>\r\n</code>). Binární režim si na něco takového nehraje.
  Když ve
  Windows čteme ze soubor v textovém režimu, reprezentuje Python konce
  řádku znakem <code>\n</code> (universální). Ale v binárním režimu
  dostaneme <code>\r\n</code>. Při čtení dat proto můžeme v každém z
  těchto režimů získat velmi rozdílné výsledky.</p>

  <p>Existují systémy, které nerozlišují mezi textovým a binárním
  režimem. Například v Unixu jsou soubory otevírány vždy v binárním
  módu. Díky tomu může kód psaný pro Unix a otevírající soubor v
  režimu 'r' dávat jiné výsledky při spuštění pod Windows. Může se
  také stát, že někdo přicházející z Unixu může použít příznak 'r' i
  ve Windows a bude nemile překvapen výsledky.</p>

  <p><strong>Řešení</strong>: Používejte správné flagy &mdash; 'r' pro
  textový režim (i na Unixu), 'rb' na binární režim.</p>

  <h3>10. Zachytávání několika výjimek najednou</h3>

  <p>Někdy potřebujete v jednom <code>except</code> zachytit několik 
  výjimek v jednom. Automaticky nás napadne nás, že by mohlo fungovat
  následující:</p>
  
  <pre>
try:
    ...něco co vyvolá chybu...
except IndexError, ValueError:
    # "mělo by" zachytit chyby IndexError a ValueError
    # špatně!
</pre>

  <p>Tohle bohužel nefunguje. Důvody se stanou jasnějšími při
  porovnání s kódem:</p>
  <pre>
&gt;&gt;&gt; try:
...     1/0
... except ZeroDivisionError, e:
...     print e
...     
integer division or modulo by zero
</pre>

  <p>První "argument" v klauzuli except uvádí třídu výjimky, druhý
  uvádí volitelné jméno, které bude navázáno na aktuální objekt
  vyvolané výjimky. Takže v předchozím chybném kódu by klauzule
  <code>except</code> zachytila <code>IndexError</code> a jméno
  <code>ValueError</code> by svázala s objektem výjimky. To asi není,
  co jsme chtěli. ;-)</p>

  <p>Tohle funguje lépe:</p>
  <pre>
try:
    ...něco co vyvolá chybu...
except (IndexError, ValueError):
    # správně zachytí IndexError a ValueError
</pre>

  <p><strong>Řešení</strong>: Když odchytáváte několik výjimek v jedné
  klausuli <code>except</code>, používejte závorky na vytvoření n-tice
  s výjimkami.</p>
  
  <hr>

  <h3>Jaké další nástrahy tu jsou? Napadají mne snad:</h3>

  <ul>
    <li>zpětné lomítka v řetězcích (bez raw), obzvláště u cest
    Windows/DOS</li>

    <li>dělení celých čísel (v dalších verzích bude snad
    změněno)</li>
  </ul>

  <h3>Příbuzné odkazy:</h3>

  <ul>
    <li><a href="http://www.ferg.org/projects/python_gotchas.html"
    title="">Python Gotchas</a> od Steve Ferg</li>

    <li><a href="http://www.amk.ca/python/writing/warts.html"
    title="">Python Warts</a> od Andrew Kuchling</li>

    <li><a href="http://mechanicalcat.net/cgi-bin/log/2003/09/02#anti-pitfalls"
    title="">Python anti-pitfalls</a> od Richard Jones</li>

  </ul>



<hr>

  <p>Poznámky překladatele:</p>
  
  <table summary="Poznámky překladatele.">
  <tr id="P_indent"><td><a href="#B_indent">[1]</a></td>
  <td><em>"... Tudy cesta nevede. Vyfukováním kouře do umyvadla s vodou 
    zlato opravdu nevzniká."</em> &ndash; J.C.</td>
  </tr>
  <tr id="P_spaces"><td><a href="#B_spaces">[2]</a></td>
  <td>S mezerami nikdy problémy nebyly. S tabulátory ano. Někteří si myslí, 
    že se tabulační pozice nemají nastavovat po 8 sloupcích.</td>
  </tr>
  <tr id="P_assign"><td><a href="#B_assign">[3]</a></td>
  <td>Takže v tuto chvíli existuje jeden seznam, jeden objekt, na 
    který ukazují dvě jména.</td>
  </tr>
  <tr id="P_assign2"><td><a href="#B_assign2">[4]</a></td>
  <td>Přiřazením <code>a = 4</code> se zruší vazba na celočíselný 
   objekt s hodnotou 3 a vznikne vazba na celočíselný objekt s 
   hodnotou 4.</td>
  </tr>
  <tr id="P_tmod"><td><a href="#B_tmod">[5]</a></td>
  <td>N-tice je sice neměnná, ale udržuje pouze odkazy na jiné objekty. 
    Odkazy se skutečně měnit nemohou. Zápis <code>t[0]</code> reprezentuje
    odkaz na seznam. Nikde se ale neříká, že by n-tice nemohla obsahovat 
    odkazy na měnitelné objekty, které mohou být navíc navázány i na jiná 
    jména a tudíž měněny odjinud. Chyba tedy nespočívá v tom, že se změnil
    obsah seznamu, ale v tom, že vůbec vznikla výjimka.</td>
  </tr>
  <tr id="P_mda"><td><a href="#B_mda">[6]</a></td>
  <td>... když Python při spuštění programu poprvé kód zpracovává
    a u funkcí si zapamatovává právě tyto implicitní argumenty (a také
    proměnné i další deklarace uvnitř funkcí). Vytváří se při tom
    vnitřní objekt, který reprezentuje zkompilovanou funkci. A o tom 
    to je.</td>
  </tr>
  <tr id="P_namebinding"><td><a href="#B_namebinding">[7]</a></td>
  <td>Jak již bylo vysvětleno u <a href="#pitfall2">pasti číslo 2</a>,
    proměnnou se v Pythonu rozumí jméno, které se odkazuje na objekt.
    Přiřazením hodnoty proměnné se provede pouze svázání jména
    proměnné s uvedeným objektem tak, že se ve vnitřním slovníku
    vytvoří dvojice <em>(jméno, odkaz na objekt)</em>. Této akci se
    říká provedení vazby jména. Pokud ve vnitřním slovníku neexistuje
    položka s klíčem odpovídajícím jménu, pak vazba nebyla provedena.
    Zmíněných vnitřních slovníků, které Python využívá, je více. V
    jednom z nich jsou zachyceny vazby jmen globálních proměnných. Pro
    každou lokální úroveň je vytvořen příslušný (jiný, oddělený,
    další) vnitřní slovník.</td>
  </tr>
  </table>

</div>
      </div>
    </div>
    
  </body>

<!-- Mirrored from www.py.cz/PastiJazykaPython/diff by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 20 Mar 2016 21:03:29 GMT -->
</html>

