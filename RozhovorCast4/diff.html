<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"
      lang="en">
                         
  
<!-- Mirrored from www.py.cz/RozhovorCast4/diff by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 20 Mar 2016 21:03:42 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta http-equiv="Content-Type"
          content="text/html;charset=utf-8" />
    
    <link rel="stylesheet" type="text/css"
          href="../FrontPage/stylesheet.css" />
    <title>PyCZ: Programovací jazyk Python, aplikační servery a frameworky, atd. RozhovorCast4</title>
    
    
    <meta name="robots" content="noindex,nofollow" />
  
  
  </head>
  <body>
    
    <div>
      <div id="pageheaderall" class="pageheader">
      <div id="accesskeys">
      <a accesskey="0"
         href="http://www.py.cz/RozhovorCast4/helpaccesskeys"></a>
      <a accesskey="f" href="http://www.py.cz/FrontPage"></a>
      <a accesskey="c"
         href="http://www.py.cz/FrontPage/contents#RozhovorCast4"></a>
      <a accesskey="r"
         href="http://www.py.cz/FrontPage/recentchanges"></a>
      <a accesskey="" href="http://www.py.cz/FrontPage"></a>
      
      <a accesskey="i"
         href="http://www.py.cz/FrontPage/wikiindex"></a>
      
      <a accesskey="o"
         href="http://www.py.cz/FrontPage/useroptions?redirectURL=http%3A//www.py.cz/RozhovorCast4"></a>
      <a accesskey="h" href="http://www.py.cz/HelpPage"></a>
      
      
      <a accesskey="n" href="http://www.py.cz/RozhovorCast5"></a>
      <a accesskey="p" href="http://www.py.cz/RozhovorCast3"></a>
      <a accesskey="u"
         href="http://www.py.cz/RozhovorGuidoVanRossum"></a>
      <a accesskey="v" href="http://www.py.cz/RozhovorCast4"></a>
      <a accesskey="m"
         href="http://www.py.cz/RozhovorCast4/subscribeform"></a>
      <a accesskey="b"
         href="http://www.py.cz/RozhovorCast4/backlinks"></a>
      <a accesskey="d"
         href="http://www.py.cz/RozhovorCast4/diff"></a>
      <a accesskey="y"
         href="http://www.py.cz/RozhovorCast4/history"></a>
      <a accesskey="e"
         href="http://www.py.cz/RozhovorCast4/editform"></a>
      
    </div>
      <div id="navlinks" class="linkpanel">
      <table class="shade1" width="100%" border="0" cellspacing="0">
        <tr>
          <td align="right">
            
      <a href="http://www.py.cz/FrontPage"
         title="show front page">
      <span>home</span></a>
      <a href="http://www.py.cz/FrontPage/contents#RozhovorCast4"
         title="show wiki contents">
      <span>contents</span></a>
      <a href="http://www.py.cz/FrontPage/recentchanges"
         title="show wiki recent changes">
      <span>changes</span></a>
      
      <a title="show wiki index"
         href="http://www.py.cz/FrontPage/wikiindex">
      <span>index</span></a>
      
      <a title="show wiki options"
         href="http://www.py.cz/FrontPage/useroptions?redirectURL=http%3A//www.py.cz/RozhovorCast4">
      <span>options</span></a>
      <a title="show help page"
         href="http://www.py.cz/HelpPage">
      <span>help</span></a>
    
            
      
      <a href="http://www.py.cz/RozhovorCast4/subscribeform"
         title="configure email subscription to this page or site">
        
      <span>subscribe</span></a>
      
      <a href="http://www.py.cz/RozhovorCast4/editform"
         title="edit-page (last edited 10 years ago by pycz)">
      <span>edit</span></a>
      
    
          </td>
        </tr>
      </table>
    </div>
      <div id="pageheader">
        <form method="GET"
              action="http://www.py.cz/FrontPage/searchwiki">
          <table width="100%" border="0" cellspacing="0">
            <tr>
              <!-- logo -->
              <td id="logo" width="1%" valign="top"
                  class="logo">
                
                  <a title="go to home page"
                     href="http://www.py.cz/FrontPage">
                    
                    <img src="http://www.py.cz/RozhovorCast4/logo.jpg" border="0" alt="home" />
                    
                  </a>
                  &nbsp;
                
              </td>
              <!-- page name and context (parent topics) -->
              <td align="left" width="79%">
                
                  <small><ul class="outline expandable">
 <li><a href="http://www.py.cz/PythonRoot" name="PythonRoot">PythonRoot</a>
<ul class="outline expandable">
  <li><a href="http://www.py.cz/RozhovoryPrednasky" name="RozhovoryPrednasky">RozhovoryPrednasky</a>
<ul class="outline expandable">
   <li><a href="http://www.py.cz/RozhovorGuidoVanRossum" name="RozhovorGuidoVanRossum">RozhovorGuidoVanRossum</a>
<ul class="outline expandable">
   <li><h1 style="display:inline;"><a href="http://www.py.cz/RozhovorCast4/backlinks" title="which pages link to this one ?" name="RozhovorCast4">RozhovorCast4</a></h1></li>
</ul>
   </li>
</ul>
  </li>
</ul>
 </li>
</ul>
</small>
                
                
              </td>
              <!-- search form & page info -->
              <td class="searchbox" width="20%" align="right">
                
                  <input id="searchinput" class="formfield"
                         name="expr" type="text" size="20"
                         maxlength="100" value=""
                         title="search all pages" /><br />
                  <span class="lasteditor">last edited  <a href="http://www.py.cz/RozhovorCast4/history" title="show last edit" >10 years</a> ago by <b>pycz</b></span><br>
                  <span class="creator">created 2005-10-05</span>   
                
                
              </td>
            </tr>
          </table>
        </form>
      </div>
      <div id="ratingform" align="right">  
      <!-- page rating form -->
      <div>
        <a name="ratingform"></a>
        <style type="text/css">
          input.rating {border:none;}
        </style>
        <form method="POST" id="ratingform"
              action="http://www.py.cz/RozhovorCast4/vote">
           <input type="image" name="vote0" value="0"
                  alt="0" class="rating" width="14"
                  height="13"
                  src="http://www.py.cz/p_/sp"
                  style=""
                  title="click to vote 0 (poor) for this page (0 votes)" /><input
    type="image" name="vote1" value="1" alt="1"
    class="rating" src="http://www.py.cz/RozhovorCast4/misc_/ZWiki/star_icon" style=""
    title="click to vote 1 (average) for this page (0 votes)" /><input
    type="image" name="vote2" value="2" alt="2"
    class="rating" src="http://www.py.cz/RozhovorCast4/misc_/ZWiki/blank_star_icon"
    style=""
    title="click to vote 2 (above average) for this page (0 votes)" /><input
    type="image" name="vote3" value="3" alt="3"
    class="rating" src="http://www.py.cz/RozhovorCast4/misc_/ZWiki/blank_star_icon"
    style=""
    title="click to vote 3 (good) for this page (0 votes)" /><input
    type="image" name="vote4" value="4" alt="4"
    class="rating" src="http://www.py.cz/RozhovorCast4/misc_/ZWiki/blank_star_icon"
    style=""
    title="click to vote 4 (great) for this page (0 votes)" /><input
    type="image" name="vote5" value="5" alt="5"
    class="rating" src="http://www.py.cz/RozhovorCast4/misc_/ZWiki/blank_star_icon"
    style=""
    title="click to vote 5 (superb) for this page (0 votes)" />
        </form>
      </div>
    </div>
    </div>
      <h1>Edit detail for RozhovorCast4 revision 1 of 1</h1>
      <div class="formcontent">
        <table border="0" cellspacing="0" width="100%">
          <tr valign="top">

            <td align="left">
              <form style="display:inline"
                    action="http://www.py.cz/RozhovorCast4">
                <input type="submit" name="history:method"
                       value="Return to edit history" />
                
              </form>
            </td>

            <td align="center">
              <form style="display:inline"
                    action="http://www.py.cz/RozhovorCast4/diff">
                <input type="hidden" name="rev" />
                
                <input disabled="1" value=" &lt; "
                       type="submit" accesskey="," />
              </form>
              <a style="font-weight:bold"
                 href="http://www.py.cz/RozhovorCast4/diff?rev=1">1</a>
              <form style="display:inline"
                    action="http://www.py.cz/RozhovorCast4/diff">
                <input type="hidden" name="rev" />
                
                <input disabled="1" value=" &gt; "
                       type="submit" accesskey="." />
              </form>
            </td>

            <td align="right">
              <form style="display:inline"
                    action="http://www.py.cz/RozhovorCast4">
                <input type="hidden" name="rev" value="1" />
                <input value="Revert to this version"
                       type="submit" name="revert:method"
                       disabled="disabled" />
              </form>
            </td>

          </tr>
          <tr valign="top">
            <td colspan="3">
              <span>Editor:</span> pycz
              <br />
              <span>Time:</span> 2005/10/05 08:35:06 GMT+0
            </td>
          </tr>
          <tr valign="top">
            <td colspan="3">
              <span>Note:</span> <span
    style="font-weight:bold; font-style:italic;"></span>
            </td>
          </tr>
        </table>
        <hr />
        <pre>
<b>changed:</b><span style="color:red;text-decoration:line-through">
-</span><span style="color:green">
Rozhovor s Guido van Rossumem, část 4.
======================================

Autor jazyka Python Guido van Rossum odpovídá na otázky Billa Vennera o
historii Pythonu, o vlivu jazyka ABC na vývoj Pythonu a o hlavních cílech
při vývoji Pythonu.

Originál rozhovoru je dostupný na http://www.artima.com/intv/guido.html .

:Author: `Jan Švec &lt;mailto:honza(at)py(dot)cz&gt;`_
:Date: 2005-10-05
:Copyright: Copyright (C) 2004-2005 `Jan Švec &lt;mailto:honza(at)py(dot)cz&gt;`_


Metody a &quot;vazby&quot;
----------------

**Bill Venners**:
Jedním z přínosů objektově orientovaného programování je oddělení rozhraní a
implementace. Protože klientův kód je svázán pouze s rohraním, mohu libovolně
měnit implementaci metod nebo soukromých dat. To mohu provádět aniž bych změnil
funkčnost již existujícího kódu. Klientův kód je svázán jen s definicí metody,
která defacto vytváří ono rozhraní. Proto je oddělení rozhraní a implementace
metod technikou, která umožňuje změny v kódu metodu a zaručuje nulové provázání
mezi soukromým kódem metody a kódem klienta.

To ale vyžaduje jak od programátora, který definuje rozhraní a implementuje
metody, tak od programátora, jenž píše klientský kód, aby věděli, co která
metoda s daným rozhraním provádí. Rozhraní tedy znamená vazbu mezi kódem a
implementací rozhraní. Jestliže metoda &lt;code&gt;add&lt;/code&gt; sčítá dvě čísla, mohu
upravit její kód za účelem efektivnější implementace, samotná metoda ale stále
sčítat! Pokud začne jedno číslo odčítat od druhého, přestane veškerý kód
používající tuto metodu pracovat správně, přestože překlad tohoto kódu proběhne
v pořádku.

Ve volně typovém prostředí, jakým Python je, nemají proměnné žádný typ.
Napíši-li metodu, jež bude přebírat dva parametry, `x` a `y` a za běhu zavolám
nějakou metodu parametru `x`, bude vše bez problémů, pokud objekt odkazovaný
tímto parametrem bude mít takto deklarovanou metodu. Nemusím však ale nutně
vědět, co tato metoda provádí.

V silně typových jazycích má každá proměnná typ známý již v čase překladu.
Pokud se pokusím zavolat metodu nějaké proměnné, ale její typ tuto metodu
nedeklaruje, překladač ohlásí chybu při překladu. To je rozdíl v chování volně
(též slabě) a silně typových jazyků. V silně typových jazycích přijdu na
některé chyby již v čase překladu, zatímco ve volně typovém prostředí budu
doufat, že případnou chybu objevím za běhu programu. V silně typových jazycích
typ proměnné popisuje její rozhraní -- rozhraní objektu.  Toto rozhraní určuje
nejen, které metody konkrétní objekt deklaruje, ale také význam jednotlivých
metod.

Například dva objekty `Artista` a `Pistolnik` budou mít metodu deklarovanou
jako `void kresli()`. Tato metoda objektu `Artista` nakreslí cvičícího človíčka
zatímco táž metoda objektu `Pistolnik` nakreslí jeho střílející pistole.  V
silně typovém jazyce si dokážu udělat představu o významu jednotlivých volání
(tj. zda objekt bude kreslit figurky nebo pistole) pouhým pohledem na typ
proměnné.  Znám-li typ objektu, znám i význam metody `kresli`. V jazycích jako
je Python, které objektům přiřazují typ až za běhu programu, lze také zjistit
význam `kresli` pomocí typu objektu, který získám za běhu programu, což se v
praxi příliš nepoužívá. V Pythonu totiž nikdy nemusíte kontrolovat typy
objektů, pouze zavoláte metodu `kresli`, které přiřadíte nějaký konkrétní
význam. Tímto &quot;domyšlením&quot; významu ovšem ztratíte záruku, že se opravdu provede
to, co očekáváte.

Proč to v praxi funguje? Proč programy v Pythonu pracují, když nelze zjistit,
která konkrétní metoda se zavolá při vykonání programu?

**Guido van Rossum**:
To mi připadá jako neopodstatněný strach. Z mých zkušeností je navržení
rozhraní často ta nejtěžší část při práci na programu.  Flexibilní návrh,
umožňující změny implementace objektu bez změn jeho rozhraní, se uplatní pouze
v určitých oblastech. Pokud potřebujete seřadit poštovní směrovací čísla,
můžete například napsat jednoduchý řadicí algoritmus. Pokud později zjistíte,
že vaše původní implementace není dostatečně rychlá, můžete na ní dále
pracovat. To je klasický způsob použití rozhraní.

Ale v mnoha situacích se po navržení rozhraní zjistí, například při práci na
další verzi programu, že je navrženo nevhodně. Některé potřebné informace jsou
například drženy jako soukromé, případně některá data nikdy neopustí metodu,
přestože by se hodila jejímu klientovi, některá jsou data nadbytečná atd.

Python má implicitní vazby
--------------------------

**Bill Venners**:
Podle mé teorie se v Pythonu v 99 procentech všech funkčních volání vykoná
přesně to, co očekávám. Jestliže metodu zavolám v silně typovém jazyce, ve 1
procentu případů může chyba nebo špatné pochopení rozhraní této metody
způsobit, že se vykoná něco nepředvídatelného.  Přestože v silných jazycích je
každá vazba odvozená od typu proměnné, neznamená to, že lidé tyto vazby
neporušují. Vazby často se porušují díky chybám a nepochopením rozhraní. Myslím
si, že jak v silně, tak ve slabě typových jazycích, je frekvence výskytu
situací, kdy metoda dělá něco nepředvídatelného, úplně stejná a většina chyb
může být odkryta a opravena již během testování.

**Guido van Rossum**:
Předám-li v Pythonu argument nějaké metodě, nevím, co je tento argument zač.
Předpokládám však, že podporuje metodu `readline`, zavolám ji tedy.  Nyní
předpokládejme, že objekt tuto metodu nepodporuje...

**Bill Venners**:
... dostanu výjimku ...

**Guido van Rossum**:
Dostanete výjimku, což je pravděpodobně v pořádku.  Jestliže se jedná o hlavní
část kódu a někdo mu předá objekt, který nemá metodu `readline`, zjistíte to
již během testování tohoto kódu.  Stejně jako v typových jazycích v případě,
kdy určitý objekt nevyhovuje požadovanému rozhraní. Podobně během testování
objevíte i výjimky, které se z vašeho kódu neočekávaně šíří.

V Pythonu však můžete díky tomu, že postrádá fixní protokoly, předat i jakýkoli
jiný objekt implementující metodu `readline` a nemusí to být jen soubor, ale
klidně váš vlastní objekt provádějící specifickou činnost.  Jediné, co
potřebujete je, aby tento objekt vracel jednotlivé řádky stejně jako metoda
`readline` souborového objektu.

**Bill Venners**:
Ale to také mohu předat cokoli, co sice má metodu `readline`, ale provádějící
něco úplně jiného.

**Guido van Rossum**:
V Pythonu obecně vazby existují, ale nejsou implicitní. Vazba není
specifikována rozhraním. Neexistují typy, podle nichž by se parser rozhodoval,
může pouze přinejlepším říci, že objekt `x` podporuje metodu `readline`, kterou
můžete volat bez argumentů a vrací řetězec znamenající určitou věc. Vazbu ale
konkrétně určuje pouze specifikace nebo dokumentace.

Řeknete-li v Javě, že něco má metodu `readline`, která vrací řetězec, co to
znamená? Předpokládáte, že vrací stále stejný řetězec? Může vrátit prázdný
řetězec? Mnoho věcí vám však rozhraní nezaručí, musí se blíže specifikovat
právě v dokumentaci.

Je kód vazbou?
--------------

**Bill Venners**:
V knize *Learning Python* (O'Reilly, 1999)
Mark Lutz a David Ascher vykládají metody a uvádějí následující příklad,
metodu `times(x, y)`, která vrátí `x * y`::

	&gt;&gt;&gt; def times(x, y):
	...    return x * y
	...

Autoři pak ukáží dva příklady vyvolání metody `times`, jeden který používá dva
integery a jeden používající řetězec a integer::

	&gt;&gt;&gt; times(2, 4)
	8
	&gt;&gt;&gt; times('Ni', 4)
	'NiNiNiNi'

Jinými slovy, pokud jí předáte čísla 2 a 4, metoda `times` vrátí 8.  Když je
předán řetězec `'Ni'` a číslo 4, pak `times` vrátí `'NiNiNiNi'`, jelikož
operátor `*` aplikovaný na posloupnosti (například řetězce nebo seznamy)
znamená opakování této posloupnosti.  Autoři to komentují slovy: &quot;Připomeňme
si, že `*` pracuje jak na číslech, tak na posloupnostech; protože v metodách
neexistuje deklarace typů, můžete používat `times` jak na vynásobení čísel, tak
pro opakování posloupností.&quot;

Nedělá neexistence deklarování typů parametrů jednotlivých metod změny kódu
těžšími, obzvláště pak ve standardních knihovnách? Lidé přece mohou definovat
novou třídu a v ní přetížit operátor `*` tak, že bude provádět cokoli jiného.
Poté mohou předat instanci této třídy metodě `times` a použít tak metodu
`times` způsobem, který její autor nikdy neuvažoval, což je způsobeno změnou
významu operátoru `*`. Jestliže mohu změnit způsob, jakým metoda `times`
pracuje, mohu přece způsobit její chybnou funkci.  Není pak vazbou vlastně
soukromý kód metody, který by měl zůstat skrytý?

**Guido van Rossum**:
Na začátek, pokud píšete standardní knihovnu, je těžké měnit metody nebo
operace, které používáte na argumenty předávané metodám. Nemyslím si, že je to
specifikum volně typových jazyků.

To, co klient metodě předá, čili ona vazba, je mnohem více omezena v silně
typových jazycích. Tento způsob omezení je někdy výhodný, poněvadž se vám
zužuje množina rozhraní, kterou je třeba uvažovat. Vše se ale stane obtížnější,
když se v příští verzi rozhodnete používat více vlastností určitého objektu,
které však zatím nejsou součástí jeho rozhraní. Pokud nechcete změnit rozhraní
vaší metody, stane se pro vás změna nemožnou.

Obsah
=====
 + RozhovorCast1 - Historie Pythonu
 + RozhovorCast2 - Cíle a návrh Pythonu
 + RozhovorCast3 - Rapidní vývoj v Pythonu
 + RozhovorCast4 - Závazky v programování
 + RozhovorCast5 - Statické vs. dynamické typování
 + RozhovorCast6 - Veřejné API jazyka Python

</span>
</pre>
        <hr />
        <div><div class="section" id="rozhovor-s-guido-van-rossumem-cast-4">
<h2>Rozhovor s Guido van Rossumem, část 4.</h2>
<p>Autor jazyka Python Guido van Rossum odpovídá na otázky Billa Vennera o
historii Pythonu, o vlivu jazyka ABC na vývoj Pythonu a o hlavních cílech
při vývoji Pythonu.</p>
<p>Originál rozhovoru je dostupný na <a class="reference external" href="http://www.artima.com/intv/guido.html">http://www.artima.com/intv/guido.html</a> .</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Author:</th><td class="field-body"><a class="reference external" href="mailto:honza(at)py(dot)cz">Jan Švec</a></td>
</tr>
<tr class="field"><th class="field-name">Date:</th><td class="field-body">2005-10-05</td>
</tr>
<tr class="field"><th class="field-name">Copyright:</th><td class="field-body">Copyright (C) 2004-2005 <a class="reference external" href="mailto:honza(at)py(dot)cz">Jan Švec</a></td>
</tr>
</tbody>
</table>
<div class="section" id="metody-a-vazby">
<h3>Metody a &quot;vazby&quot;</h3>
<p><strong>Bill Venners</strong>:
Jedním z přínosů objektově orientovaného programování je oddělení rozhraní a
implementace. Protože klientův kód je svázán pouze s rohraním, mohu libovolně
měnit implementaci metod nebo soukromých dat. To mohu provádět aniž bych změnil
funkčnost již existujícího kódu. Klientův kód je svázán jen s definicí metody,
která defacto vytváří ono rozhraní. Proto je oddělení rozhraní a implementace
metod technikou, která umožňuje změny v kódu metodu a zaručuje nulové provázání
mezi soukromým kódem metody a kódem klienta.</p>
<p>To ale vyžaduje jak od programátora, který definuje rozhraní a implementuje
metody, tak od programátora, jenž píše klientský kód, aby věděli, co která
metoda s daným rozhraním provádí. Rozhraní tedy znamená vazbu mezi kódem a
implementací rozhraní. Jestliže metoda &lt;code&gt;add&lt;/code&gt; sčítá dvě čísla, mohu
upravit její kód za účelem efektivnější implementace, samotná metoda ale stále
sčítat! Pokud začne jedno číslo odčítat od druhého, přestane veškerý kód
používající tuto metodu pracovat správně, přestože překlad tohoto kódu proběhne
v pořádku.</p>
<p>Ve volně typovém prostředí, jakým Python je, nemají proměnné žádný typ.
Napíši-li metodu, jež bude přebírat dva parametry, <cite>x</cite> a <cite>y</cite> a za běhu zavolám
nějakou metodu parametru <cite>x</cite>, bude vše bez problémů, pokud objekt odkazovaný
tímto parametrem bude mít takto deklarovanou metodu. Nemusím však ale nutně
vědět, co tato metoda provádí.</p>
<p>V silně typových jazycích má každá proměnná typ známý již v čase překladu.
Pokud se pokusím zavolat metodu nějaké proměnné, ale její typ tuto metodu
nedeklaruje, překladač ohlásí chybu při překladu. To je rozdíl v chování volně
(též slabě) a silně typových jazyků. V silně typových jazycích přijdu na
některé chyby již v čase překladu, zatímco ve volně typovém prostředí budu
doufat, že případnou chybu objevím za běhu programu. V silně typových jazycích
typ proměnné popisuje její rozhraní -- rozhraní objektu.  Toto rozhraní určuje
nejen, které metody konkrétní objekt deklaruje, ale také význam jednotlivých
metod.</p>
<p>Například dva objekty <cite>Artista</cite> a <cite>Pistolnik</cite> budou mít metodu deklarovanou
jako <cite>void kresli()</cite>. Tato metoda objektu <cite>Artista</cite> nakreslí cvičícího človíčka
zatímco táž metoda objektu <cite>Pistolnik</cite> nakreslí jeho střílející pistole.  V
silně typovém jazyce si dokážu udělat představu o významu jednotlivých volání
(tj. zda objekt bude kreslit figurky nebo pistole) pouhým pohledem na typ
proměnné.  Znám-li typ objektu, znám i význam metody <cite>kresli</cite>. V jazycích jako
je Python, které objektům přiřazují typ až za běhu programu, lze také zjistit
význam <cite>kresli</cite> pomocí typu objektu, který získám za běhu programu, což se v
praxi příliš nepoužívá. V Pythonu totiž nikdy nemusíte kontrolovat typy
objektů, pouze zavoláte metodu <cite>kresli</cite>, které přiřadíte nějaký konkrétní
význam. Tímto &quot;domyšlením&quot; významu ovšem ztratíte záruku, že se opravdu provede
to, co očekáváte.</p>
<p>Proč to v praxi funguje? Proč programy v Pythonu pracují, když nelze zjistit,
která konkrétní metoda se zavolá při vykonání programu?</p>
<p><strong>Guido van Rossum</strong>:
To mi připadá jako neopodstatněný strach. Z mých zkušeností je navržení
rozhraní často ta nejtěžší část při práci na programu.  Flexibilní návrh,
umožňující změny implementace objektu bez změn jeho rozhraní, se uplatní pouze
v určitých oblastech. Pokud potřebujete seřadit poštovní směrovací čísla,
můžete například napsat jednoduchý řadicí algoritmus. Pokud později zjistíte,
že vaše původní implementace není dostatečně rychlá, můžete na ní dále
pracovat. To je klasický způsob použití rozhraní.</p>
<p>Ale v mnoha situacích se po navržení rozhraní zjistí, například při práci na
další verzi programu, že je navrženo nevhodně. Některé potřebné informace jsou
například drženy jako soukromé, případně některá data nikdy neopustí metodu,
přestože by se hodila jejímu klientovi, některá jsou data nadbytečná atd.</p>
</div>
<div class="section" id="python-ma-implicitni-vazby">
<h3>Python má implicitní vazby</h3>
<p><strong>Bill Venners</strong>:
Podle mé teorie se v Pythonu v 99 procentech všech funkčních volání vykoná
přesně to, co očekávám. Jestliže metodu zavolám v silně typovém jazyce, ve 1
procentu případů může chyba nebo špatné pochopení rozhraní této metody
způsobit, že se vykoná něco nepředvídatelného.  Přestože v silných jazycích je
každá vazba odvozená od typu proměnné, neznamená to, že lidé tyto vazby
neporušují. Vazby často se porušují díky chybám a nepochopením rozhraní. Myslím
si, že jak v silně, tak ve slabě typových jazycích, je frekvence výskytu
situací, kdy metoda dělá něco nepředvídatelného, úplně stejná a většina chyb
může být odkryta a opravena již během testování.</p>
<p><strong>Guido van Rossum</strong>:
Předám-li v Pythonu argument nějaké metodě, nevím, co je tento argument zač.
Předpokládám však, že podporuje metodu <cite>readline</cite>, zavolám ji tedy.  Nyní
předpokládejme, že objekt tuto metodu nepodporuje...</p>
<p><strong>Bill Venners</strong>:
... dostanu výjimku ...</p>
<p><strong>Guido van Rossum</strong>:
Dostanete výjimku, což je pravděpodobně v pořádku.  Jestliže se jedná o hlavní
část kódu a někdo mu předá objekt, který nemá metodu <cite>readline</cite>, zjistíte to
již během testování tohoto kódu.  Stejně jako v typových jazycích v případě,
kdy určitý objekt nevyhovuje požadovanému rozhraní. Podobně během testování
objevíte i výjimky, které se z vašeho kódu neočekávaně šíří.</p>
<p>V Pythonu však můžete díky tomu, že postrádá fixní protokoly, předat i jakýkoli
jiný objekt implementující metodu <cite>readline</cite> a nemusí to být jen soubor, ale
klidně váš vlastní objekt provádějící specifickou činnost.  Jediné, co
potřebujete je, aby tento objekt vracel jednotlivé řádky stejně jako metoda
<cite>readline</cite> souborového objektu.</p>
<p><strong>Bill Venners</strong>:
Ale to také mohu předat cokoli, co sice má metodu <cite>readline</cite>, ale provádějící
něco úplně jiného.</p>
<p><strong>Guido van Rossum</strong>:
V Pythonu obecně vazby existují, ale nejsou implicitní. Vazba není
specifikována rozhraním. Neexistují typy, podle nichž by se parser rozhodoval,
může pouze přinejlepším říci, že objekt <cite>x</cite> podporuje metodu <cite>readline</cite>, kterou
můžete volat bez argumentů a vrací řetězec znamenající určitou věc. Vazbu ale
konkrétně určuje pouze specifikace nebo dokumentace.</p>
<p>Řeknete-li v Javě, že něco má metodu <cite>readline</cite>, která vrací řetězec, co to
znamená? Předpokládáte, že vrací stále stejný řetězec? Může vrátit prázdný
řetězec? Mnoho věcí vám však rozhraní nezaručí, musí se blíže specifikovat
právě v dokumentaci.</p>
</div>
<div class="section" id="je-kod-vazbou">
<h3>Je kód vazbou?</h3>
<p><strong>Bill Venners</strong>:
V knize <em>Learning Python</em> (O'Reilly, 1999)
Mark Lutz a David Ascher vykládají metody a uvádějí následující příklad,
metodu <cite>times(x, y)</cite>, která vrátí <cite>x * y</cite>:</p>
<pre class="literal-block">
&gt;&gt;&gt; def times(x, y):
...    return x * y
...
</pre>
<p>Autoři pak ukáží dva příklady vyvolání metody <cite>times</cite>, jeden který používá dva
integery a jeden používající řetězec a integer:</p>
<pre class="literal-block">
&gt;&gt;&gt; times(2, 4)
8
&gt;&gt;&gt; times('Ni', 4)
'NiNiNiNi'
</pre>
<p>Jinými slovy, pokud jí předáte čísla 2 a 4, metoda <cite>times</cite> vrátí 8.  Když je
předán řetězec <cite>'Ni'</cite> a číslo 4, pak <cite>times</cite> vrátí <cite>'NiNiNiNi<a class="new visualNoPrint" href="http://www.py.cz/RozhovorCast4/createform?page=NiNiNiNi" title="create this page">?</a>'</cite>, jelikož
operátor <cite>*</cite> aplikovaný na posloupnosti (například řetězce nebo seznamy)
znamená opakování této posloupnosti.  Autoři to komentují slovy: &quot;Připomeňme
si, že <cite>*</cite> pracuje jak na číslech, tak na posloupnostech; protože v metodách
neexistuje deklarace typů, můžete používat <cite>times</cite> jak na vynásobení čísel, tak
pro opakování posloupností.&quot;</p>
<p>Nedělá neexistence deklarování typů parametrů jednotlivých metod změny kódu
těžšími, obzvláště pak ve standardních knihovnách? Lidé přece mohou definovat
novou třídu a v ní přetížit operátor <cite>*</cite> tak, že bude provádět cokoli jiného.
Poté mohou předat instanci této třídy metodě <cite>times</cite> a použít tak metodu
<cite>times</cite> způsobem, který její autor nikdy neuvažoval, což je způsobeno změnou
významu operátoru <cite>*</cite>. Jestliže mohu změnit způsob, jakým metoda <cite>times</cite>
pracuje, mohu přece způsobit její chybnou funkci.  Není pak vazbou vlastně
soukromý kód metody, který by měl zůstat skrytý?</p>
<p><strong>Guido van Rossum</strong>:
Na začátek, pokud píšete standardní knihovnu, je těžké měnit metody nebo
operace, které používáte na argumenty předávané metodám. Nemyslím si, že je to
specifikum volně typových jazyků.</p>
<p>To, co klient metodě předá, čili ona vazba, je mnohem více omezena v silně
typových jazycích. Tento způsob omezení je někdy výhodný, poněvadž se vám
zužuje množina rozhraní, kterou je třeba uvažovat. Vše se ale stane obtížnější,
když se v příští verzi rozhodnete používat více vlastností určitého objektu,
které však zatím nejsou součástí jeho rozhraní. Pokud nechcete změnit rozhraní
vaší metody, stane se pro vás změna nemožnou.</p>
</div>
</div>
<div class="section" id="obsah">
<h2>Obsah</h2>
<blockquote>
<ul class="simple">
<li><a href="http://www.py.cz/RozhovorCast1">RozhovorCast1</a> - Historie Pythonu</li>
<li><a href="http://www.py.cz/RozhovorCast2">RozhovorCast2</a> - Cíle a návrh Pythonu</li>
<li><a href="http://www.py.cz/RozhovorCast3">RozhovorCast3</a> - Rapidní vývoj v Pythonu</li>
<li><a href="http://www.py.cz/RozhovorCast4">RozhovorCast4</a> - Závazky v programování</li>
<li><a href="http://www.py.cz/RozhovorCast5">RozhovorCast5</a> - Statické vs. dynamické typování</li>
<li><a href="http://www.py.cz/RozhovorCast6">RozhovorCast6</a> - Veřejné API jazyka Python</li>
</ul>
</blockquote>
<p>
</p>
</div>
</div>
      </div>
    </div>
    
  </body>

<!-- Mirrored from www.py.cz/RozhovorCast4/diff by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 20 Mar 2016 21:03:42 GMT -->
</html>

