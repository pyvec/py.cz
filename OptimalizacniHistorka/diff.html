<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"
      lang="en">
                         
  
<!-- Mirrored from www.py.cz/OptimalizacniHistorka/diff by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 20 Mar 2016 21:03:36 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta http-equiv="Content-Type"
          content="text/html;charset=utf-8" />
    
    <link rel="stylesheet" type="text/css"
          href="../FrontPage/stylesheet.css" />
    <title>PyCZ: Programovací jazyk Python, aplikační servery a frameworky, atd. OptimalizacniHistorka</title>
    
    
    <meta name="robots" content="noindex,nofollow" />
  
  
  </head>
  <body>
    
    <div>
      <div id="pageheaderall" class="pageheader">
      <div id="accesskeys">
      <a accesskey="0"
         href="http://www.py.cz/OptimalizacniHistorka/helpaccesskeys"></a>
      <a accesskey="f" href="http://www.py.cz/FrontPage"></a>
      <a accesskey="c"
         href="http://www.py.cz/FrontPage/contents#OptimalizacniHistorka"></a>
      <a accesskey="r"
         href="http://www.py.cz/FrontPage/recentchanges"></a>
      <a accesskey="" href="http://www.py.cz/FrontPage"></a>
      
      <a accesskey="i"
         href="http://www.py.cz/FrontPage/wikiindex"></a>
      
      <a accesskey="o"
         href="http://www.py.cz/FrontPage/useroptions?redirectURL=http%3A//www.py.cz/OptimalizacniHistorka"></a>
      <a accesskey="h" href="http://www.py.cz/HelpPage"></a>
      
      
      <a accesskey="n"
         href="http://www.py.cz/RozhovorGuidoVanRossum"></a>
      <a accesskey="p"
         href="http://www.py.cz/KKYSeminarPython"></a>
      <a accesskey="u"
         href="http://www.py.cz/RozhovoryPrednasky"></a>
      <a accesskey="v"
         href="http://www.py.cz/OptimalizacniHistorka"></a>
      <a accesskey="m"
         href="http://www.py.cz/OptimalizacniHistorka/subscribeform"></a>
      <a accesskey="b"
         href="http://www.py.cz/OptimalizacniHistorka/backlinks"></a>
      <a accesskey="d"
         href="http://www.py.cz/OptimalizacniHistorka/diff"></a>
      <a accesskey="y"
         href="http://www.py.cz/OptimalizacniHistorka/history"></a>
      <a accesskey="e"
         href="http://www.py.cz/OptimalizacniHistorka/editform"></a>
      
    </div>
      <div id="navlinks" class="linkpanel">
      <table class="shade1" width="100%" border="0" cellspacing="0">
        <tr>
          <td align="right">
            
      <a href="http://www.py.cz/FrontPage"
         title="show front page">
      <span>home</span></a>
      <a href="http://www.py.cz/FrontPage/contents#OptimalizacniHistorka"
         title="show wiki contents">
      <span>contents</span></a>
      <a href="http://www.py.cz/FrontPage/recentchanges"
         title="show wiki recent changes">
      <span>changes</span></a>
      
      <a title="show wiki index"
         href="http://www.py.cz/FrontPage/wikiindex">
      <span>index</span></a>
      
      <a title="show wiki options"
         href="http://www.py.cz/FrontPage/useroptions?redirectURL=http%3A//www.py.cz/OptimalizacniHistorka">
      <span>options</span></a>
      <a title="show help page"
         href="http://www.py.cz/HelpPage">
      <span>help</span></a>
    
            
      
      <a href="http://www.py.cz/OptimalizacniHistorka/subscribeform"
         title="configure email subscription to this page or site">
        
      <span>subscribe</span></a>
      
      <a href="http://www.py.cz/OptimalizacniHistorka/editform"
         title="edit-page (last edited 6 years ago by stibi)">
      <span>edit</span></a>
      
    
          </td>
        </tr>
      </table>
    </div>
      <div id="pageheader">
        <form method="GET"
              action="http://www.py.cz/FrontPage/searchwiki">
          <table width="100%" border="0" cellspacing="0">
            <tr>
              <!-- logo -->
              <td id="logo" width="1%" valign="top"
                  class="logo">
                
                  <a title="go to home page"
                     href="http://www.py.cz/FrontPage">
                    
                    <img src="http://www.py.cz/OptimalizacniHistorka/logo.jpg" border="0" alt="home" />
                    
                  </a>
                  &nbsp;
                
              </td>
              <!-- page name and context (parent topics) -->
              <td align="left" width="79%">
                
                  <small><ul class="outline expandable">
 <li><a href="http://www.py.cz/PythonRoot" name="PythonRoot">PythonRoot</a>
<ul class="outline expandable">
  <li><a href="http://www.py.cz/RozhovoryPrednasky" name="RozhovoryPrednasky">RozhovoryPrednasky</a>
<ul class="outline expandable">
  <li><h1 style="display:inline;"><a href="http://www.py.cz/OptimalizacniHistorka/backlinks" title="which pages link to this one ?" name="OptimalizacniHistorka">OptimalizacniHistorka</a></h1></li>
</ul>
  </li>
</ul>
 </li>
</ul>
</small>
                
                
              </td>
              <!-- search form & page info -->
              <td class="searchbox" width="20%" align="right">
                
                  <input id="searchinput" class="formfield"
                         name="expr" type="text" size="20"
                         maxlength="100" value=""
                         title="search all pages" /><br />
                  <span class="lasteditor">last edited  <a href="http://www.py.cz/OptimalizacniHistorka/history" title="show last edit" >6 years</a> ago by <b>stibi</b></span><br>
                  <span class="creator">created 2009-10-03</span>   
                
                
              </td>
            </tr>
          </table>
        </form>
      </div>
      <div id="ratingform" align="right">  
      <!-- page rating form -->
      <div>
        <a name="ratingform"></a>
        <style type="text/css">
          input.rating {border:none;}
        </style>
        <form method="POST" id="ratingform"
              action="http://www.py.cz/OptimalizacniHistorka/vote">
           <input type="image" name="vote0" value="0"
                  alt="0" class="rating" width="14"
                  height="13"
                  src="http://www.py.cz/p_/sp"
                  style=""
                  title="click to vote 0 (poor) for this page (0 votes)" /><input
    type="image" name="vote1" value="1" alt="1"
    class="rating" src="http://www.py.cz/OptimalizacniHistorka/misc_/ZWiki/star_icon" style=""
    title="click to vote 1 (average) for this page (0 votes)" /><input
    type="image" name="vote2" value="2" alt="2"
    class="rating" src="http://www.py.cz/OptimalizacniHistorka/misc_/ZWiki/blank_star_icon"
    style=""
    title="click to vote 2 (above average) for this page (0 votes)" /><input
    type="image" name="vote3" value="3" alt="3"
    class="rating" src="http://www.py.cz/OptimalizacniHistorka/misc_/ZWiki/blank_star_icon"
    style=""
    title="click to vote 3 (good) for this page (0 votes)" /><input
    type="image" name="vote4" value="4" alt="4"
    class="rating" src="http://www.py.cz/OptimalizacniHistorka/misc_/ZWiki/blank_star_icon"
    style=""
    title="click to vote 4 (great) for this page (0 votes)" /><input
    type="image" name="vote5" value="5" alt="5"
    class="rating" src="http://www.py.cz/OptimalizacniHistorka/misc_/ZWiki/blank_star_icon"
    style=""
    title="click to vote 5 (superb) for this page (0 votes)" />
        </form>
      </div>
    </div>
    </div>
      <h1>Edit detail for OptimalizacniHistorka revision 2 of 1</h1>
      <div class="formcontent">
        <table border="0" cellspacing="0" width="100%">
          <tr valign="top">

            <td align="left">
              <form style="display:inline"
                    action="http://www.py.cz/OptimalizacniHistorka">
                <input type="submit" name="history:method"
                       value="Return to edit history" />
                
              </form>
            </td>

            <td align="center">
              <form style="display:inline"
                    action="http://www.py.cz/OptimalizacniHistorka/diff">
                <input type="hidden" name="rev" />
                
                <input disabled="1" value=" &lt; "
                       type="submit" accesskey="," />
              </form>
              <a style="font-weight:bold"
                 href="http://www.py.cz/OptimalizacniHistorka/diff?rev=2">2</a>
              <form style="display:inline"
                    action="http://www.py.cz/OptimalizacniHistorka/diff">
                <input type="hidden" name="rev" />
                
                <input disabled="1" value=" &gt; "
                       type="submit" accesskey="." />
              </form>
            </td>

            <td align="right">
              <form style="display:inline"
                    action="http://www.py.cz/OptimalizacniHistorka">
                <input type="hidden" name="rev" value="2" />
                <input value="Revert to this version"
                       type="submit" name="revert:method"
                       disabled="disabled" />
              </form>
            </td>

          </tr>
          <tr valign="top">
            <td colspan="3">
              <span>Editor:</span> stibi
              <br />
              <span>Time:</span> 2009/10/03 17:44:00 GMT+2
            </td>
          </tr>
          <tr valign="top">
            <td colspan="3">
              <span>Note:</span> <span
    style="font-weight:bold; font-style:italic;">díky</span>
            </td>
          </tr>
        </table>
        <hr />
        <pre>
<b>changed:</b><span style="color:red;text-decoration:line-through">
-</span><span style="color:green">
Optimalizační historka
=====================================================

Jednoho dne mi kamarád položil zdánlivě jednoduchou otázku: &quot;Jaký je nejlepší způsob převodu seznamu celých čísel na řetězec, pokud každé číslo vyjadřuje ASCII hodnotou nějakého znaku?&quot;. Například, seznam [97,98,99] by měl být převeden na řetězec 'abc'. Předpokládejme, že k tomu chceme vytvořit jedinou funkci.

První verze, se kterou jsem přišel, byla naprosto přímočará:
::

    def f1(seznam):
          retezec = &quot;&quot;
          for polozka in seznam:
              retezec = retezec + chr(polozka)
          return retezec

::

&quot;Tohle ale nemůže být ten nejrychlejší způsob&quot;, namítl kamarád. &quot;Co třeba toto:&quot;

::

    def f2(seznam):
          return reduce(lambda retezec, polozka: retezec + chr(polozka), seznam, &quot;&quot;)

::

Tato verze vykonává zcela stejné řetězcové operace, jako verze první, ale dokáže se vyhnout zbytečným režijním nákladům smyčky ``for`` pomocí rychlejší smyčky ve funkci ``reduce()``.

&quot;Samozřejmě&quot;, odpověděl jsem, &quot;ale moc si nepomůžeme - cena volání funkcí (lambda funkce) pro každou položku obsaženou v seznamu je poměrně vysoká. Vsadím se, že to bude pomalejší, režije volání funkcí v Pythonu je větší než režije smyčky ``for``&quot;.

(Ok, udělal jsem porovnání a ``f2()`` trvá o 60% déle než ``f1()``. Takže asi tak :-) )

&quot;Hmm&quot;, odvětil kamarád. &quot;Ale já to potřebuji mít ještě rychlejší&quot;. Nabídl jsem mu tedy následující verzi:

::

    def f3(seznam):
        retezec = &quot;&quot;
        for znak in map(chr, seznam):
            retezec = retezec + znak
        return retezec
        
::

K překvapení nás obou byla funkce ``f3()`` dvakrát rychlejší než funkce ``f1()``! Důvody, proč nás to tak překvapilo byly dva: za prvé, funkce používá více paměti (výsledkem ``map(chr,seznam)`` je další seznam stejné délky); a za druhé, funkce obsahuje dvě smyčky oproti jediné v ``f1()`` (jedna smyčka je zahrnuta ve funkci ``map()`` a druhá je smyčka ``for``).

Jasně, správné použití prostoru versus času je dobře známá věc, takže první důvod by nás tak překvapit neměl. Jak je ale možné, že dvě smyčky jsou rychlejší než jedna? Vysvětlením jsou dva důvody.

První, v ``f1()`` je funkce ``chr()`` vyhledávána Pythonem během každé jednotlivé iterace, kdežto v ``f3()`` se vyhledá pouze jednou (a to jako argument pro ``map()``). &quot;Toto vyhledávání je docela náročné&quot;, řekl jsem kamarádovi, &quot;pravidla dynamického prostoru v Pythonu říkají, že nejdříve se vyhledává (neúspěšně) v globálním slovníku současného modulu a teprve potom ve vestavěných funkcích (kde bude funkce opravdu nalezena). A navíc, kvůli způsobu hashování, je neúspěšné vyhledávání ve slovníku (v průměru) o trošku pomalejší než úspěšné.&quot;

Druhý důvod proč je ``f3()`` rychlejší než ``f1()`` je, že funkce ``chr(polozka)`` spuštěná přímo bytecode interpretem je obvykle pomalejší než spuštění pomocí ``map()`` - bytecode interpret musí vykonat tři instrukce pro každé volání (nahrát 'chr', nahrát 'polozka', zavolat), zatímco funkce ``map()`` dělá vše přímo v C.

To nás přivádí ke kompromisu, který nevyžaduje tolik paměti, ale dokáže značně urychlit vyhledávání funkce ``chr()``:

::

    def f4(seznam):
        retezec = &quot;&quot;
        vyhledane_chr = chr
        for polozka in seznam:
            retezec = retezec + vyhledane_chr(polozka)
        return retezec

::

Jak jsem předpokládali, ``f4()`` byla pomalejší než ``f3()``, ale pouze o 25%; tzn. byla stále o 40% rychlejší než ``f1()``. Vyhledávání lokálních proměnných je mnohem rychlejší než vyhledávání globálních nebo vestavěných proměnných: &quot;kompilátor&quot; Pythonu optimalizuje většinu funkcí tak, aby pro lokální proměnné nebylo potřeba vyhledávat ve slovníku, ale aby stačila jednoduchá indexovaná pole. Relativní rychlost ``f4()`` porovnaná s ``f1()`` a ``f2()`` ukazuje, že k rychlosti ``f3()`` přispívají oba dva zmíněné důvody, ale první (méně vyhledávání) je o trošku důležitější. (Abychom dostali přesnější data, museli bychom upravit interpret.)

Zatím naše nejlepší verze ``f3()`` je jenom dvakrát rychlejší než přímočará verze ``f1()``. Můžeme být lepší?

Obával jsem se, že kvadratické povaha algoritmu pro nás bude smrtící. Jako testovací data jsme zatím používali seznam 256 celých čísel, protože přesně k tomu kamarád tuto funkci potřeboval. Ale co se stane, když ji použijeme na seznam s dvěma tisíci znaky? V každé iteraci bychom zvětšovali stále delší a delší řetězce o jediný znak. Je jasně vidět, že vytvoření seznamu o délce N tímto způsobem vyžaduje, kromě nutné režije, celkově zkopírování 1 + 2 + 3 + ... + (N-1) znaků, neboli N*(N-1)/2 nebo 0.5*N**2 - 0.5*N. Dále se provede N paměťových alokací řetězce, ale pro dostatečně vysoké N, výraz obsahující N**2 naprosto převládne. A opravdu, pro osmkrát delší seznam (2048 položek) trvá funkce mnohem déle než jen osmkrát, je téměř šestnáctkrát delší. Ani jsem se neodvážil zkusit seznam 64 krát delší.

Existuje obecná technika, jak se takovémuto kvadratickému algoritmu vyhnout. Následující kód jsem napsal pro přesně 256 položek dlouhý seznam:

::

    def f5(seznam):
        retezec = &quot;&quot;
        for i in range(0, 256, 16): # 0, 16, 32, 48, 64, ...
            r = &quot;&quot;
            for znak in map(chr, seznam[i:i+16]):
                r = r + znak
            retezec = retezec + r
        return string

::

Bohužel, pro seznam 256 položek běžela tato verze o něco pomaleji (skoro o 20%) než ``f3()``. Jelikož vytvoření obecné verze by funkci ještě více zpomalilo, nezatěžovali jsme se dále s jejím vývojem (kromě porovnání s variantou bez použití ``map()``, která byla samozřejmě zase pomalejší).

Nakonec jsem zkusil úplně odlišný přístup: použít `jenom` vestavěné smyčky. Poznamenejme, že celá operace může být popsána takto: použij ``chr()`` na každou položku seznamu a pak spoj výsledné znaky. Vestavěné smyčky jsme už používali v první části: ``map()``.
Naštěstí modul `string` obsahuje i funkce na spojování řetězců implementované v C. Konkrétně ``string.joinfields(seznam_retezcu,oddelovac)`` spojí seznam řetězců vložením oddělovače, podle našeho výběru, mezi každé dvě sousední položky. Teď už nás nic nemůže zastavit od spojení seznamu znaků (řetězců o délce jedna), použitím prázdného řetězce jako oddělovače. Pohleďme:

::

    import string
        def f6(list):
            return string.joinfields(map(chr, list), &quot;&quot;)

::

Tato funkce běží čtyřikrát až pětkrát rychleji než dosavadní nejrychlejší soutěžící ``f3()``. A dokonce funkce ani nemá kvadratické chování, jako předchozí verze.

A vítězem se stává ...
----------------------------
Druhý den jsem si vzpomněl na trochu netypickou část Pythonu: modul ``array``. Modul má operace pro vytvoření pole jedno-bytových celých čísel ze seznamu Pythonovských čísel a každé pole umí zapsat do souboru nebo konvertovat na řetězec jako binární datovou strukturu. Takhle vypadá naše funkce vytvořená použitím zmíněných operací:

::

    import array
        def f7(list):
            return array.array('B', list).tostring()

::

Tohle je zhruba třikrát rychlejší než ``f6()`` a 12 až 15 krát rychlejší než ``f3()``! Používá se také méně přechodné paměti - pouze alokuje 2 objekty o N bytech (plus pevné režije), zatímco ``f6()`` začíná alokováním seznamu o N položkách, které obvykle zabírají 4N bytů (8N bytů na 64-bit počítačích) - za předpokladu, že objekty reprezentující znaky jsou sdílené s obdobnými objekty kdekoliv jinde v programu (podobně jako malá celá čísla, jsou i řetězce délky jedna většinou Pythonem kešovány).

&quot;Zastav&quot;, řekl kamarád, &quot;než se dostaneš do záporných časů - tohle je pro můj program již dostatečně rychlé&quot;. Souhlasil jsem, ačkoliv jsem chtěl vyzkoušet ještě jeden způsob: napsat celou funkci v C. Taková funkce by měla minimum paměťových nároků (alokovala by řetězec délky N hned na začátku) a ušetřila by několik instrukcí v C kódu, které jsou v modulu array kvůli potřebné obecnosti (podporuje celá čísla o 1,2 a 4 bytech). Funkce by se však nemohla vyhnout převodu Pythonovských celých čísel ze seznamu na celočíselné typy v C, což je časově docela náročná operace v Python-C API, a tudíž očekávané zlepšení výkonu bylo asi nepodstatné. Když jsem vzal v úvahu úsilí na napsání a otestování tohoto rozšíření (v porovnání s předešlými jednořádkovými funkcemi) a stejně tak závislost na nestandardním Pythonovském funkci, rozhodl jsem se tím dále nezabývat.

Závěr
------------------------------
Pokud cítíte potřebu po zvyšování rychlosti, používejte vestavěné funkce - nikdy nemůžete být lepší než smyčky napsané v C. Pro nalezení vhodných vestavěných funkcí používejte manuál k základním knihovnám a pokud takovou funkci nenajdete, držte se následujících základních pravidel pro optimalizaci smyček:

* `Pravidlo jedna`: optimalizujte jen pokud máte nějak prokázané, že je funkce opravdu pomalá. Optimalizujte vždy jen nejhlouběji vnořenou smyčku. (Toto pravidlo neplatí jen pro Python, ale opakování základů nikomu neublíží, zvlášť když může ušetřit množství zbytečné práce.)
* Co je malé, to je hezké. Kvůli množství instrukcí v pythonovském bytecodu a vyhledání proměnných, se málokdy vyplatí přidávat extra testy na ušetření trochy práce.
* Používejte vnitřní operace. Smyčka ve funkci ``map()`` je mnohem rychlejší než explicitní smyčka ``for``. Konstrukce ``while`` s počítadlem smyček je dokonce ještě pomalejší.
* Uvnitř smyček se vyhněte volání funkcí napsaných v Pythonu (včetně volání lambda funkcí). Jednořádkové smyčky nám mohou šetřit nemalé množství času.
* Lokální proměnné jsou rychlejší než globální. Pokud používáte globální konstanty ve smyčkách, zkopírujte je do lokálních těsně předtím, než smyčka začne. Jména funkcí v Pythonu (globální nebo vestavěné) jsou také globální konstanty!
* Zkuste pomocí ``map()``, ``filter()`` nebo ``reduce()`` nahradit explicitní smyčky ``for``, ale jen v případě, že můžete použít vestavěné funkce: ``map`` s vestavěnou funkcí je rychlejší než smyčka ``for``, ale smyčka ``for`` s in-line kódem překoná ``map`` s lambda funkcí!
* Zkontrolujte zda váš algoritmus nemá kvadratické chování. Komplexní algoritmus pro odstranění kvadraticity se vyplatí jen pro velká N - pro malá N bývá komplexní algoritmus zbytečný. V našem případě bylo 256 dostatečně malé, takže jednodušší verze byla pořád o trošku rychlejší. Vaše hraniční hodnota N se může lišit a je rozhodně vhodné ji řádně otestovat.
* A v neposlední řadě: shormážděte si potřebná data. Excelentní Pythonovský profile modul může rychle ukázat na slabá místa vašeho kódu. Když přemýšlíte nad jinou verzí algoritmu, otestujte ji ve smyčce s použitím funkce ``time.clock()``.

Mimochodem, tady je funkce, kterou na testování používám já. Testovanou funkci ``f()`` volám n*10 krát s argumentem ``a`` a následně vypíšu jméno funkce a použitý čas zaokrouhlený na milisekundy. Desetinásobné volání minimalizuje zkreslení potřebného času kvůli režiji smyčky. Samozřejmě můžete jít i dále a udělat stonásobné volání ... I výraz ``range(n)`` je vykonán před začátkem měření času, aby náš časový výsledek byl co nejvěrohodnější. Pokud vám ještě pořád přijde, že režije smyčky bude výsledek příliš zkreslovat, můžete vše kalibrovat pomocí prázdné funkce.

::

    import time
    def timing(f, n, a):
        print f.__name__,
        r = range(n)
        t1 = time.clock()
        for i in r:
            f(a); f(a); f(a); f(a); f(a); f(a); f(a); f(a); f(a); f(a)
        t2 = time.clock()
        print round(t2-t1, 3)

::


Doslov
-------------------------------
Po pár dnech se kamarád vrátil s další otázkou: &quot;Jak udělat obrácenou operaci?. Jak z řetězce vytvořit seznam ASCII hodnot?&quot;. &quot;Ale ne, jsem zase na začátku&quot;, proběhlo mi hlavou ...

Tentokrát to však bylo docela bezbolestné. Máme dva kandidáty, jeden zcela očividný:

::

    def g1(string):
        return map(ord, string)

::

a druhý, už ne tak zřejmý:

::

    import array
    def g2(string):
        return array.array('b', string).tolist()

::

Testování odhalilo, že funkce ``g2()`` je zhruba pětkrát rychlejší než ``g1()``. Je tady však jedno ale: ``g2()`` vrací seznam celých čísel v rozsahu -128...127, kdežto ``g1()`` vrací celá čísla mezi 0..255. Pokud chceme pouze kladná čísla, pak ``g1()`` je rychlejší než jakákoliv transformace výstupu funkce ``g2()``. (Pozn. po napsání této eseje byl v modulu array přidán parametr 'B', který uchovává bezznaménkové byty, takže teď už není žádný rozumný důvod k preferování funkce ``g1()``.)

--------------------------------------------

**Copyright** Python Software Foundation

Přeloženo se svolením autora - Guida van Rossuma z http://www.python.org/doc/essays/list2str/



From stibi Sat Oct 3 17:44:00 +0200 2009
From: stibi
Date: Sat, 03 Oct 2009 17:44:00 +0200
Subject: díky
Message-ID: &lt;20091003174400+0200@www.py.cz&gt;

Moc díky za překlad. Velmi zajímavé .. pro mě takový další level, musím to znovu důkladněji prostudovat.</span>
</pre>
        <hr />
        <div><h1 class="title">Optimalizační historka</h1>
<p>Jednoho dne mi kamarád položil zdánlivě jednoduchou otázku: &quot;Jaký je nejlepší způsob převodu seznamu celých čísel na řetězec, pokud každé číslo vyjadřuje ASCII hodnotou nějakého znaku?&quot;. Například, seznam [97,98,99]<a class="new visualNoPrint" href="http://www.py.cz/OptimalizacniHistorka/createform?page=97%2C98%2C99" title="create this page">?</a> by měl být převeden na řetězec 'abc'. Předpokládejme, že k tomu chceme vytvořit jedinou funkci.</p>
<p>První verze, se kterou jsem přišel, byla naprosto přímočará:</p>
<pre class="literal-block">
def f1(seznam):
      retezec = &quot;&quot;
      for polozka in seznam:
          retezec = retezec + chr(polozka)
      return retezec
</pre>
<pre class="literal-block">
&quot;Tohle ale nemůže být ten nejrychlejší způsob&quot;, namítl kamarád. &quot;Co třeba toto:&quot;
</pre>
<pre class="literal-block">
def f2(seznam):
      return reduce(lambda retezec, polozka: retezec + chr(polozka), seznam, &quot;&quot;)
</pre>
<p>Tato verze vykonává zcela stejné řetězcové operace, jako verze první, ale dokáže se vyhnout zbytečným režijním nákladům smyčky <tt class="docutils literal">for</tt> pomocí rychlejší smyčky ve funkci <tt class="docutils literal">reduce()</tt>.</p>
<p>&quot;Samozřejmě&quot;, odpověděl jsem, &quot;ale moc si nepomůžeme - cena volání funkcí (lambda funkce) pro každou položku obsaženou v seznamu je poměrně vysoká. Vsadím se, že to bude pomalejší, režije volání funkcí v Pythonu je větší než režije smyčky <tt class="docutils literal">for</tt>&quot;.</p>
<p>(Ok, udělal jsem porovnání a <tt class="docutils literal">f2()</tt> trvá o 60% déle než <tt class="docutils literal">f1()</tt>. Takže asi tak :-) )</p>
<p>&quot;Hmm&quot;, odvětil kamarád. &quot;Ale já to potřebuji mít ještě rychlejší&quot;. Nabídl jsem mu tedy následující verzi:</p>
<pre class="literal-block">
def f3(seznam):
    retezec = &quot;&quot;
    for znak in map(chr, seznam):
        retezec = retezec + znak
    return retezec
</pre>
<p>K překvapení nás obou byla funkce <tt class="docutils literal">f3()</tt> dvakrát rychlejší než funkce <tt class="docutils literal">f1()</tt>! Důvody, proč nás to tak překvapilo byly dva: za prvé, funkce používá více paměti (výsledkem <tt class="docutils literal">map(chr,seznam)</tt> je další seznam stejné délky); a za druhé, funkce obsahuje dvě smyčky oproti jediné v <tt class="docutils literal">f1()</tt> (jedna smyčka je zahrnuta ve funkci <tt class="docutils literal">map()</tt> a druhá je smyčka <tt class="docutils literal">for</tt>).</p>
<p>Jasně, správné použití prostoru versus času je dobře známá věc, takže první důvod by nás tak překvapit neměl. Jak je ale možné, že dvě smyčky jsou rychlejší než jedna? Vysvětlením jsou dva důvody.</p>
<p>První, v <tt class="docutils literal">f1()</tt> je funkce <tt class="docutils literal">chr()</tt> vyhledávána Pythonem během každé jednotlivé iterace, kdežto v <tt class="docutils literal">f3()</tt> se vyhledá pouze jednou (a to jako argument pro <tt class="docutils literal">map()</tt>). &quot;Toto vyhledávání je docela náročné&quot;, řekl jsem kamarádovi, &quot;pravidla dynamického prostoru v Pythonu říkají, že nejdříve se vyhledává (neúspěšně) v globálním slovníku současného modulu a teprve potom ve vestavěných funkcích (kde bude funkce opravdu nalezena). A navíc, kvůli způsobu hashování, je neúspěšné vyhledávání ve slovníku (v průměru) o trošku pomalejší než úspěšné.&quot;</p>
<p>Druhý důvod proč je <tt class="docutils literal">f3()</tt> rychlejší než <tt class="docutils literal">f1()</tt> je, že funkce <tt class="docutils literal">chr(polozka)</tt> spuštěná přímo bytecode interpretem je obvykle pomalejší než spuštění pomocí <tt class="docutils literal">map()</tt> - bytecode interpret musí vykonat tři instrukce pro každé volání (nahrát 'chr', nahrát 'polozka', zavolat), zatímco funkce <tt class="docutils literal">map()</tt> dělá vše přímo v C.</p>
<p>To nás přivádí ke kompromisu, který nevyžaduje tolik paměti, ale dokáže značně urychlit vyhledávání funkce <tt class="docutils literal">chr()</tt>:</p>
<pre class="literal-block">
def f4(seznam):
    retezec = &quot;&quot;
    vyhledane_chr = chr
    for polozka in seznam:
        retezec = retezec + vyhledane_chr(polozka)
    return retezec
</pre>
<p>Jak jsem předpokládali, <tt class="docutils literal">f4()</tt> byla pomalejší než <tt class="docutils literal">f3()</tt>, ale pouze o 25%; tzn. byla stále o 40% rychlejší než <tt class="docutils literal">f1()</tt>. Vyhledávání lokálních proměnných je mnohem rychlejší než vyhledávání globálních nebo vestavěných proměnných: &quot;kompilátor&quot; Pythonu optimalizuje většinu funkcí tak, aby pro lokální proměnné nebylo potřeba vyhledávat ve slovníku, ale aby stačila jednoduchá indexovaná pole. Relativní rychlost <tt class="docutils literal">f4()</tt> porovnaná s <tt class="docutils literal">f1()</tt> a <tt class="docutils literal">f2()</tt> ukazuje, že k rychlosti <tt class="docutils literal">f3()</tt> přispívají oba dva zmíněné důvody, ale první (méně vyhledávání) je o trošku důležitější. (Abychom dostali přesnější data, museli bychom upravit interpret.)</p>
<p>Zatím naše nejlepší verze <tt class="docutils literal">f3()</tt> je jenom dvakrát rychlejší než přímočará verze <tt class="docutils literal">f1()</tt>. Můžeme být lepší?</p>
<p>Obával jsem se, že kvadratické povaha algoritmu pro nás bude smrtící. Jako testovací data jsme zatím používali seznam 256 celých čísel, protože přesně k tomu kamarád tuto funkci potřeboval. Ale co se stane, když ji použijeme na seznam s dvěma tisíci znaky? V každé iteraci bychom zvětšovali stále delší a delší řetězce o jediný znak. Je jasně vidět, že vytvoření seznamu o délce N tímto způsobem vyžaduje, kromě nutné režije, celkově zkopírování 1 + 2 + 3 + ... + (N-1) znaků, neboli N*(N-1)/2 nebo 0.5*N**2 - 0.5*N. Dále se provede N paměťových alokací řetězce, ale pro dostatečně vysoké N, výraz obsahující N**2 naprosto převládne. A opravdu, pro osmkrát delší seznam (2048 položek) trvá funkce mnohem déle než jen osmkrát, je téměř šestnáctkrát delší. Ani jsem se neodvážil zkusit seznam 64 krát delší.</p>
<p>Existuje obecná technika, jak se takovémuto kvadratickému algoritmu vyhnout. Následující kód jsem napsal pro přesně 256 položek dlouhý seznam:</p>
<pre class="literal-block">
def f5(seznam):
    retezec = &quot;&quot;
    for i in range(0, 256, 16): # 0, 16, 32, 48, 64, ...
        r = &quot;&quot;
        for znak in map(chr, seznam[i:i+16]):
            r = r + znak
        retezec = retezec + r
    return string
</pre>
<p>Bohužel, pro seznam 256 položek běžela tato verze o něco pomaleji (skoro o 20%) než <tt class="docutils literal">f3()</tt>. Jelikož vytvoření obecné verze by funkci ještě více zpomalilo, nezatěžovali jsme se dále s jejím vývojem (kromě porovnání s variantou bez použití <tt class="docutils literal">map()</tt>, která byla samozřejmě zase pomalejší).</p>
<p>Nakonec jsem zkusil úplně odlišný přístup: použít <cite>jenom</cite> vestavěné smyčky. Poznamenejme, že celá operace může být popsána takto: použij <tt class="docutils literal">chr()</tt> na každou položku seznamu a pak spoj výsledné znaky. Vestavěné smyčky jsme už používali v první části: <tt class="docutils literal">map()</tt>.
Naštěstí modul <cite>string</cite> obsahuje i funkce na spojování řetězců implementované v C. Konkrétně <tt class="docutils literal">string.joinfields(seznam_retezcu,oddelovac)</tt> spojí seznam řetězců vložením oddělovače, podle našeho výběru, mezi každé dvě sousední položky. Teď už nás nic nemůže zastavit od spojení seznamu znaků (řetězců o délce jedna), použitím prázdného řetězce jako oddělovače. Pohleďme:</p>
<pre class="literal-block">
import string
    def f6(list):
        return string.joinfields(map(chr, list), &quot;&quot;)
</pre>
<p>Tato funkce běží čtyřikrát až pětkrát rychleji než dosavadní nejrychlejší soutěžící <tt class="docutils literal">f3()</tt>. A dokonce funkce ani nemá kvadratické chování, jako předchozí verze.</p>
<div class="section" id="a-vitezem-se-stava">
<h2>A vítězem se stává ...</h2>
<p>Druhý den jsem si vzpomněl na trochu netypickou část Pythonu: modul <tt class="docutils literal">array</tt>. Modul má operace pro vytvoření pole jedno-bytových celých čísel ze seznamu Pythonovských čísel a každé pole umí zapsat do souboru nebo konvertovat na řetězec jako binární datovou strukturu. Takhle vypadá naše funkce vytvořená použitím zmíněných operací:</p>
<pre class="literal-block">
import array
    def f7(list):
        return array.array('B', list).tostring()
</pre>
<p>Tohle je zhruba třikrát rychlejší než <tt class="docutils literal">f6()</tt> a 12 až 15 krát rychlejší než <tt class="docutils literal">f3()</tt>! Používá se také méně přechodné paměti - pouze alokuje 2 objekty o N bytech (plus pevné režije), zatímco <tt class="docutils literal">f6()</tt> začíná alokováním seznamu o N položkách, které obvykle zabírají 4N bytů (8N bytů na 64-bit počítačích) - za předpokladu, že objekty reprezentující znaky jsou sdílené s obdobnými objekty kdekoliv jinde v programu (podobně jako malá celá čísla, jsou i řetězce délky jedna většinou Pythonem kešovány).</p>
<p>&quot;Zastav&quot;, řekl kamarád, &quot;než se dostaneš do záporných časů - tohle je pro můj program již dostatečně rychlé&quot;. Souhlasil jsem, ačkoliv jsem chtěl vyzkoušet ještě jeden způsob: napsat celou funkci v C. Taková funkce by měla minimum paměťových nároků (alokovala by řetězec délky N hned na začátku) a ušetřila by několik instrukcí v C kódu, které jsou v modulu array kvůli potřebné obecnosti (podporuje celá čísla o 1,2 a 4 bytech). Funkce by se však nemohla vyhnout převodu Pythonovských celých čísel ze seznamu na celočíselné typy v C, což je časově docela náročná operace v Python-C API, a tudíž očekávané zlepšení výkonu bylo asi nepodstatné. Když jsem vzal v úvahu úsilí na napsání a otestování tohoto rozšíření (v porovnání s předešlými jednořádkovými funkcemi) a stejně tak závislost na nestandardním Pythonovském funkci, rozhodl jsem se tím dále nezabývat.</p>
</div>
<div class="section" id="zaver">
<h2>Závěr</h2>
<p>Pokud cítíte potřebu po zvyšování rychlosti, používejte vestavěné funkce - nikdy nemůžete být lepší než smyčky napsané v C. Pro nalezení vhodných vestavěných funkcí používejte manuál k základním knihovnám a pokud takovou funkci nenajdete, držte se následujících základních pravidel pro optimalizaci smyček:</p>
<ul class="simple">
<li><cite>Pravidlo jedna</cite>: optimalizujte jen pokud máte nějak prokázané, že je funkce opravdu pomalá. Optimalizujte vždy jen nejhlouběji vnořenou smyčku. (Toto pravidlo neplatí jen pro Python, ale opakování základů nikomu neublíží, zvlášť když může ušetřit množství zbytečné práce.)</li>
<li>Co je malé, to je hezké. Kvůli množství instrukcí v pythonovském bytecodu a vyhledání proměnných, se málokdy vyplatí přidávat extra testy na ušetření trochy práce.</li>
<li>Používejte vnitřní operace. Smyčka ve funkci <tt class="docutils literal">map()</tt> je mnohem rychlejší než explicitní smyčka <tt class="docutils literal">for</tt>. Konstrukce <tt class="docutils literal">while</tt> s počítadlem smyček je dokonce ještě pomalejší.</li>
<li>Uvnitř smyček se vyhněte volání funkcí napsaných v Pythonu (včetně volání lambda funkcí). Jednořádkové smyčky nám mohou šetřit nemalé množství času.</li>
<li>Lokální proměnné jsou rychlejší než globální. Pokud používáte globální konstanty ve smyčkách, zkopírujte je do lokálních těsně předtím, než smyčka začne. Jména funkcí v Pythonu (globální nebo vestavěné) jsou také globální konstanty!</li>
<li>Zkuste pomocí <tt class="docutils literal">map()</tt>, <tt class="docutils literal">filter()</tt> nebo <tt class="docutils literal">reduce()</tt> nahradit explicitní smyčky <tt class="docutils literal">for</tt>, ale jen v případě, že můžete použít vestavěné funkce: <tt class="docutils literal">map</tt> s vestavěnou funkcí je rychlejší než smyčka <tt class="docutils literal">for</tt>, ale smyčka <tt class="docutils literal">for</tt> s in-line kódem překoná <tt class="docutils literal">map</tt> s lambda funkcí!</li>
<li>Zkontrolujte zda váš algoritmus nemá kvadratické chování. Komplexní algoritmus pro odstranění kvadraticity se vyplatí jen pro velká N - pro malá N bývá komplexní algoritmus zbytečný. V našem případě bylo 256 dostatečně malé, takže jednodušší verze byla pořád o trošku rychlejší. Vaše hraniční hodnota N se může lišit a je rozhodně vhodné ji řádně otestovat.</li>
<li>A v neposlední řadě: shormážděte si potřebná data. Excelentní Pythonovský profile modul může rychle ukázat na slabá místa vašeho kódu. Když přemýšlíte nad jinou verzí algoritmu, otestujte ji ve smyčce s použitím funkce <tt class="docutils literal">time.clock()</tt>.</li>
</ul>
<p>Mimochodem, tady je funkce, kterou na testování používám já. Testovanou funkci <tt class="docutils literal">f()</tt> volám n*10 krát s argumentem <tt class="docutils literal">a</tt> a následně vypíšu jméno funkce a použitý čas zaokrouhlený na milisekundy. Desetinásobné volání minimalizuje zkreslení potřebného času kvůli režiji smyčky. Samozřejmě můžete jít i dále a udělat stonásobné volání ... I výraz <tt class="docutils literal">range(n)</tt> je vykonán před začátkem měření času, aby náš časový výsledek byl co nejvěrohodnější. Pokud vám ještě pořád přijde, že režije smyčky bude výsledek příliš zkreslovat, můžete vše kalibrovat pomocí prázdné funkce.</p>
<pre class="literal-block">
import time
def timing(f, n, a):
    print f.__name__,
    r = range(n)
    t1 = time.clock()
    for i in r:
        f(a); f(a); f(a); f(a); f(a); f(a); f(a); f(a); f(a); f(a)
    t2 = time.clock()
    print round(t2-t1, 3)
</pre>
</div>
<div class="section" id="doslov">
<h2>Doslov</h2>
<p>Po pár dnech se kamarád vrátil s další otázkou: &quot;Jak udělat obrácenou operaci?. Jak z řetězce vytvořit seznam ASCII hodnot?&quot;. &quot;Ale ne, jsem zase na začátku&quot;, proběhlo mi hlavou ...</p>
<p>Tentokrát to však bylo docela bezbolestné. Máme dva kandidáty, jeden zcela očividný:</p>
<pre class="literal-block">
def g1(string):
    return map(ord, string)
</pre>
<p>a druhý, už ne tak zřejmý:</p>
<pre class="literal-block">
import array
def g2(string):
    return array.array('b', string).tolist()
</pre>
<p>Testování odhalilo, že funkce <tt class="docutils literal">g2()</tt> je zhruba pětkrát rychlejší než <tt class="docutils literal">g1()</tt>. Je tady však jedno ale: <tt class="docutils literal">g2()</tt> vrací seznam celých čísel v rozsahu -128...127, kdežto <tt class="docutils literal">g1()</tt> vrací celá čísla mezi 0..255. Pokud chceme pouze kladná čísla, pak <tt class="docutils literal">g1()</tt> je rychlejší než jakákoliv transformace výstupu funkce <tt class="docutils literal">g2()</tt>. (Pozn. po napsání této eseje byl v modulu array přidán parametr 'B', který uchovává bezznaménkové byty, takže teď už není žádný rozumný důvod k preferování funkce <tt class="docutils literal">g1()</tt>.)</p>
<hr class="docutils" />
<p><strong>Copyright</strong> Python Software Foundation</p>
<p>Přeloženo se svolením autora - Guida van Rossuma z <a class="reference external" href="http://www.python.org/doc/essays/list2str/">http://www.python.org/doc/essays/list2str/</a></p>
<p>
</p>
<p class="commentheading"><strong>díky</strong> --stibi, Sat, 03 Oct 2009 17:44:00 +0200 <a class="reference external" href="http://localhost:18081/www.py.cz/OptimalizacniHistorka?subject=d%C3%ADky&amp;in_reply_to=%3C20091003174400%2B0200%40www.py.cz%3E#bottom">reply</a></p>
<p class="commentbody">Moc díky za překlad. Velmi zajímavé .. pro mě takový další level, musím to znovu důkladněji prostudovat.</p>
</div>
</div>
      </div>
    </div>
    
  </body>

<!-- Mirrored from www.py.cz/OptimalizacniHistorka/diff by HTTrack Website Copier/3.x [XR&CO'2014], Sun, 20 Mar 2016 21:03:36 GMT -->
</html>

